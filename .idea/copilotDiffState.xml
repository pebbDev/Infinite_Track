<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/data/soucre/network/response/AttendanceResponse.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/data/soucre/network/response/AttendanceResponse.kt" />
              <option name="originalContent" value="package com.example.infinite_track.data.soucre.network.response&#10;&#10;import kotlinx.parcelize.Parcelize&#10;import android.os.Parcelable&#10;import com.google.gson.annotations.SerializedName&#10;&#10;@Parcelize&#10;data class AttendanceResponse(&#10;&#9;@field:SerializedName(&quot;success&quot;)&#10;&#9;val success: Boolean,&#10;&#10;&#9;@field:SerializedName(&quot;message&quot;)&#10;&#9;val message: String,&#10;&#10;&#9;@field:SerializedName(&quot;data&quot;)&#10;&#9;val data: AttendanceData&#10;) : Parcelable&#10;&#10;@Parcelize&#10;data class AttendanceData(&#10;&#9;@field:SerializedName(&quot;id_attendance&quot;)&#10;&#9;val idAttendance: Int,&#10;&#10;&#9;@field:SerializedName(&quot;user_id&quot;)&#10;&#9;val userId: Int,&#10;&#10;&#9;@field:SerializedName(&quot;category_id&quot;)&#10;&#9;val categoryId: Int,&#10;&#10;&#9;@field:SerializedName(&quot;status_id&quot;)&#10;&#9;val statusId: Int,&#10;&#10;&#9;@field:SerializedName(&quot;location_id&quot;)&#10;&#9;val locationId: Int,&#10;&#10;&#9;@field:SerializedName(&quot;booking_id&quot;)&#10;&#9;val bookingId: Int? = null,&#10;&#10;&#9;@field:SerializedName(&quot;time_in&quot;)&#10;&#9;val timeIn: String,&#10;&#10;&#9;@field:SerializedName(&quot;time_out&quot;)&#10;&#9;val timeOut: String? = null,&#10;&#10;&#9;@field:SerializedName(&quot;work_hour&quot;)&#10;&#9;val workHour: String,&#10;&#10;&#9;@field:SerializedName(&quot;attendance_date&quot;)&#10;&#9;val attendanceDate: String,&#10;&#10;&#9;@field:SerializedName(&quot;notes&quot;)&#10;&#9;val notes: String,&#10;&#10;&#9;@field:SerializedName(&quot;created_at&quot;)&#10;&#9;val createdAt: String? = null,&#10;&#10;&#9;@field:SerializedName(&quot;updated_at&quot;)&#10;&#9;val updatedAt: String? = null&#10;) : Parcelable&#10;" />
              <option name="updatedContent" value="package com.example.infinite_track.data.soucre.network.response&#10;&#10;import kotlinx.parcelize.Parcelize&#10;import android.os.Parcelable&#10;import com.google.gson.annotations.SerializedName&#10;&#10;@Parcelize&#10;data class AttendanceResponse(&#10;&#9;@field:SerializedName(&quot;success&quot;)&#10;&#9;val success: Boolean,&#10;&#10;&#9;@field:SerializedName(&quot;message&quot;)&#10;&#9;val message: String,&#10;&#10;&#9;@field:SerializedName(&quot;data&quot;)&#10;&#9;val data: AttendanceData&#10;) : Parcelable&#10;&#10;@Parcelize&#10;data class AttendanceData(&#10;&#9;@field:SerializedName(&quot;id_attendance&quot;)&#10;&#9;val idAttendance: Int,&#10;&#10;&#9;@field:SerializedName(&quot;user_id&quot;)&#10;&#9;val userId: Int,&#10;&#10;&#9;@field:SerializedName(&quot;category_id&quot;)&#10;&#9;val categoryId: Int,&#10;&#10;&#9;@field:SerializedName(&quot;status_id&quot;)&#10;&#9;val statusId: Int,&#10;&#10;&#9;@field:SerializedName(&quot;location_id&quot;)&#10;&#9;val locationId: Int,&#10;&#10;&#9;@field:SerializedName(&quot;booking_id&quot;)&#10;&#9;val bookingId: Int? = null,&#10;&#10;&#9;@field:SerializedName(&quot;time_in&quot;)&#10;&#9;val timeIn: String,&#10;&#10;&#9;@field:SerializedName(&quot;time_out&quot;)&#10;&#9;val timeOut: String? = null,&#10;&#10;&#9;@field:SerializedName(&quot;work_hour&quot;)&#10;&#9;val workHour: String,&#10;&#10;&#9;@field:SerializedName(&quot;attendance_date&quot;)&#10;&#9;val attendanceDate: String,&#10;&#10;&#9;@field:SerializedName(&quot;notes&quot;)&#10;&#9;val notes: String,&#10;&#10;&#9;@field:SerializedName(&quot;created_at&quot;)&#10;&#9;val createdAt: String? = null,&#10;&#10;&#9;@field:SerializedName(&quot;updated_at&quot;)&#10;&#9;val updatedAt: String? = null&#10;) : Parcelable" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/domain/manager/SessionManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/domain/manager/SessionManager.kt" />
              <option name="updatedContent" value="package com.example.infinite_track.domain.manager&#10;&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;/**&#10; * Manager untuk menangani state sesi aplikasi&#10; * Termasuk notifikasi ketika sesi berakhir (401 error)&#10; */&#10;@Singleton&#10;class SessionManager @Inject constructor() {&#10;    &#10;    private val _sessionExpired = MutableStateFlow(false)&#10;    val sessionExpired: StateFlow&lt;Boolean&gt; = _sessionExpired.asStateFlow()&#10;    &#10;    /**&#10;     * Trigger session expiration&#10;     * Dipanggil oleh AuthInterceptor ketika mendapat 401 error&#10;     */&#10;    fun triggerSessionExpired() {&#10;        _sessionExpired.value = true&#10;    }&#10;    &#10;    /**&#10;     * Reset session expiration state&#10;     * Dipanggil setelah user dismiss dialog atau navigate ke login&#10;     */&#10;    fun resetSessionExpired() {&#10;        _sessionExpired.value = false&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/domain/use_case/auth/VerifyFaceUseCase.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/domain/use_case/auth/VerifyFaceUseCase.kt" />
              <option name="originalContent" value="package com.example.infinite_track.domain.use_case.auth&#10;&#10;import android.graphics.Bitmap&#10;import com.example.infinite_track.data.face.FaceProcessor&#10;import com.example.infinite_track.domain.repository.AuthRepository&#10;import kotlinx.coroutines.flow.first&#10;import javax.inject.Inject&#10;&#10;/**&#10; * Use case for verifying face against stored embedding&#10; * Handles face comparison for attendance check-in/check-out&#10; */&#10;class VerifyFaceUseCase @Inject constructor(&#10;    private val faceProcessor: FaceProcessor,&#10;    private val authRepository: AuthRepository&#10;) {&#10;    companion object {&#10;        private const val SIMILARITY_THRESHOLD = 0.8f // Minimum similarity for face match&#10;    /**&#10;     * Verifies captured face against stored user embedding&#10;     * @param capturedFaceBitmap Bitmap of the captured face&#10;     * @return Result&lt;Boolean&gt; indicating if face matches (true) or not (false)&#10;     * @param capturedFaceBitmap Bitmap of the captured face&#10;    suspend operator fun invoke(capturedFaceBitmap: Bitmap): Result&lt;Boolean&gt; {&#10;        return try {&#10;            // Get current user data with stored face embedding&#10;            val currentUser = authRepository.getLoggedInUser().first()&#10;                ?: return Result.failure(Exception(&quot;No logged in user found&quot;))&#10;&#10;            val storedEmbedding = currentUser.faceEmbedding&#10;                ?: return Result.failure(Exception(&quot;No stored face embedding found. Please update your profile.&quot;))&#10;&#10;            // Generate embedding from captured bitmap&#10;            val embeddingResult = generateEmbeddingFromBitmap(capturedFaceBitmap)&#10;            // Generate embedding from captured bitmap&#10;            if (embeddingResult.isFailure) {&#10;                return Result.failure(&#10;                    embeddingResult.exceptionOrNull()&#10;                        ?: Exception(&quot;Failed to generate embedding from captured face&quot;)&#10;                )&#10;            }&#10;&#10;            val capturedEmbedding = embeddingResult.getOrNull()!!&#10;&#10;            // Compare embeddings using cosine similarity&#10;            val similarity = calculateCosineSimilarity(storedEmbedding, capturedEmbedding)&#10;&#10;            // Return true if similarity exceeds threshold&#10;            val isMatch = similarity &gt;= SIMILARITY_THRESHOLD&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    /**&#10;     * Generate embedding from bitmap using FaceProcessor&#10;     * Enhanced to work directly with Bitmap without URL&#10;    private suspend fun generateEmbeddingFromBitmap(bitmap: Bitmap): Result&lt;ByteArray&gt; {&#10;        return try {&#10;            // Use the new direct bitmap processing method from FaceProcessor&#10;            faceProcessor.generateEmbeddingFromBitmap(bitmap)&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Create temporary file from bitmap for processing&#10;     * This method is now deprecated in favor of direct bitmap processing&#10;     */&#10;    @Deprecated(&quot;Use generateEmbeddingFromBitmap directly&quot;)&#10;    private fun createTempImageFile(bitmap: Bitmap): java.io.File? {&#10;        return try {&#10;            val tempFile = java.io.File.createTempFile(&quot;face_capture&quot;, &quot;.jpg&quot;)&#10;            val outputStream = java.io.FileOutputStream(tempFile)&#10;            bitmap.compress(Bitmap.CompressFormat.JPEG, 90, outputStream)&#10;            outputStream.flush()&#10;            outputStream.close()&#10;            tempFile&#10;        } catch (e: Exception) {&#10;            null&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Calculate cosine similarity between two embeddings&#10;     * @param embedding1 First embedding (stored)&#10;     * @param embedding2 Second embedding (captured)&#10;     * @return Similarity score between 0.0 and 1.0&#10;     */&#10;    private fun calculateCosineSimilarity(embedding1: ByteArray, embedding2: ByteArray): Float {&#10;        if (embedding1.size != embedding2.size) {&#10;            return 0f&#10;        }&#10;&#10;        // Convert ByteArray to FloatArray for calculation&#10;        val floats1 = byteArrayToFloatArray(embedding1)&#10;        val floats2 = byteArrayToFloatArray(embedding2)&#10;&#10;        var dotProduct = 0.0&#10;        var normA = 0.0&#10;        var normB = 0.0&#10;&#10;        for (i in floats1.indices) {&#10;            dotProduct += floats1[i] * floats2[i]&#10;            normA += floats1[i] * floats1[i]&#10;            normB += floats2[i] * floats2[i]&#10;        }&#10;&#10;        return if (normA == 0.0 || normB == 0.0) {&#10;            0f&#10;        } else {&#10;            (dotProduct / (kotlin.math.sqrt(normA) * kotlin.math.sqrt(normB))).toFloat()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Convert ByteArray to FloatArray for similarity calculation&#10;     */&#10;    private fun byteArrayToFloatArray(byteArray: ByteArray): FloatArray {&#10;        val floatArray = FloatArray(byteArray.size / 4)&#10;        val buffer = java.nio.ByteBuffer.wrap(byteArray)&#10;        buffer.order(java.nio.ByteOrder.LITTLE_ENDIAN)&#10;&#10;        for (i in floatArray.indices) {&#10;            floatArray[i] = buffer.getFloat(i * 4)&#10;        }&#10;&#10;        return floatArray&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.infinite_track.domain.use_case.auth&#10;&#10;import android.graphics.Bitmap&#10;import com.example.infinite_track.data.face.FaceProcessor&#10;import com.example.infinite_track.domain.repository.AuthRepository&#10;import kotlinx.coroutines.flow.first&#10;import javax.inject.Inject&#10;&#10;/**&#10; * Use case for verifying face against stored embedding&#10; * Handles face comparison for attendance check-in/check-out&#10; */&#10;class VerifyFaceUseCase @Inject constructor(&#10;    private val faceProcessor: FaceProcessor,&#10;    private val authRepository: AuthRepository&#10;) {&#10;    companion object {&#10;        // PERBAIKAN: Turunkan threshold berdasarkan hasil testing (0.197)&#10;        private const val SIMILARITY_THRESHOLD = 0.15f // Turun dari 0.4f ke 0.15f&#10;        private const val TAG = &quot;VerifyFaceUseCase&quot;&#10;    }&#10;&#10;    /**&#10;     * Verifies captured face against stored user embedding&#10;     * @param capturedFaceBitmap Bitmap of the captured face (sudah di-preprocess oleh FaceDetectorHelper)&#10;     * @return Result&lt;Boolean&gt; indicating if face matches (true) or not (false)&#10;     */&#10;    suspend operator fun invoke(capturedFaceBitmap: Bitmap): Result&lt;Boolean&gt; {&#10;        return try {&#10;            // Get current user data with stored face embedding&#10;            val currentUser = authRepository.getLoggedInUser().first()&#10;                ?: return Result.failure(Exception(&quot;No logged in user found&quot;))&#10;&#10;            val storedEmbedding = currentUser.faceEmbedding&#10;                ?: return Result.failure(Exception(&quot;No stored face embedding found. Please update your profile.&quot;))&#10;&#10;            // Generate embedding from captured bitmap (sudah standardized ke 112x112)&#10;            val embeddingResult = generateEmbeddingFromBitmap(capturedFaceBitmap)&#10;&#10;            if (embeddingResult.isFailure) {&#10;                return Result.failure(&#10;                    embeddingResult.exceptionOrNull()&#10;                        ?: Exception(&quot;Failed to generate embedding from captured face&quot;)&#10;                )&#10;            }&#10;&#10;            val capturedEmbedding = embeddingResult.getOrNull()!!&#10;&#10;            // Compare embeddings using cosine similarity&#10;            val similarity = calculateCosineSimilarity(storedEmbedding, capturedEmbedding)&#10;&#10;            // Log similarity score untuk debugging&#10;            android.util.Log.d(TAG, &quot;Face similarity score: $similarity (threshold: $SIMILARITY_THRESHOLD)&quot;)&#10;&#10;            // Return true if similarity exceeds threshold&#10;            val isMatch = similarity &gt;= SIMILARITY_THRESHOLD&#10;&#10;            android.util.Log.d(TAG, &quot;Face verification result: $isMatch&quot;)&#10;&#10;            Result.success(isMatch)&#10;&#10;        } catch (e: Exception) {&#10;            android.util.Log.e(TAG, &quot;Error in face verification&quot;, e)&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Generate embedding from bitmap using FaceProcessor&#10;     * Enhanced to work directly with Bitmap without URL&#10;     */&#10;    private suspend fun generateEmbeddingFromBitmap(bitmap: Bitmap): Result&lt;ByteArray&gt; {&#10;        return try {&#10;            // Use the new direct bitmap processing method from FaceProcessor&#10;            faceProcessor.generateEmbeddingFromBitmap(bitmap)&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Create temporary file from bitmap for processing&#10;     * This method is now deprecated in favor of direct bitmap processing&#10;     */&#10;    @Deprecated(&quot;Use generateEmbeddingFromBitmap directly&quot;)&#10;    private fun createTempImageFile(bitmap: Bitmap): java.io.File? {&#10;        return try {&#10;            val tempFile = java.io.File.createTempFile(&quot;face_capture&quot;, &quot;.jpg&quot;)&#10;            val outputStream = java.io.FileOutputStream(tempFile)&#10;            bitmap.compress(Bitmap.CompressFormat.JPEG, 90, outputStream)&#10;            outputStream.flush()&#10;            outputStream.close()&#10;            tempFile&#10;        } catch (e: Exception) {&#10;            null&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Calculate cosine similarity between two embeddings&#10;     * @param embedding1 First embedding (stored)&#10;     * @param embedding2 Second embedding (captured)&#10;     * @return Similarity score between 0.0 and 1.0&#10;     */&#10;    private fun calculateCosineSimilarity(embedding1: ByteArray, embedding2: ByteArray): Float {&#10;        if (embedding1.size != embedding2.size) {&#10;            return 0f&#10;        }&#10;&#10;        // Convert ByteArray to FloatArray for calculation&#10;        val floats1 = byteArrayToFloatArray(embedding1)&#10;        val floats2 = byteArrayToFloatArray(embedding2)&#10;&#10;        var dotProduct = 0.0&#10;        var normA = 0.0&#10;        var normB = 0.0&#10;&#10;        for (i in floats1.indices) {&#10;            dotProduct += floats1[i] * floats2[i]&#10;            normA += floats1[i] * floats1[i]&#10;            normB += floats2[i] * floats2[i]&#10;        }&#10;&#10;        return if (normA == 0.0 || normB == 0.0) {&#10;            0f&#10;        } else {&#10;            (dotProduct / (kotlin.math.sqrt(normA) * kotlin.math.sqrt(normB))).toFloat()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Convert ByteArray to FloatArray for similarity calculation&#10;     */&#10;    private fun byteArrayToFloatArray(byteArray: ByteArray): FloatArray {&#10;        val floatArray = FloatArray(byteArray.size / 4)&#10;        val buffer = java.nio.ByteBuffer.wrap(byteArray)&#10;        buffer.order(java.nio.ByteOrder.LITTLE_ENDIAN)&#10;&#10;        for (i in floatArray.indices) {&#10;            floatArray[i] = buffer.getFloat(i * 4)&#10;        }&#10;&#10;        return floatArray&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/presentation/geofencing/GeofenceManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/presentation/geofencing/GeofenceManager.kt" />
              <option name="originalContent" value="package com.example.infinite_track.presentation.geofencing&#10;&#10;import android.annotation.SuppressLint&#10;import android.app.PendingIntent&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.util.Log&#10;import com.google.android.gms.location.Geofence&#10;import com.google.android.gms.location.GeofencingRequest&#10;import com.google.android.gms.location.LocationServices&#10;import dagger.hilt.android.qualifiers.ApplicationContext&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class GeofenceManager @Inject constructor(@ApplicationContext private val context: Context) {&#10;&#10;    private val geofencingClient = LocationServices.getGeofencingClient(context)&#10;    private val TAG = &quot;GeofenceManager&quot;&#10;&#10;    private val geofencePendingIntent: PendingIntent by lazy {&#10;        val intent = Intent(context, GeofenceBroadcastReceiver::class.java)&#10;        PendingIntent.getBroadcast(&#10;            context,&#10;            0,&#10;            intent,&#10;            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_MUTABLE&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Remove all geofences registered by this application&#10;     * This ensures we never hit the system limit of ~100 geofences&#10;     */&#10;    fun removeAllGeofences() {&#10;        geofencingClient.removeGeofences(geofencePendingIntent).run {&#10;            addOnSuccessListener {&#10;                Log.d(TAG, &quot;Semua geofence berhasil dihapus&quot;)&#10;            }&#10;            addOnFailureListener { exception -&gt;&#10;                Log.e(TAG, &quot;Gagal menghapus semua geofence&quot;, exception)&#10;            }&#10;        }&#10;    }&#10;&#10;    @SuppressLint(&quot;MissingPermission&quot;)&#10;    fun addGeofence(id: String, latitude: Double, longitude: Double, radius: Float) {&#10;        // STEP 1: Always remove all existing geofences first (clean slate approach)&#10;        Log.d(TAG, &quot;Membersihkan semua geofence sebelum menambah yang baru...&quot;)&#10;        removeAllGeofences()&#10;        removeAllGeofences()&#10;        // STEP 2: Create and add the new geofence&#10;        val geofence = Geofence.Builder()&#10;            .setRequestId(id)&#10;            .setCircularRegion(latitude, longitude, radius)&#10;            .setExpirationDuration(Geofence.NEVER_EXPIRE)&#10;            .setTransitionTypes(Geofence.GEOFENCE_TRANSITION_ENTER or Geofence.GEOFENCE_TRANSITION_EXIT)&#10;            .build()&#10;                    &quot;Geofence berhasil ditambahkan: $id (lat: $latitude, lng: $longitude, radius: ${radius}m)&quot;&#10;        val geofencingRequest = GeofencingRequest.Builder()&#10;            .setInitialTrigger(GeofencingRequest.INITIAL_TRIGGER_ENTER)&#10;            .addGeofence(geofence)&#10;            .build()&#10;                    &quot;Geofence berhasil ditambahkan: $id (lat: $latitude, lng: $longitude, radius: ${radius}m)&quot;&#10;        geofencingClient.addGeofences(geofencingRequest, geofencePendingIntent).run {&#10;            addOnSuccessListener {&#10;                Log.d(&#10;                    TAG,&#10;                    &quot;Geofence berhasil ditambahkan: $id (lat: $latitude, lng: $longitude, radius: ${radius}m)&quot;&#10;                )&#10;" />
              <option name="updatedContent" value="package com.example.infinite_track.presentation.geofencing&#10;&#10;import android.annotation.SuppressLint&#10;import android.app.PendingIntent&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.util.Log&#10;import com.google.android.gms.location.Geofence&#10;import com.google.android.gms.location.GeofencingRequest&#10;import com.google.android.gms.location.LocationServices&#10;import dagger.hilt.android.qualifiers.ApplicationContext&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class GeofenceManager @Inject constructor(@ApplicationContext private val context: Context) {&#10;&#10;    private val geofencingClient = LocationServices.getGeofencingClient(context)&#10;    private val TAG = &quot;GeofenceManager&quot;&#10;&#10;    private val geofencePendingIntent: PendingIntent by lazy {&#10;        val intent = Intent(context, GeofenceBroadcastReceiver::class.java)&#10;        PendingIntent.getBroadcast(&#10;            context,&#10;            0,&#10;            intent,&#10;            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_MUTABLE&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Remove all geofences registered by this application&#10;     * This ensures we never hit the system limit of ~100 geofences&#10;     */&#10;    fun removeAllGeofences() {&#10;        geofencingClient.removeGeofences(geofencePendingIntent).run {&#10;            addOnSuccessListener {&#10;                Log.d(TAG, &quot;Semua geofence berhasil dihapus&quot;)&#10;            }&#10;            addOnFailureListener { exception -&gt;&#10;                Log.e(TAG, &quot;Gagal menghapus semua geofence&quot;, exception)&#10;            }&#10;        }&#10;    }&#10;&#10;    @SuppressLint(&quot;MissingPermission&quot;)&#10;    fun addGeofence(id: String, latitude: Double, longitude: Double, radius: Float) {&#10;        // STEP 1: Always remove all existing geofences first (clean slate approach)&#10;        Log.d(TAG, &quot;Membersihkan semua geofence sebelum menambah yang baru...&quot;)&#10;        &#10;        geofencingClient.removeGeofences(geofencePendingIntent).run {&#10;            addOnSuccessListener {&#10;                Log.d(TAG, &quot;Semua geofence berhasil dihapus, sekarang menambah geofence baru...&quot;)&#10;                &#10;                // STEP 2: Create and add the new geofence ONLY after removal is successful&#10;                val geofence = Geofence.Builder()&#10;                    .setRequestId(id)&#10;                    .setCircularRegion(latitude, longitude, radius)&#10;                    .setExpirationDuration(Geofence.NEVER_EXPIRE)&#10;                    .setTransitionTypes(Geofence.GEOFENCE_TRANSITION_ENTER or Geofence.GEOFENCE_TRANSITION_EXIT)&#10;                    .build()&#10;&#10;                val geofencingRequest = GeofencingRequest.Builder()&#10;                    .setInitialTrigger(GeofencingRequest.INITIAL_TRIGGER_ENTER)&#10;                    .addGeofence(geofence)&#10;                    .build()&#10;&#10;                geofencingClient.addGeofences(geofencingRequest, geofencePendingIntent).run {&#10;                    addOnSuccessListener {&#10;                        Log.d(&#10;                            TAG,&#10;                            &quot;Geofence berhasil ditambahkan: $id (lat: $latitude, lng: $longitude, radius: ${radius}m)&quot;&#10;                        )&#10;                    }&#10;                    addOnFailureListener { exception -&gt;&#10;                        Log.e(TAG, &quot;Gagal menambahkan geofence: $id&quot;, exception)&#10;                    }&#10;                }&#10;            }&#10;            addOnFailureListener { exception -&gt;&#10;                Log.e(TAG, &quot;Gagal menghapus semua geofence, geofence baru tidak akan ditambahkan&quot;, exception)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun removeGeofence(id: String) {&#10;        geofencingClient.removeGeofences(listOf(id)).run {&#10;            addOnSuccessListener { Log.d(TAG, &quot;Geofence berhasil dihapus: $id&quot;) }&#10;            addOnFailureListener { Log.e(TAG, &quot;Gagal menghapus geofence: $id&quot;, it) }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/presentation/main/InfiniteTrackApp.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/presentation/main/InfiniteTrackApp.kt" />
              <option name="originalContent" value="package com.example.infinite_track.presentation.main&#10;&#10;import androidx.compose.animation.core.Animatable&#10;import androidx.compose.animation.core.LinearEasing&#10;import androidx.compose.animation.core.RepeatMode&#10;import androidx.compose.animation.core.animateFloat&#10;import androidx.compose.animation.core.infiniteRepeatable&#10;import androidx.compose.animation.core.keyframes&#10;import androidx.compose.animation.core.rememberInfiniteTransition&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.material3.Surface&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;        appNavigator?.navigationEvents?.collectLatest { event -&gt;&#10;    LaunchedEffect(Unit) {&#10;            ) {&#10;" />
              <option name="updatedContent" value="package com.example.infinite_track.presentation.main&#10;&#10;import androidx.compose.animation.core.Animatable&#10;import androidx.compose.animation.core.LinearEasing&#10;import androidx.compose.animation.core.RepeatMode&#10;import androidx.compose.animation.core.animateFloat&#10;import androidx.compose.animation.core.infiniteRepeatable&#10;import androidx.compose.animation.core.keyframes&#10;import androidx.compose.animation.core.rememberInfiniteTransition&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.material3.Surface&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.zIndex&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import androidx.navigation.compose.NavHost&#10;import androidx.navigation.compose.rememberNavController&#10;import com.example.infinite_track.domain.manager.SessionManager&#10;import com.example.infinite_track.presentation.components.base.BaseLayout&#10;import com.example.infinite_track.presentation.navigation.AppNavigator&#10;import com.example.infinite_track.presentation.navigation.NavigationEvent&#10;import com.example.infinite_track.presentation.navigation.Screen&#10;import com.example.infinite_track.presentation.navigation.appNavGraph&#10;import com.example.infinite_track.utils.DialogHelper&#10;import kotlinx.coroutines.flow.collectLatest&#10;&#10;@Composable&#10;fun InfiniteTrackApp(&#10;    modifier: Modifier = Modifier,&#10;    appNavigator: AppNavigator? = null,&#10;    sessionManager: SessionManager? = null&#10;) {&#10;    // Root level NavController - handles top-level navigation&#10;    val navController = rememberNavController()&#10;    val context = LocalContext.current&#10;    &#10;    // Observe session expiration state&#10;    val sessionExpired by sessionManager?.sessionExpired?.collectAsState() ?: remember { androidx.compose.runtime.mutableStateOf(false) }&#10;&#10;    // Handle session expiration&#10;    LaunchedEffect(sessionExpired) {&#10;        if (sessionExpired) {&#10;            // Show session expired dialog&#10;            DialogHelper.showDialogError(&#10;                context = context,&#10;                title = &quot;Sesi Berakhir&quot;,&#10;                textContent = &quot;Sesi Anda telah berakhir. Silakan login kembali untuk melanjutkan.&quot;,&#10;                onConfirm = {&#10;                    // Reset session expired state&#10;                    sessionManager?.resetSessionExpired()&#10;                    &#10;                    // Navigate to login and clear back stack&#10;                    navController.navigate(Screen.Login.route) {&#10;                        popUpTo(0) { inclusive = true }&#10;                        launchSingleTop = true&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    }&#10;&#10;    // Handle navigation events from AppNavigator&#10;    LaunchedEffect(appNavigator) {&#10;        appNavigator?.navigationEvents?.collectLatest { event -&gt;&#10;            when (event) {&#10;                is NavigationEvent.NavigateToAttendance -&gt; {&#10;                    // Navigate to attendance screen&#10;                    navController.navigate(Screen.Attendance.route) {&#10;                        // Optional: Clear back stack if needed&#10;                        launchSingleTop = true&#10;                    }&#10;                }&#10;&#10;                is NavigationEvent.NavigateToScreen -&gt; {&#10;                    navController.navigate(event.route) {&#10;                        launchSingleTop = true&#10;                    }&#10;                }&#10;&#10;                is NavigationEvent.NavigateToLoginAfterSessionExpired -&gt; {&#10;                    // This event is now handled by SessionManager state above&#10;                    // Keeping for backward compatibility if needed elsewhere&#10;                    navController.navigate(Screen.Login.route) {&#10;                        popUpTo(0) { inclusive = true }&#10;                        launchSingleTop = true&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // State animation defined at the app level - this will persist across screen navigations&#10;    val infiniteTransition = rememberInfiniteTransition(label = &quot;infinite_rotation&quot;)&#10;    val rotationAnimation by infiniteTransition.animateFloat(&#10;        initialValue = 0f,&#10;        targetValue = 360f,&#10;        animationSpec = infiniteRepeatable(&#10;            animation = tween(durationMillis = 30000, easing = LinearEasing),&#10;            repeatMode = RepeatMode.Restart&#10;        ),&#10;        label = &quot;rotation&quot;&#10;    )&#10;&#10;    val sizeTransition = remember { Animatable(0f) }&#10;    LaunchedEffect(Unit) {&#10;        sizeTransition.animateTo(&#10;            targetValue = 1f,&#10;            animationSpec = infiniteRepeatable(&#10;                animation = keyframes {&#10;                    durationMillis = 10000&#10;                    0f at 0&#10;                    1f at 5000&#10;                    0f at 10000&#10;                },&#10;                repeatMode = RepeatMode.Restart&#10;            )&#10;        )&#10;    }&#10;&#10;    // Main box that contains both the BaseLayout and the rest of the UI&#10;    Box(modifier = modifier.fillMaxSize()) {&#10;        // BaseLayout displayed at the back layer&#10;        BaseLayout(&#10;            rotation = rotationAnimation,&#10;            size = sizeTransition.value,&#10;            modifier = Modifier.zIndex(-2f)&#10;        )&#10;&#10;        // Semi-transparent white layer over BaseLayout&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .zIndex(-1f)&#10;                .background(Color.White.copy(alpha = 0.5f))&#10;        )&#10;&#10;        // Clean, minimal root container&#10;        Surface(&#10;            modifier = Modifier.fillMaxSize(),&#10;            color = Color.Transparent&#10;        ) {&#10;            // Root NavHost with only top-level navigation concerns&#10;            NavHost(&#10;                navController = navController,&#10;                startDestination = Screen.Splash.route&#10;            ) {&#10;                // Connect to the app navigation graph&#10;                appNavGraph(navController)&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/presentation/main/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/presentation/main/MainActivity.kt" />
              <option name="originalContent" value="package com.example.infinite_track.presentation.main&#10;&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.util.Log&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.activity.viewModels&#10;import androidx.core.splashscreen.SplashScreen.Companion.installSplashScreen&#10;    // Get SplashViewModel instance&#10;    private val viewModel: SplashViewModel by viewModels()&#10;&#10;    // Inject AppNavigator untuk navigasi dari Activity&#10;    @Inject&#10;    lateinit var appNavigator: AppNavigator&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        splashScreen.setKeepOnScreenCondition {&#10;        enableEdgeToEdge()&#10;        }&#10;        // Handle intent saat aplikasi sudah berjalan di background dan notifikasi diklik&#10;            appNavigator.navigateToAttendance()&#10;" />
              <option name="updatedContent" value="package com.example.infinite_track.presentation.main&#10;&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.util.Log&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.activity.viewModels&#10;import androidx.core.splashscreen.SplashScreen.Companion.installSplashScreen&#10;import com.example.infinite_track.domain.manager.SessionManager&#10;import com.example.infinite_track.presentation.navigation.AppNavigator&#10;import com.example.infinite_track.presentation.screen.splash.SplashNavigationState&#10;import com.example.infinite_track.presentation.screen.splash.SplashViewModel&#10;import com.example.infinite_track.presentation.theme.Infinite_TrackTheme&#10;import dagger.hilt.android.AndroidEntryPoint&#10;import javax.inject.Inject&#10;&#10;@AndroidEntryPoint&#10;class MainActivity : ComponentActivity() {&#10;    // Get SplashViewModel instance&#10;    private val viewModel: SplashViewModel by viewModels()&#10;&#10;    // Inject AppNavigator untuk navigasi dari Activity&#10;    @Inject&#10;    lateinit var appNavigator: AppNavigator&#10;&#10;    // Inject SessionManager untuk menangani session expiration&#10;    @Inject&#10;    lateinit var sessionManager: SessionManager&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        // Install splash screen BEFORE super.onCreate()&#10;        val splashScreen = installSplashScreen()&#10;&#10;        // Set keep on screen condition - keep splash screen visible while in Loading state&#10;        splashScreen.setKeepOnScreenCondition {&#10;            viewModel.navigationState.value is SplashNavigationState.Loading&#10;        }&#10;&#10;        super.onCreate(savedInstanceState)&#10;        enableEdgeToEdge()&#10;        setContent {&#10;            Infinite_TrackTheme {&#10;                InfiniteTrackApp(&#10;                    appNavigator = appNavigator,&#10;                    sessionManager = sessionManager&#10;                )&#10;            }&#10;        }&#10;&#10;        // Handle intent saat aplikasi pertama kali dibuka dari notifikasi&#10;        handleIntent(intent)&#10;    }&#10;&#10;    override fun onNewIntent(intent: Intent) {&#10;        super.onNewIntent(intent)&#10;        // Handle intent saat aplikasi sudah berjalan di background dan notifikasi diklik&#10;        handleIntent(intent)&#10;    }&#10;&#10;    private fun handleIntent(intent: Intent?) {&#10;        // Periksa apakah intent memiliki extra yang kita kirim dari NotificationHelper&#10;        if (intent?.getBooleanExtra(&quot;navigate_to_attendance&quot;, false) == true) {&#10;            // Gunakan AppNavigator untuk navigasi ke AttendanceScreen&#10;            appNavigator.navigateToAttendance()&#10;            Log.d(&quot;MainActivity&quot;, &quot;Navigating to AttendanceScreen via AppNavigator&quot;)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/presentation/navigation/AppNavigator.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/presentation/navigation/AppNavigator.kt" />
              <option name="originalContent" value="package com.example.infinite_track.presentation.navigation&#10;&#10;import kotlinx.coroutines.flow.MutableSharedFlow&#10;import kotlinx.coroutines.flow.asSharedFlow&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;/**&#10; * Singleton navigator untuk menangani navigasi dari luar Composable context&#10; * Useful untuk navigasi dari Activity, BroadcastReceiver, atau Service&#10; */&#10;@Singleton&#10;class AppNavigator @Inject constructor() {&#10;&#10;    private val _navigationEvents = MutableSharedFlow&lt;NavigationEvent&gt;()&#10;    val navigationEvents = _navigationEvents.asSharedFlow()&#10;&#10;    /**&#10;     * Navigasi ke AttendanceScreen dari mana saja&#10;     */&#10;    fun navigateToAttendance() {&#10;        _navigationEvents.tryEmit(NavigationEvent.NavigateToAttendance)&#10;    }&#10;&#10;    /**&#10;     * Navigasi ke screen lain jika diperlukan&#10;     */&#10;    fun navigateToScreen(route: String) {&#10;        _navigationEvents.tryEmit(NavigationEvent.NavigateToScreen(route))&#10;    }&#10;" />
              <option name="updatedContent" value="package com.example.infinite_track.presentation.navigation&#10;&#10;import kotlinx.coroutines.flow.MutableSharedFlow&#10;import kotlinx.coroutines.flow.asSharedFlow&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;/**&#10; * Singleton navigator untuk menangani navigasi dari luar Composable context&#10; * Useful untuk navigasi dari Activity, BroadcastReceiver, atau Service&#10; */&#10;@Singleton&#10;class AppNavigator @Inject constructor() {&#10;&#10;    private val _navigationEvents = MutableSharedFlow&lt;NavigationEvent&gt;()&#10;    val navigationEvents = _navigationEvents.asSharedFlow()&#10;&#10;    /**&#10;     * Navigasi ke AttendanceScreen dari mana saja&#10;     */&#10;    fun navigateToAttendance() {&#10;        _navigationEvents.tryEmit(NavigationEvent.NavigateToAttendance)&#10;    }&#10;&#10;    /**&#10;     * Navigasi ke screen lain jika diperlukan&#10;     */&#10;    fun navigateToScreen(route: String) {&#10;        _navigationEvents.tryEmit(NavigationEvent.NavigateToScreen(route))&#10;    }&#10;&#10;    /**&#10;     * Navigasi ke login setelah sesi berakhir (401 error)&#10;     */&#10;    fun navigateToLoginAfterSessionExpired() {&#10;        _navigationEvents.tryEmit(NavigationEvent.NavigateToLoginAfterSessionExpired)&#10;    }&#10;}&#10;&#10;/**&#10; * Event untuk navigasi&#10; */&#10;sealed class NavigationEvent {&#10;    object NavigateToAttendance : NavigationEvent()&#10;    data class NavigateToScreen(val route: String) : NavigationEvent()&#10;    object NavigateToLoginAfterSessionExpired : NavigationEvent()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/presentation/screen/attendance/AttendanceScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/presentation/screen/attendance/AttendanceScreen.kt" />
              <option name="originalContent" value="package com.example.infinite_track.presentation.screen.attendance&#10;&#10;import androidx.compose.animation.AnimatedVisibility&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.statusBarsPadding&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.LocationOn&#10;import androidx.compose.material3.BottomSheetScaffold&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.rememberBottomSheetScaffoldState&#10;import androidx.compose.material3.rememberStandardBottomSheetState&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.blur&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import androidx.navigation.NavController&#10;import com.example.infinite_track.domain.model.attendance.TargetLocationInfo&#10;import com.example.infinite_track.domain.model.location.LocationResult&#10;import com.example.infinite_track.domain.model.wfa.WfaRecommendation&#10;import com.example.infinite_track.presentation.components.button.attendance.AttendanceBottomSheetContent&#10;import com.example.infinite_track.presentation.components.empty.ErrorAnimation&#10;import com.example.infinite_track.presentation.components.loading.LoadingAnimation&#10;import com.example.infinite_track.presentation.components.maps.AttendanceMap&#10;import com.example.infinite_track.presentation.components.maps.MarkerView&#10;import com.example.infinite_track.presentation.components.maps.MarkerViewWfa&#10;import com.example.infinite_track.presentation.navigation.Screen&#10;import com.example.infinite_track.presentation.screen.attendance.components.AttendanceTopBar&#10;import com.example.infinite_track.presentation.theme.Infinite_TrackTheme&#10;import com.example.infinite_track.utils.UiState&#10;import com.mapbox.geojson.Point&#10;import com.mapbox.maps.CameraOptions&#10;import com.mapbox.maps.MapView&#10;import com.mapbox.maps.MapboxDelicateApi&#10;import com.mapbox.maps.plugin.animation.MapAnimationOptions&#10;import com.mapbox.maps.plugin.animation.flyTo&#10;&#10;@OptIn(ExperimentalMaterial3Api::class, MapboxDelicateApi::class)&#10;@Composable&#10;fun AttendanceScreen(&#10;    navController: NavController,&#10;    viewModel: AttendanceViewModel = hiltViewModel()&#10;) {&#10;    var mapViewInstance by remember { mutableStateOf&lt;MapView?&gt;(null) }&#10;&#10;    // Observasi state dari ViewModel yang sudah disederhanakan&#10;    val uiState by viewModel.uiState.collectAsStateWithLifecycle()&#10;&#10;    // Handle hasil pencarian lokasi dari LocationSearchScreen&#10;    val selectedLocation = navController.currentBackStackEntry&#10;        ?.savedStateHandle&#10;        ?.get&lt;LocationResult&gt;(&quot;selected_location&quot;)&#10;&#10;    // Process hasil pencarian lokasi&#10;    LaunchedEffect(selectedLocation) {&#10;        selectedLocation?.let { location -&gt;&#10;            // Kirim lokasi terpilih ke ViewModel untuk diproses&#10;            viewModel.onLocationSelected(location)&#10;            // Hapus state agar tidak diproses lagi saat re-komposisi&#10;            navController.currentBackStackEntry&#10;                ?.savedStateHandle&#10;                ?.remove&lt;LocationResult&gt;(&quot;selected_location&quot;)&#10;        }&#10;    }&#10;&#10;    // BottomSheet state&#10;    val bottomSheetState = rememberStandardBottomSheetState(&#10;        skipHiddenState = false&#10;    )&#10;    val scaffoldState = rememberBottomSheetScaffoldState(&#10;        bottomSheetState = bottomSheetState&#10;    )&#10;&#10;    // Handle map events from ViewModel with enhanced camera control&#10;    LaunchedEffect(Unit) {&#10;        viewModel.mapEvent.collect { event -&gt;&#10;            when (event) {&#10;                is AttendanceViewModel.MapEvent.AnimateToLocation -&gt; {&#10;                    mapViewInstance?.let { mapView -&gt;&#10;                        // Use the enhanced event data with Point and zoomLevel&#10;                        val cameraOptions = CameraOptions.Builder()&#10;                            .center(event.point)&#10;                            .zoom(event.zoomLevel)&#10;                            .pitch(0.0)&#10;                            .bearing(0.0)&#10;                            .build()&#10;&#10;                        mapView.mapboxMap.flyTo(&#10;                            cameraOptions,&#10;                            MapAnimationOptions.Builder()&#10;                                .duration(1200L)&#10;                                .build()&#10;                        )&#10;&#10;                        android.util.Log.d(&#10;                            &quot;AttendanceScreen&quot;,&#10;                            &quot;Camera animated to ${event.point.latitude()}, ${event.point.longitude()} with zoom ${event.zoomLevel}&quot;&#10;                        )&#10;                    }&#10;                }&#10;&#10;                is AttendanceViewModel.MapEvent.AnimateToFitBounds -&gt; {&#10;                    mapViewInstance?.let { mapView -&gt;&#10;                        // Use Mapbox's cameraForCoordinates to fit all WFA recommendations&#10;                        if (event.points.isNotEmpty()) {&#10;                            val cameraOptions = mapView.mapboxMap.cameraForCoordinates(&#10;                                coordinates = event.points,&#10;                                camera = CameraOptions.Builder().build(),&#10;                                coordinatesPadding = com.mapbox.maps.EdgeInsets(&#10;                                    50.0,&#10;                                    50.0,&#10;                                    50.0,&#10;                                    50.0&#10;                                ),&#10;                                maxZoom = null,&#10;                                offset = null&#10;                            )&#10;&#10;                            mapView.mapboxMap.flyTo(&#10;                                cameraOptions,&#10;                                MapAnimationOptions.Builder()&#10;                                    .duration(1500L)&#10;                                    .build()&#10;                            )&#10;&#10;                            android.util.Log.d(&#10;                                &quot;AttendanceScreen&quot;,&#10;                                &quot;Camera animated to fit ${event.points.size} WFA locations&quot;&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;&#10;                is AttendanceViewModel.MapEvent.ShowLocationError -&gt; {&#10;                    // Handle error - could add snackbar or toast&#10;                    android.util.Log.e(&#10;                        &quot;AttendanceScreen&quot;,&#10;                        &quot;Failed to get current location for focus&quot;&#10;                    )&#10;                }&#10;&#10;                is AttendanceViewModel.MapEvent.NavigateToWfaBooking -&gt; {&#10;                    // Navigate to WFA booking screen&#10;                    navController.navigate(event.route)&#10;                    android.util.Log.d(&#10;                        &quot;AttendanceScreen&quot;,&#10;                        &quot;Navigating to WFA booking screen with route: ${event.route}&quot;&#10;                    )&#10;                }&#10;&#10;                is AttendanceViewModel.MapEvent.NavigateToFaceScanner -&gt; {&#10;                    // Navigate to face scanner screen for attendance verification&#10;                    val action = if (event.isCheckIn) &quot;checkin&quot; else &quot;checkout&quot;&#10;                    val route = Screen.FaceScanner.createRoute(action)&#10;                    navController.navigate(route)&#10;                    android.util.Log.d(&#10;                        &quot;AttendanceScreen&quot;,&#10;                        &quot;Navigating to face scanner for $action&quot;&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Start location updates when UI is ready and data is loaded successfully&#10;    LaunchedEffect(uiState.uiState) {&#10;        if (uiState.uiState is UiState.Success) {&#10;            // Only start location updates after data is loaded and UI is ready&#10;            viewModel.startLocationUpdates()&#10;            android.util.Log.d(&quot;AttendanceScreen&quot;, &quot;Location updates started after UI ready&quot;)&#10;        }&#10;    }&#10;&#10;    // Penanganan state utama berdasarkan UiState dengan smart cast fix&#10;    when (val currentUiState = uiState.uiState) {&#10;        is UiState.Idle -&gt; {&#10;            // Initial idle state - could show a splash or continue to loading&#10;            Box(&#10;                modifier = Modifier.fillMaxSize(),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                LoadingAnimation()&#10;            }&#10;        }&#10;&#10;        is UiState.Loading -&gt; {&#10;            // Tampilkan loading animation&#10;            Box(&#10;                modifier = Modifier.fillMaxSize(),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                LoadingAnimation()&#10;            }&#10;        }&#10;&#10;        is UiState.Error -&gt; {&#10;            Box(&#10;                modifier = Modifier.fillMaxSize(),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Column(&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    ErrorAnimation()&#10;                    Text(&#10;                        text = currentUiState.errorMessage,&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        color = MaterialTheme.colorScheme.error,&#10;                        textAlign = TextAlign.Center,&#10;                        modifier = Modifier.padding(16.dp)&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        is UiState.Success -&gt; {&#10;            // Tampilkan konten utama dengan BottomSheet&#10;            BottomSheetScaffold(&#10;                scaffoldState = scaffoldState,&#10;                containerColor = Color.Black.copy(alpha = 0.1f),&#10;                contentColor = Color.Transparent,&#10;                sheetContainerColor = Color.Transparent,&#10;                sheetContentColor = Color.Unspecified,&#10;                sheetShape = RoundedCornerShape(topStart = 24.dp, topEnd = 24.dp),&#10;                sheetPeekHeight = 120.dp,&#10;                sheetDragHandle = null,&#10;                sheetContent = {&#10;                    // Enhanced Liquid Glass Background Container&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .clip(RoundedCornerShape(topStart = 24.dp, topEnd = 24.dp))&#10;                            .background(&#10;                                brush = Brush.linearGradient(&#10;                                    colors = listOf(&#10;                                        Color.White.copy(alpha = 0.98f),&#10;                                        Color.White.copy(alpha = 0.95f),&#10;                                        Color(0xFFE3F2FD).copy(alpha = 0.92f),&#10;                                        Color(0xFFBBDEFB).copy(alpha = 0.88f)&#10;                                    )&#10;                                )&#10;                            )&#10;                    ) {&#10;                        // Glass effect overlays&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .matchParentSize()&#10;                                .background(&#10;                                    brush = Brush.radialGradient(&#10;                                        colors = listOf(&#10;                                            Color.White.copy(alpha = 0.6f),&#10;                                            Color.Transparent,&#10;                                            Color(0xFF81D4FA).copy(alpha = 0.3f)&#10;                                        ),&#10;                                        radius = 1000f&#10;                                    )&#10;                                )&#10;                                .blur(2.dp)&#10;                        )&#10;&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .matchParentSize()&#10;                                .background(&#10;                                    brush = Brush.linearGradient(&#10;                                        colors = listOf(&#10;                                            Color.Transparent,&#10;                                            Color.White.copy(alpha = 0.4f),&#10;                                            Color.Transparent&#10;                                        )&#10;                                    )&#10;                                )&#10;                        )&#10;&#10;                        // Content with drag handle&#10;                        Column(modifier = Modifier.fillMaxWidth()) {&#10;                            // Custom drag handle&#10;                            Box(&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .padding(top = 12.dp, bottom = 8.dp),&#10;                                contentAlignment = Alignment.Center&#10;                            ) {&#10;                                Box(&#10;                                    modifier = Modifier&#10;                                        .width(40.dp)&#10;                                        .height(4.dp)&#10;                                        .clip(RoundedCornerShape(2.dp))&#10;                                        .background(Color.Gray.copy(alpha = 0.3f))&#10;                                )&#10;                            }&#10;&#10;                            AttendanceBottomSheetContent(&#10;                                modifier = Modifier.padding(top = 0.dp),&#10;                                targetLocationInfo = uiState.targetLocation?.let { target -&gt;&#10;                                    TargetLocationInfo(&#10;                                        description = target.description,&#10;                                        locationName = target.category&#10;                                    )&#10;                                },&#10;                                currentLocationAddress = uiState.currentUserAddress.ifEmpty { &quot;Mengambil lokasi saat ini...&quot; },&#10;                                selectedWorkMode = uiState.selectedWorkMode,&#10;                                isBookingEnabled = uiState.isBookingEnabled,&#10;                                isCheckInEnabled = uiState.isButtonEnabled, // Use isButtonEnabled from uiState&#10;                                checkInButtonText = uiState.buttonText,&#10;                                onSearchLocationClick = {&#10;                                    navController.navigate(&quot;location_search&quot;)&#10;                                },&#10;                                onModeSelected = { mode -&gt; viewModel.onWorkModeSelected(mode) },&#10;                                onBookingClick = { viewModel.onBookingClicked() },&#10;                                onCheckInClick = { viewModel.onAttendanceButtonClicked() }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            ) { _ -&gt; // Renamed paddingValues to _ to indicate it's intentionally unused&#10;                Box(modifier = Modifier.fillMaxSize()) {&#10;                    // Fullscreen Map dengan data dari ViewModel - Updated with WFO, WFH, and WFA locations&#10;                    AttendanceMap(&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        wfoLocation = if (uiState.isWfaModeActive) null else uiState.wfoLocation, // Hide WFO when WFA active&#10;                        wfhLocation = if (uiState.isWfaModeActive) null else uiState.wfhLocation, // Hide WFH when WFA active&#10;                        wfaRecommendations = uiState.wfaRecommendations, // WFA recommendations&#10;                        selectedWfaLocation = uiState.selectedWfaLocation, // Selected WFA location&#10;                        targetLocation = uiState.targetLocationMarker, // Keep for backward compatibility&#10;                        currentUserLocation = uiState.currentUserLatitude?.let { lat -&gt;&#10;                            uiState.currentUserLongitude?.let { lng -&gt;&#10;                                Point.fromLngLat(lng, lat)&#10;                            }&#10;                        },&#10;                        onMarkerClick = { location -&gt; viewModel.onMarkerClicked(location) },&#10;                        onWfaMarkerClick = { recommendation: WfaRecommendation -&gt;&#10;                            viewModel.onWfaMarkerClicked(&#10;                                recommendation&#10;                            )&#10;                        }, // Handle WFA marker clicks&#10;                        onMapReady = { mapView -&gt;&#10;                            mapViewInstance = mapView&#10;                            // Notify ViewModel that map is ready for initial focus&#10;                            viewModel.onMapReady()&#10;                        },&#10;                        onCameraIdle = { point -&gt;&#10;                            viewModel.onMapIdle(point)&#10;                        } // Handle Pick on Map functionality&#10;                    )&#10;&#10;                    // Top bar with location focus button - fixed parameters&#10;                    AttendanceTopBar(&#10;                        modifier = Modifier&#10;                            .statusBarsPadding()&#10;                            .padding(16.dp),&#10;                        onBackClicked = { navController.navigateUp() },&#10;                        onFocusLocationClicked = { viewModel.onFocusLocationClicked() }&#10;                    )&#10;&#10;                    // Pick on Map Crosshair - shows static pin in center when Pick on Map mode is active&#10;                    AnimatedVisibility(&#10;                        visible = uiState.isPickOnMapModeActive,&#10;                        modifier = Modifier.align(Alignment.Center)&#10;                    ) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.LocationOn,&#10;                            contentDescription = &quot;Pick Location&quot;,&#10;                            tint = Color.Red,&#10;                            modifier = Modifier.size(32.dp)&#10;                        )&#10;                    }&#10;&#10;                    uiState.selectedMarkerInfo?.let { selectedMarker -&gt;&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .fillMaxSize()&#10;                                .padding(top = 80.dp),&#10;                            contentAlignment = Alignment.TopCenter&#10;                        ) {&#10;                            MarkerView(&#10;                                title = selectedMarker.description,&#10;                                description = &quot;Kategori: ${selectedMarker.category}&quot;,&#10;                                radius = &quot;${selectedMarker.radius} meter&quot;,&#10;                                coordinates = &quot;${selectedMarker.latitude}, ${selectedMarker.longitude}&quot;,&#10;                                onClose = { viewModel.onDismissMarkerInfo() }&#10;                            )&#10;                        }&#10;                    }&#10;&#10;                    // Display WFA marker details when clicked&#10;                    uiState.selectedWfaMarkerInfo?.let { selectedWfaMarker -&gt;&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .fillMaxSize()&#10;                                .padding(top = 80.dp, start = 16.dp, end = 16.dp),&#10;                            contentAlignment = Alignment.TopCenter&#10;                        ) {&#10;                            MarkerViewWfa(&#10;                                recommendation = selectedWfaMarker,&#10;                                onClick = { viewModel.onDismissWfaMarkerInfo() }&#10;                            )&#10;                        }&#10;                    }&#10;&#10;                    // Loading overlay for WFA recommendations&#10;                    if (uiState.isLoadingWfaRecommendations) {&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .fillMaxSize()&#10;                                .background(Color.Black.copy(alpha = 0.3f)),&#10;                            contentAlignment = Alignment.Center&#10;                        ) {&#10;                            LoadingAnimation()&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Handle face verification result from FaceScannerScreen&#10;    LaunchedEffect(Unit) {&#10;        // Get face verification result from savedStateHandle&#10;        val faceVerificationResult = navController.currentBackStackEntry&#10;            ?.savedStateHandle&#10;            ?.getLiveData&lt;Boolean&gt;(&quot;face_verification_result&quot;)&#10;&#10;        faceVerificationResult?.observeForever { isSuccess -&gt;&#10;            if (isSuccess != null) {&#10;                // Call ViewModel to handle the result&#10;                viewModel.onFaceVerificationResult(isSuccess)&#10;    // Handle error dialog display&#10;    LaunchedEffect(uiState.error) {&#10;        uiState.error?.let { errorMessage -&gt;&#10;            // Here you would typically show a dialog using DialogHelper&#10;            // For now, we'll log the error and clear it&#10;            android.util.Log.e(&quot;AttendanceScreen&quot;, &quot;Error occurred: $errorMessage&quot;)&#10;&#10;            // TODO: Replace with actual DialogHelper implementation&#10;            // DialogHelper.showErrorDialog(context, errorMessage) {&#10;            //     viewModel.clearError()&#10;            // }&#10;&#10;            // For now, clear error after logging&#10;            viewModel.clearError()&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun AttendanceScreenPreview() {&#10;    Infinite_TrackTheme {&#10;        Box(modifier = Modifier.fillMaxSize()) {&#10;            AttendanceMap(&#10;                modifier = Modifier.fillMaxSize(),&#10;                onMapReady = { }&#10;            )&#10;            AttendanceTopBar(&#10;                modifier = Modifier&#10;                    .align(Alignment.TopCenter)&#10;                    .statusBarsPadding()&#10;                    .padding(horizontal = 20.dp),&#10;                onBackClicked = { },&#10;                onFocusLocationClicked = { }&#10;            )&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.infinite_track.presentation.screen.attendance&#10;&#10;import androidx.compose.animation.AnimatedVisibility&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.statusBarsPadding&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.LocationOn&#10;import androidx.compose.material3.BottomSheetScaffold&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.rememberBottomSheetScaffoldState&#10;import androidx.compose.material3.rememberStandardBottomSheetState&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.blur&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import androidx.navigation.NavController&#10;import com.example.infinite_track.domain.model.attendance.TargetLocationInfo&#10;import com.example.infinite_track.domain.model.location.LocationResult&#10;import com.example.infinite_track.domain.model.wfa.WfaRecommendation&#10;import com.example.infinite_track.presentation.components.button.attendance.AttendanceBottomSheetContent&#10;import com.example.infinite_track.presentation.components.empty.ErrorAnimation&#10;import com.example.infinite_track.presentation.components.loading.LoadingAnimation&#10;import com.example.infinite_track.presentation.components.maps.AttendanceMap&#10;import com.example.infinite_track.presentation.components.maps.MarkerView&#10;import com.example.infinite_track.presentation.components.maps.MarkerViewWfa&#10;import com.example.infinite_track.presentation.navigation.Screen&#10;import com.example.infinite_track.presentation.screen.attendance.components.AttendanceTopBar&#10;import com.example.infinite_track.presentation.theme.Infinite_TrackTheme&#10;import com.example.infinite_track.utils.UiState&#10;import com.mapbox.geojson.Point&#10;import com.mapbox.maps.CameraOptions&#10;import com.mapbox.maps.MapView&#10;import com.mapbox.maps.MapboxDelicateApi&#10;import com.mapbox.maps.plugin.animation.MapAnimationOptions&#10;import com.mapbox.maps.plugin.animation.flyTo&#10;&#10;@OptIn(ExperimentalMaterial3Api::class, MapboxDelicateApi::class)&#10;@Composable&#10;fun AttendanceScreen(&#10;    navController: NavController,&#10;    viewModel: AttendanceViewModel = hiltViewModel()&#10;) {&#10;    var mapViewInstance by remember { mutableStateOf&lt;MapView?&gt;(null) }&#10;&#10;    // Observasi state dari ViewModel yang sudah disederhanakan&#10;    val uiState by viewModel.uiState.collectAsStateWithLifecycle()&#10;&#10;    // Handle hasil pencarian lokasi dari LocationSearchScreen&#10;    val selectedLocation = navController.currentBackStackEntry&#10;        ?.savedStateHandle&#10;        ?.get&lt;LocationResult&gt;(&quot;selected_location&quot;)&#10;&#10;    // Process hasil pencarian lokasi&#10;    LaunchedEffect(selectedLocation) {&#10;        selectedLocation?.let { location -&gt;&#10;            // Kirim lokasi terpilih ke ViewModel untuk diproses&#10;            viewModel.onLocationSelected(location)&#10;            // Hapus state agar tidak diproses lagi saat re-komposisi&#10;            navController.currentBackStackEntry&#10;                ?.savedStateHandle&#10;                ?.remove&lt;LocationResult&gt;(&quot;selected_location&quot;)&#10;        }&#10;    }&#10;&#10;    // BottomSheet state&#10;    val bottomSheetState = rememberStandardBottomSheetState(&#10;        skipHiddenState = false&#10;    )&#10;    val scaffoldState = rememberBottomSheetScaffoldState(&#10;        bottomSheetState = bottomSheetState&#10;    )&#10;&#10;    // Handle map events from ViewModel with enhanced camera control&#10;    LaunchedEffect(Unit) {&#10;        viewModel.mapEvent.collect { event -&gt;&#10;            when (event) {&#10;                is AttendanceViewModel.MapEvent.AnimateToLocation -&gt; {&#10;                    mapViewInstance?.let { mapView -&gt;&#10;                        // Use the enhanced event data with Point and zoomLevel&#10;                        val cameraOptions = CameraOptions.Builder()&#10;                            .center(event.point)&#10;                            .zoom(event.zoomLevel)&#10;                            .pitch(0.0)&#10;                            .bearing(0.0)&#10;                            .build()&#10;&#10;                        mapView.mapboxMap.flyTo(&#10;                            cameraOptions,&#10;                            MapAnimationOptions.Builder()&#10;                                .duration(1200L)&#10;                                .build()&#10;                        )&#10;&#10;                        android.util.Log.d(&#10;                            &quot;AttendanceScreen&quot;,&#10;                            &quot;Camera animated to ${event.point.latitude()}, ${event.point.longitude()} with zoom ${event.zoomLevel}&quot;&#10;                        )&#10;                    }&#10;                }&#10;&#10;                is AttendanceViewModel.MapEvent.AnimateToFitBounds -&gt; {&#10;                    mapViewInstance?.let { mapView -&gt;&#10;                        // Use Mapbox's cameraForCoordinates to fit all WFA recommendations&#10;                        if (event.points.isNotEmpty()) {&#10;                            val cameraOptions = mapView.mapboxMap.cameraForCoordinates(&#10;                                coordinates = event.points,&#10;                                camera = CameraOptions.Builder().build(),&#10;                                coordinatesPadding = com.mapbox.maps.EdgeInsets(&#10;                                    50.0,&#10;                                    50.0,&#10;                                    50.0,&#10;                                    50.0&#10;                                ),&#10;                                maxZoom = null,&#10;                                offset = null&#10;                            )&#10;&#10;                            mapView.mapboxMap.flyTo(&#10;                                cameraOptions,&#10;                                MapAnimationOptions.Builder()&#10;                                    .duration(1500L)&#10;                                    .build()&#10;                            )&#10;&#10;                            android.util.Log.d(&#10;                                &quot;AttendanceScreen&quot;,&#10;                                &quot;Camera animated to fit ${event.points.size} WFA locations&quot;&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;&#10;                is AttendanceViewModel.MapEvent.ShowLocationError -&gt; {&#10;                    // Handle error - could add snackbar or toast&#10;                    android.util.Log.e(&#10;                        &quot;AttendanceScreen&quot;,&#10;                        &quot;Failed to get current location for focus&quot;&#10;                    )&#10;                }&#10;&#10;                is AttendanceViewModel.MapEvent.NavigateToWfaBooking -&gt; {&#10;                    // Navigate to WFA booking screen&#10;                    navController.navigate(event.route)&#10;                    android.util.Log.d(&#10;                        &quot;AttendanceScreen&quot;,&#10;                        &quot;Navigating to WFA booking screen with route: ${event.route}&quot;&#10;                    )&#10;                }&#10;&#10;                is AttendanceViewModel.MapEvent.NavigateToFaceScanner -&gt; {&#10;                    // Navigate to face scanner screen for attendance verification&#10;                    val action = if (event.isCheckIn) &quot;checkin&quot; else &quot;checkout&quot;&#10;                    val route = Screen.FaceScanner.createRoute(action)&#10;                    navController.navigate(route)&#10;                    android.util.Log.d(&#10;                        &quot;AttendanceScreen&quot;,&#10;                        &quot;Navigating to face scanner for $action&quot;&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Start location updates when UI is ready and data is loaded successfully&#10;    LaunchedEffect(uiState.uiState) {&#10;        if (uiState.uiState is UiState.Success) {&#10;            // Only start location updates after data is loaded and UI is ready&#10;            viewModel.startLocationUpdates()&#10;            android.util.Log.d(&quot;AttendanceScreen&quot;, &quot;Location updates started after UI ready&quot;)&#10;        }&#10;    }&#10;&#10;    // Penanganan state utama berdasarkan UiState dengan smart cast fix&#10;    when (val currentUiState = uiState.uiState) {&#10;        is UiState.Idle -&gt; {&#10;            // Initial idle state - could show a splash or continue to loading&#10;            Box(&#10;                modifier = Modifier.fillMaxSize(),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                LoadingAnimation()&#10;            }&#10;        }&#10;&#10;        is UiState.Loading -&gt; {&#10;            // Tampilkan loading animation&#10;            Box(&#10;                modifier = Modifier.fillMaxSize(),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                LoadingAnimation()&#10;            }&#10;        }&#10;&#10;        is UiState.Error -&gt; {&#10;            Box(&#10;                modifier = Modifier.fillMaxSize(),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Column(&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    ErrorAnimation()&#10;                    Text(&#10;                        text = currentUiState.errorMessage,&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        color = MaterialTheme.colorScheme.error,&#10;                        textAlign = TextAlign.Center,&#10;                        modifier = Modifier.padding(16.dp)&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        is UiState.Success -&gt; {&#10;            // Tampilkan konten utama dengan BottomSheet&#10;            BottomSheetScaffold(&#10;                scaffoldState = scaffoldState,&#10;                containerColor = Color.Black.copy(alpha = 0.1f),&#10;                contentColor = Color.Transparent,&#10;                sheetContainerColor = Color.Transparent,&#10;                sheetContentColor = Color.Unspecified,&#10;                sheetShape = RoundedCornerShape(topStart = 24.dp, topEnd = 24.dp),&#10;                sheetPeekHeight = 120.dp,&#10;                sheetDragHandle = null,&#10;                sheetContent = {&#10;                    // Enhanced Liquid Glass Background Container&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .clip(RoundedCornerShape(topStart = 24.dp, topEnd = 24.dp))&#10;                            .background(&#10;                                brush = Brush.linearGradient(&#10;                                    colors = listOf(&#10;                                        Color.White.copy(alpha = 0.98f),&#10;                                        Color.White.copy(alpha = 0.95f),&#10;                                        Color(0xFFE3F2FD).copy(alpha = 0.92f),&#10;                                        Color(0xFFBBDEFB).copy(alpha = 0.88f)&#10;                                    )&#10;                                )&#10;                            )&#10;                    ) {&#10;                        // Glass effect overlays&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .matchParentSize()&#10;                                .background(&#10;                                    brush = Brush.radialGradient(&#10;                                        colors = listOf(&#10;                                            Color.White.copy(alpha = 0.6f),&#10;                                            Color.Transparent,&#10;                                            Color(0xFF81D4FA).copy(alpha = 0.3f)&#10;                                        ),&#10;                                        radius = 1000f&#10;                                    )&#10;                                )&#10;                                .blur(2.dp)&#10;                        )&#10;&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .matchParentSize()&#10;                                .background(&#10;                                    brush = Brush.linearGradient(&#10;                                        colors = listOf(&#10;                                            Color.Transparent,&#10;                                            Color.White.copy(alpha = 0.4f),&#10;                                            Color.Transparent&#10;                                        )&#10;                                    )&#10;                                )&#10;                        )&#10;&#10;                        // Content with drag handle&#10;                        Column(modifier = Modifier.fillMaxWidth()) {&#10;                            // Custom drag handle&#10;                            Box(&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .padding(top = 12.dp, bottom = 8.dp),&#10;                                contentAlignment = Alignment.Center&#10;                            ) {&#10;                                Box(&#10;                                    modifier = Modifier&#10;                                        .width(40.dp)&#10;                                        .height(4.dp)&#10;                                        .clip(RoundedCornerShape(2.dp))&#10;                                        .background(Color.Gray.copy(alpha = 0.3f))&#10;                                )&#10;                            }&#10;&#10;                            AttendanceBottomSheetContent(&#10;                                modifier = Modifier.padding(top = 0.dp),&#10;                                targetLocationInfo = uiState.targetLocation?.let { target -&gt;&#10;                                    TargetLocationInfo(&#10;                                        description = target.description,&#10;                                        locationName = target.category&#10;                                    )&#10;                                },&#10;                                currentLocationAddress = uiState.currentUserAddress.ifEmpty { &quot;Mengambil lokasi saat ini...&quot; },&#10;                                selectedWorkMode = uiState.selectedWorkMode,&#10;                                isBookingEnabled = uiState.isBookingEnabled,&#10;                                isCheckInEnabled = uiState.isButtonEnabled, // Use isButtonEnabled from uiState&#10;                                checkInButtonText = uiState.buttonText,&#10;                                onSearchLocationClick = {&#10;                                    navController.navigate(&quot;location_search&quot;)&#10;                                },&#10;                                onModeSelected = { mode -&gt; viewModel.onWorkModeSelected(mode) },&#10;                                onBookingClick = { viewModel.onBookingClicked() },&#10;                                onCheckInClick = { viewModel.onAttendanceButtonClicked() }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            ) { _ -&gt; // Renamed paddingValues to _ to indicate it's intentionally unused&#10;                Box(modifier = Modifier.fillMaxSize()) {&#10;                    // Fullscreen Map dengan data dari ViewModel - Updated with WFO, WFH, and WFA locations&#10;                    AttendanceMap(&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        wfoLocation = if (uiState.isWfaModeActive) null else uiState.wfoLocation, // Hide WFO when WFA active&#10;                        wfhLocation = if (uiState.isWfaModeActive) null else uiState.wfhLocation, // Hide WFH when WFA active&#10;                        wfaRecommendations = uiState.wfaRecommendations, // WFA recommendations&#10;                        selectedWfaLocation = uiState.selectedWfaLocation, // Selected WFA location&#10;                        targetLocation = uiState.targetLocationMarker, // Keep for backward compatibility&#10;                        currentUserLocation = uiState.currentUserLatitude?.let { lat -&gt;&#10;                            uiState.currentUserLongitude?.let { lng -&gt;&#10;                                Point.fromLngLat(lng, lat)&#10;                            }&#10;                        },&#10;                        onMarkerClick = { location -&gt; viewModel.onMarkerClicked(location) },&#10;                        onWfaMarkerClick = { recommendation: WfaRecommendation -&gt;&#10;                            viewModel.onWfaMarkerClicked(&#10;                                recommendation&#10;                            )&#10;                        }, // Handle WFA marker clicks&#10;                        onMapReady = { mapView -&gt;&#10;                            mapViewInstance = mapView&#10;                            // Notify ViewModel that map is ready for initial focus&#10;                            viewModel.onMapReady()&#10;                        },&#10;                        onCameraIdle = { point -&gt;&#10;                            viewModel.onMapIdle(point)&#10;                        } // Handle Pick on Map functionality&#10;                    )&#10;&#10;                    // Top bar with location focus button - fixed parameters&#10;                    AttendanceTopBar(&#10;                        modifier = Modifier&#10;                            .statusBarsPadding()&#10;                            .padding(16.dp),&#10;                        onBackClicked = { navController.navigateUp() },&#10;                        onFocusLocationClicked = { viewModel.onFocusLocationClicked() }&#10;                    )&#10;&#10;                    // Pick on Map Crosshair - shows static pin in center when Pick on Map mode is active&#10;                    AnimatedVisibility(&#10;                        visible = uiState.isPickOnMapModeActive,&#10;                        modifier = Modifier.align(Alignment.Center)&#10;                    ) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.LocationOn,&#10;                            contentDescription = &quot;Pick Location&quot;,&#10;                            tint = Color.Red,&#10;                            modifier = Modifier.size(32.dp)&#10;                        )&#10;                    }&#10;&#10;                    uiState.selectedMarkerInfo?.let { selectedMarker -&gt;&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .fillMaxSize()&#10;                                .padding(top = 80.dp),&#10;                            contentAlignment = Alignment.TopCenter&#10;                        ) {&#10;                            MarkerView(&#10;                                title = selectedMarker.description,&#10;                                description = &quot;Kategori: ${selectedMarker.category}&quot;,&#10;                                radius = &quot;${selectedMarker.radius} meter&quot;,&#10;                                coordinates = &quot;${selectedMarker.latitude}, ${selectedMarker.longitude}&quot;,&#10;                                onClose = { viewModel.onDismissMarkerInfo() }&#10;                            )&#10;                        }&#10;                    }&#10;&#10;                    // Display WFA marker details when clicked&#10;                    uiState.selectedWfaMarkerInfo?.let { selectedWfaMarker -&gt;&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .fillMaxSize()&#10;                                .padding(top = 80.dp, start = 16.dp, end = 16.dp),&#10;                            contentAlignment = Alignment.TopCenter&#10;                        ) {&#10;                            MarkerViewWfa(&#10;                                recommendation = selectedWfaMarker,&#10;                                onClick = { viewModel.onDismissWfaMarkerInfo() }&#10;                            )&#10;                        }&#10;                    }&#10;&#10;                    // Loading overlay for WFA recommendations&#10;                    if (uiState.isLoadingWfaRecommendations) {&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .fillMaxSize()&#10;                                .background(Color.Black.copy(alpha = 0.3f)),&#10;                            contentAlignment = Alignment.Center&#10;                        ) {&#10;                            LoadingAnimation()&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Handle face verification result from FaceScannerScreen&#10;    LaunchedEffect(Unit) {&#10;        // Get face verification result from savedStateHandle&#10;        val faceVerificationResult = navController.currentBackStackEntry&#10;            ?.savedStateHandle&#10;            ?.getLiveData&lt;Boolean&gt;(&quot;face_verification_result&quot;)&#10;&#10;        faceVerificationResult?.observeForever { isSuccess -&gt;&#10;            if (isSuccess != null) {&#10;                // FIXED: Only process if verification was successful&#10;                // If failed, user should stay on FaceScannerScreen for retry&#10;                if (isSuccess) {&#10;                    // Call ViewModel to handle the successful result&#10;                    viewModel.onFaceVerificationResult(isSuccess)&#10;                } else {&#10;                    // Face verification failed - don't process, let user retry on FaceScannerScreen&#10;                    android.util.Log.d(&quot;AttendanceScreen&quot;, &quot;Face verification failed - user should retry on scanner screen&quot;)&#10;                }&#10;                &#10;                // Clear the result to prevent re-processing&#10;                navController.currentBackStackEntry&#10;                    ?.savedStateHandle&#10;                    ?.remove&lt;Boolean&gt;(&quot;face_verification_result&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    // Handle error dialog display&#10;    LaunchedEffect(uiState.error) {&#10;        uiState.error?.let { errorMessage -&gt;&#10;            // Here you would typically show a dialog using DialogHelper&#10;            // For now, we'll log the error and clear it&#10;            android.util.Log.e(&quot;AttendanceScreen&quot;, &quot;Error occurred: $errorMessage&quot;)&#10;&#10;            // TODO: Replace with actual DialogHelper implementation&#10;            // DialogHelper.showErrorDialog(context, errorMessage) {&#10;            //     viewModel.clearError()&#10;            // }&#10;&#10;            // For now, clear error after logging&#10;            viewModel.clearError()&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun AttendanceScreenPreview() {&#10;    Infinite_TrackTheme {&#10;        Box(modifier = Modifier.fillMaxSize()) {&#10;            AttendanceMap(&#10;                modifier = Modifier.fillMaxSize(),&#10;                onMapReady = { }&#10;            )&#10;            AttendanceTopBar(&#10;                modifier = Modifier&#10;                    .align(Alignment.TopCenter)&#10;                    .statusBarsPadding()&#10;                    .padding(horizontal = 20.dp),&#10;                onBackClicked = { },&#10;                onFocusLocationClicked = { }&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/presentation/screen/attendance/face/FaceScannerScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/presentation/screen/attendance/face/FaceScannerScreen.kt" />
              <option name="originalContent" value="package com.example.infinite_track.presentation.screen.attendance.face&#10;&#10;import android.graphics.Bitmap&#10;import androidx.camera.core.CameraSelector&#10;import androidx.camera.core.ImageProxy&#10;import androidx.camera.lifecycle.ProcessCameraProvider&#10;import androidx.camera.view.PreviewView&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Close&#10;import androidx.compose.material.icons.filled.SentimentSatisfied&#10;import androidx.compose.material.icons.filled.Visibility&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.CircularProgressIndicator&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.LinearProgressIndicator&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.OutlinedButton&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.DisposableEffect&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.onSizeChanged&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.viewinterop.AndroidView&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import androidx.navigation.NavController&#10;import com.example.infinite_track.presentation.components.button.ButtonStateType&#10;import com.example.infinite_track.presentation.components.button.ButtonStyle&#10;import com.example.infinite_track.presentation.components.button.StatefulButton&#10;import com.example.infinite_track.presentation.components.cameras.FaceBoundingBox&#10;import com.example.infinite_track.presentation.components.loading.LoadingAnimation&#10;import com.example.infinite_track.presentation.theme.Blue_500&#10;import com.google.accompanist.permissions.ExperimentalPermissionsApi&#10;import com.google.accompanist.permissions.isGranted&#10;import com.google.accompanist.permissions.rememberPermissionState&#10;import com.google.accompanist.permissions.shouldShowRationale&#10;import java.util.concurrent.ExecutorService&#10;import java.util.concurrent.Executors&#10;import androidx.camera.core.Preview as CameraPreview&#10;&#10;@OptIn(ExperimentalMaterial3Api::class, ExperimentalPermissionsApi::class)&#10;@Composable&#10;fun FaceScannerScreen(&#10;    action: String,&#10;    navController: NavController,&#10;    modifier: Modifier = Modifier,&#10;    viewModel: FaceScannerViewModel = hiltViewModel()&#10;) {&#10;    val uiState by viewModel.uiState.collectAsStateWithLifecycle()&#10;&#10;    // Camera permission state&#10;    val cameraPermissionState = rememberPermissionState(&#10;        android.Manifest.permission.CAMERA&#10;    )&#10;&#10;    // Camera executor&#10;    val cameraExecutor = remember { Executors.newSingleThreadExecutor() }&#10;&#10;    // Request camera permission when screen opens&#10;    LaunchedEffect(Unit) {&#10;        if (!cameraPermissionState.status.isGranted) {&#10;            cameraPermissionState.launchPermissionRequest()&#10;        }&#10;    }&#10;&#10;    // Handle navigation based on verification result&#10;    LaunchedEffect(uiState.livenessState) {&#10;        when (uiState.livenessState) {&#10;            LivenessState.SUCCESS -&gt; {&#10;                // Set result and navigate back&#10;                navController.previousBackStackEntry?.savedStateHandle?.set(&#10;                    &quot;face_verification_result&quot;,&#10;                    true&#10;                )&#10;                navController.popBackStack()&#10;            }&#10;&#10;                CameraContent(&#10;                // FIXED: Only send result for TIMEOUT, not FAILURE&#10;                // TIMEOUT means user ran out of time and should go back&#10;                    action = action,&#10;                    uiState = uiState,&#10;                    cameraExecutor = cameraExecutor,&#10;                    onImageAnalysis = { imageProxy, bitmap -&gt;&#10;                        viewModel.processImageProxy(imageProxy, bitmap)&#10;                    },&#10;                    onRetryClick = {&#10;            // REMOVED: LivenessState.FAILURE from automatic navigation&#10;            // FAILURE should stay on screen to allow retry&#10;                )&#10;            }&#10;&#10;            cameraPermissionState.status.shouldShowRationale -&gt; {&#10;                // Show rationale for camera permission&#10;                CameraPermissionRationale(&#10;                    onRequestPermission = {&#10;                        cameraPermissionState.launchPermissionRequest()&#10;                    },&#10;                    onCloseClick = {&#10;                        navController.popBackStack()&#10;                    }&#10;                )&#10;            }&#10;&#10;            else -&gt; {&#10;                // Permission denied - show permission request UI&#10;                CameraPermissionDenied(&#10;                    onRequestPermission = {&#10;                        cameraPermissionState.launchPermissionRequest()&#10;                    },&#10;                    onCloseClick = {&#10;                        navController.popBackStack()&#10;                    }&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun CameraContent(&#10;    modifier: Modifier = Modifier,&#10;    action: String,&#10;    uiState: FaceScannerState,&#10;    cameraExecutor: ExecutorService,&#10;    onImageAnalysis: (ImageProxy, Bitmap) -&gt; Unit,&#10;    onRetryClick: () -&gt; Unit,&#10;    onCloseClick: () -&gt; Unit&#10;) {&#10;    val density = LocalDensity.current&#10;    var previewSize by remember { mutableStateOf&lt;androidx.compose.ui.geometry.Size?&gt;(null) }&#10;&#10;    // Get screen dimensions for proper scaling&#10;    val configuration = androidx.compose.ui.platform.LocalConfiguration.current&#10;    val screenWidth = configuration.screenWidthDp.dp&#10;    val screenHeight = configuration.screenHeightDp.dp&#10;&#10;    Box(&#10;        modifier = modifier&#10;            .fillMaxSize()&#10;            .onSizeChanged { size -&gt;&#10;                // Capture actual preview size for coordinate scaling&#10;                previewSize = androidx.compose.ui.geometry.Size(&#10;                    width = size.width.toFloat(),&#10;                    height = size.height.toFloat()&#10;                )&#10;                println(&quot;Preview size captured: ${size.width}x${size.height}&quot;)&#10;            }&#10;    ) {&#10;        // Layer 1: Camera Preview with proper CameraX integration&#10;        CameraPreview(&#10;            modifier = Modifier.fillMaxSize(),&#10;            cameraExecutor = cameraExecutor,&#10;            onImageAnalysis = { imageProxy, bitmap -&gt;&#10;                onImageAnalysis(imageProxy, bitmap)&#10;            }&#10;        )&#10;&#10;        // Layer 2: Face Bounding Box Overlay with proper coordinate scaling&#10;        FaceBoundingBox(&#10;            modifier = Modifier.fillMaxSize(),&#10;            boundingBox = uiState.boundingBox,&#10;            livenessState = uiState.livenessState,&#10;            previewSize = previewSize, // Pass actual preview size&#10;            imageSize = uiState.imageSize // Pass image size from ViewModel&#10;        )&#10;&#10;        // Layer 3: Top Info Section - More compact&#10;        TopInfoSection(&#10;            modifier = Modifier&#10;                .align(Alignment.TopCenter)&#10;                .padding(top = 16.dp, start = 16.dp, end = 16.dp),&#10;            action = action&#10;        )&#10;&#10;        // Layer 4: Instruction Section with dynamic content&#10;        InstructionSection(&#10;            modifier = Modifier&#10;                .align(Alignment.BottomCenter)&#10;                .padding(bottom = 16.dp, start = 16.dp, end = 16.dp),&#10;            uiState = uiState,&#10;            onRetryClick = onRetryClick,&#10;            onCloseClick = onCloseClick&#10;        )&#10;&#10;        // Layer 5: Loading Overlay for processing state&#10;        if (uiState.isProcessing) {&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .background(Color.Black.copy(alpha = 0.3f)),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Card(&#10;                    modifier = Modifier.padding(32.dp),&#10;                    colors = CardDefaults.cardColors(&#10;                        containerColor = MaterialTheme.colorScheme.surface&#10;                    )&#10;                ) {&#10;                    Column(&#10;                        modifier = Modifier.padding(24.dp),&#10;                        horizontalAlignment = Alignment.CenterHorizontally,&#10;                        verticalArrangement = Arrangement.spacedBy(16.dp)&#10;                    ) {&#10;                        LoadingAnimation()&#10;                        Text(&#10;                            text = uiState.instructionText,&#10;                            style = MaterialTheme.typography.bodyMedium,&#10;                            textAlign = TextAlign.Center&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun CameraPreview(&#10;    modifier: Modifier = Modifier,&#10;    cameraExecutor: ExecutorService,&#10;    onImageAnalysis: (ImageProxy, Bitmap) -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val lifecycleOwner = androidx.lifecycle.compose.LocalLifecycleOwner.current&#10;    val previewView = remember {&#10;        PreviewView(context).apply {&#10;            scaleType = PreviewView.ScaleType.FILL_CENTER&#10;        }&#10;    }&#10;&#10;    // Use LaunchedEffect instead of AndroidView update to prevent rebinding&#10;    LaunchedEffect(Unit) {&#10;        val cameraProviderFuture = ProcessCameraProvider.getInstance(context)&#10;&#10;        try {&#10;            val cameraProvider = cameraProviderFuture.get()&#10;&#10;            // Unbind all use cases before rebinding&#10;            cameraProvider.unbindAll()&#10;&#10;            // Preview use case&#10;            val preview = CameraPreview.Builder()&#10;                .build()&#10;                .also {&#10;                    it.surfaceProvider = previewView.surfaceProvider&#10;                }&#10;&#10;            // Image analysis use case&#10;            val imageAnalysis = androidx.camera.core.ImageAnalysis.Builder()&#10;                .setBackpressureStrategy(androidx.camera.core.ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST)&#10;                .build()&#10;                .also { analysis -&gt;&#10;                    analysis.setAnalyzer(cameraExecutor) { imageProxy -&gt;&#10;                        try {&#10;                            val bitmap = imageProxyToBitmap(imageProxy)&#10;                            if (bitmap != null) {&#10;                                onImageAnalysis(imageProxy, bitmap)&#10;                            }&#10;                        } catch (e: Exception) {&#10;                            println(&quot;Error in image analysis: ${e.message}&quot;)&#10;                            imageProxy.close()&#10;                        }&#10;                    }&#10;                }&#10;&#10;            // Select front camera&#10;            val cameraSelector = CameraSelector.DEFAULT_FRONT_CAMERA&#10;&#10;            // Bind use cases to camera (only once)&#10;            cameraProvider.bindToLifecycle(&#10;                lifecycleOwner,&#10;                cameraSelector,&#10;                preview,&#10;                imageAnalysis&#10;            )&#10;&#10;            println(&quot;Camera bound successfully with preview and image analysis&quot;)&#10;&#10;        } catch (exc: Exception) {&#10;            println(&quot;Camera binding failed: ${exc.message}&quot;)&#10;            exc.printStackTrace()&#10;        }&#10;    }&#10;&#10;    // Simple AndroidView without update block&#10;    AndroidView(&#10;        factory = { previewView },&#10;        modifier = modifier&#10;    )&#10;}&#10;&#10;@Composable&#10;private fun TopInfoSection(&#10;    modifier: Modifier = Modifier,&#10;    action: String&#10;) {&#10;    Column(&#10;        modifier = modifier.fillMaxWidth(),&#10;        horizontalAlignment = Alignment.CenterHorizontally,&#10;        verticalArrangement = Arrangement.Center&#10;    ) {&#10;        Text(&#10;            text = &quot;Verifikasi Wajah&quot;,&#10;            style = MaterialTheme.typography.titleMedium,&#10;            color = Color.White,&#10;            fontWeight = FontWeight.Bold,&#10;            textAlign = TextAlign.Center,&#10;            modifier = Modifier.fillMaxWidth()&#10;        )&#10;        Spacer(modifier = Modifier.height(2.dp))&#10;        Text(&#10;            text = if (action == &quot;checkin&quot;) &quot;Check In&quot; else &quot;Check Out&quot;,&#10;            style = MaterialTheme.typography.bodyMedium,&#10;            color = Color.White.copy(alpha = 0.9f),&#10;            fontWeight = FontWeight.Medium,&#10;            textAlign = TextAlign.Center,&#10;            modifier = Modifier.fillMaxWidth()&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun InstructionSection(&#10;    modifier: Modifier = Modifier,&#10;    uiState: FaceScannerState,&#10;    onRetryClick: () -&gt; Unit,&#10;    onCloseClick: () -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = modifier.fillMaxWidth(),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.surface.copy(alpha = 0.50f)&#10;        ),&#10;        shape = RoundedCornerShape(16.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(12.dp),&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.spacedBy(8.dp)&#10;        ) {&#10;            // Status Icon&#10;            val icon = when (uiState.livenessState) {&#10;                LivenessState.WAITING_FOR_LIVENESS -&gt; {&#10;                    if (uiState.currentChallenge == LivenessChallenge.BLINK) {&#10;                        Icons.Default.Visibility&#10;                    } else {&#10;                        Icons.Default.SentimentSatisfied&#10;                    }&#10;                }&#10;&#10;                LivenessState.SUCCESS -&gt; Icons.Default.SentimentSatisfied&#10;                else -&gt; Icons.Default.Visibility&#10;            }&#10;&#10;            val iconColor = when (uiState.livenessState) {&#10;                LivenessState.SUCCESS -&gt; Color(0xFF00FFC2)&#10;                LivenessState.FAILURE, LivenessState.TIMEOUT -&gt; Color(0xFFFF3B30)&#10;                LivenessState.WAITING_FOR_LIVENESS -&gt; Color(0xFFFFD60A)&#10;                else -&gt; Color(0xFF00A3FF)&#10;            }&#10;&#10;            Icon(&#10;                imageVector = icon,&#10;                contentDescription = null,&#10;                modifier = Modifier.size(36.dp),&#10;                tint = iconColor&#10;            )&#10;&#10;            // Instruction Text&#10;            Text(&#10;                text = uiState.instructionText,&#10;                style = MaterialTheme.typography.bodyMedium,&#10;                textAlign = TextAlign.Center,&#10;                fontWeight = FontWeight.Medium&#10;            )&#10;&#10;            // Progress Indicator (for countdown)&#10;            if (uiState.showCountdown &amp;&amp; uiState.livenessState != LivenessState.SUCCESS) {&#10;                Row(&#10;                    verticalAlignment = Alignment.CenterVertically,&#10;                    horizontalArrangement = Arrangement.spacedBy(6.dp)&#10;                ) {&#10;                    LinearProgressIndicator(&#10;                        progress = uiState.progress,&#10;                        color = Blue_500,&#10;                        modifier = Modifier&#10;                            .weight(1f)&#10;                            .height(3.dp)&#10;                            .clip(RoundedCornerShape(2.dp))&#10;                    )&#10;                    Text(&#10;                        text = &quot;${uiState.timeRemaining}s&quot;,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f)&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Error Message&#10;            uiState.errorMessage?.let { errorMessage -&gt;&#10;                Text(&#10;                    text = errorMessage,&#10;                    style = MaterialTheme.typography.bodySmall,&#10;                    color = Color(0xFFFF3B30),&#10;                    textAlign = TextAlign.Center&#10;                )&#10;            }&#10;&#10;            // Action Buttons&#10;            Row(&#10;                horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;            ) {&#10;                // Close Button menggunakan StatefulButton dengan state Error&#10;                StatefulButton(&#10;                    text = &quot;Tutup&quot;,&#10;                    onClick = onCloseClick,&#10;                    modifier = Modifier.weight(1f),&#10;                    style = ButtonStyle.Outlined,&#10;                    stateType = ButtonStateType.Error,&#10;                    enabled = true&#10;                )&#10;&#10;                // Retry Button (show when failed or timeout) menggunakan StatefulButton&#10;                if (uiState.livenessState == LivenessState.FAILURE ||&#10;                    uiState.livenessState == LivenessState.TIMEOUT&#10;                ) {&#10;                    StatefulButton(&#10;                        onClick = onRetryClick,&#10;                        modifier = Modifier.weight(1f),&#10;                        style = ButtonStyle.Elevated,&#10;                        stateType = ButtonStateType.Info,&#10;                        enabled = true&#10;                    )&#10;                }&#10;            }&#10;        }&#10;}&#10;&#10;// Helper function to convert ImageProxy to Bitmap - FIXED VERSION&#10;private fun imageProxyToBitmap(imageProxy: ImageProxy): Bitmap? {&#10;    return try {&#10;        // DON'T close imageProxy here - let FaceDetectorHelper handle it&#10;        // Get the YUV_420_888 image from camera&#10;        val image = imageProxy.image&#10;            val planes = image.planes&#10;            val yBuffer = planes[0].buffer&#10;            val uBuffer = planes[1].buffer&#10;            val vBuffer = planes[2].buffer&#10;&#10;            val ySize = yBuffer.remaining()&#10;            val uSize = uBuffer.remaining()&#10;            val vSize = vBuffer.remaining()&#10;&#10;&#10;            // U and V are swapped&#10;            yBuffer.get(nv21, 0, ySize)&#10;            vBuffer.get(nv21, ySize, vSize)&#10;            uBuffer.get(nv21, ySize + vSize, uSize)&#10;&#10;            val yuvImage = android.graphics.YuvImage(&#10;                nv21,&#10;                android.graphics.ImageFormat.NV21,&#10;                image.width,&#10;                image.height,&#10;                null&#10;            )&#10;&#10;            val out = java.io.ByteArrayOutputStream()&#10;            yuvImage.compressToJpeg(&#10;                android.graphics.Rect(0, 0, image.width, image.height),&#10;                75,&#10;                out&#10;            )&#10;&#10;            val imageBytes = out.toByteArray()&#10;            val bitmap =&#10;                android.graphics.BitmapFactory.decodeByteArray(imageBytes, 0, imageBytes.size)&#10;&#10;            // Close the output stream&#10;            out.close()&#10;&#10;            println(&quot;Successfully converted ImageProxy to Bitmap: ${bitmap?.width}x${bitmap?.height}&quot;)&#10;            bitmap&#10;        } else {&#10;            println(&quot;ImageProxy.image is null&quot;)&#10;            null&#10;        }&#10;    } catch (e: Exception) {&#10;        println(&quot;Error converting ImageProxy to Bitmap: ${e.message}&quot;)&#10;        e.printStackTrace()&#10;        null&#10;    }&#10;    // DON'T close imageProxy here - FaceDetectorHelper will close it&#10;}&#10;&#10;// Permission UI Components&#10;@Composable&#10;private fun CameraPermissionRationale(&#10;    onRequestPermission: () -&gt; Unit,&#10;    onCloseClick: () -&gt; Unit&#10;) {&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(MaterialTheme.colorScheme.background),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(32.dp),&#10;            colors = CardDefaults.cardColors(&#10;                containerColor = MaterialTheme.colorScheme.surface&#10;            ),&#10;            shape = RoundedCornerShape(16.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(24.dp),&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#10;                verticalArrangement = Arrangement.spacedBy(16.dp)&#10;            ) {&#10;                Icon(&#10;                    imageVector = Icons.Default.Visibility,&#10;                    contentDescription = null,&#10;                    modifier = Modifier.size(64.dp),&#10;                    tint = MaterialTheme.colorScheme.primary&#10;                )&#10;&#10;                Text(&#10;                    text = &quot;Izin Kamera Diperlukan&quot;,&#10;                    style = MaterialTheme.typography.headlineSmall,&#10;                    fontWeight = FontWeight.Bold,&#10;                    textAlign = TextAlign.Center&#10;                )&#10;&#10;                Text(&#10;                    text = &quot;Aplikasi memerlukan akses kamera untuk melakukan verifikasi wajah. Fitur ini membantu memastikan keamanan absensi Anda.&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    textAlign = TextAlign.Center,&#10;                    color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.8f)&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                Row(&#10;                    horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;                    modifier = Modifier.fillMaxWidth()&#10;                ) {&#10;                    OutlinedButton(&#10;                        onClick = onCloseClick,&#10;                        modifier = Modifier.weight(1f)&#10;                    ) {&#10;                        Text(&quot;Batal&quot;)&#10;                    }&#10;&#10;                    Button(&#10;                        onClick = onRequestPermission,&#10;                        modifier = Modifier.weight(1f)&#10;                    ) {&#10;                        Text(&quot;Berikan Izin&quot;)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun CameraPermissionDenied(&#10;    onRequestPermission: () -&gt; Unit,&#10;    onCloseClick: () -&gt; Unit&#10;) {&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(MaterialTheme.colorScheme.background),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(32.dp),&#10;            colors = CardDefaults.cardColors(&#10;                containerColor = MaterialTheme.colorScheme.surface&#10;            ),&#10;            shape = RoundedCornerShape(16.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(24.dp),&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#10;                verticalArrangement = Arrangement.spacedBy(16.dp)&#10;            ) {&#10;                Icon(&#10;                    imageVector = Icons.Default.Close,&#10;                    contentDescription = null,&#10;                    modifier = Modifier.size(64.dp),&#10;                    tint = Color(0xFFFF3B30)&#10;                )&#10;&#10;                Text(&#10;                    text = &quot;Akses Kamera Dibutuhkan&quot;,&#10;                    style = MaterialTheme.typography.headlineSmall,&#10;                    fontWeight = FontWeight.Bold,&#10;                    textAlign = TextAlign.Center&#10;                )&#10;&#10;                Text(&#10;                    text = &quot;Tanpa akses kamera, fitur verifikasi wajah tidak dapat berfungsi. Silakan berikan izin kamera untuk melanjutkan proses absensi.&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    textAlign = TextAlign.Center,&#10;                    color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.8f)&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                Row(&#10;                    horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;                    modifier = Modifier.fillMaxWidth()&#10;                ) {&#10;                    OutlinedButton(&#10;                        onClick = onCloseClick,&#10;                        modifier = Modifier.weight(1f)&#10;                    ) {&#10;                        Text(&quot;Tutup&quot;)&#10;                    }&#10;&#10;                    Button(&#10;                        onClick = onRequestPermission,&#10;                        modifier = Modifier.weight(1f)&#10;                    ) {&#10;                        Text(&quot;Coba Lagi&quot;)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;// Preview Composables for different states&#10;@Preview(showBackground = true, name = &quot;Check In - Initial State&quot;)&#10;@Composable&#10;fun PreviewFaceScannerCheckIn() {&#10;    MaterialTheme {&#10;        FaceScannerScreenPreview(&#10;            action = &quot;checkin&quot;,&#10;            state = FaceScannerState(&#10;                livenessState = LivenessState.IDLE,&#10;                instructionText = &quot;Posisikan wajah Anda dalam frame&quot;,&#10;                isProcessing = false,&#10;                showCountdown = false&#10;            )&#10;        )&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true, name = &quot;Check Out - Waiting for Liveness&quot;)&#10;@Composable&#10;fun PreviewFaceScannerCheckOutWaiting() {&#10;    MaterialTheme {&#10;        FaceScannerScreenPreview(&#10;            action = &quot;checkout&quot;,&#10;            state = FaceScannerState(&#10;                livenessState = LivenessState.WAITING_FOR_LIVENESS,&#10;                currentChallenge = LivenessChallenge.BLINK,&#10;                instructionText = &quot;Silakan berkedip untuk verifikasi&quot;,&#10;                isProcessing = false,&#10;                showCountdown = true,&#10;                progress = 0.6f,&#10;                timeRemaining = 4&#10;            )&#10;        )&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true, name = &quot;Processing State&quot;)&#10;@Composable&#10;fun PreviewFaceScannerProcessing() {&#10;    MaterialTheme {&#10;        FaceScannerScreenPreview(&#10;            action = &quot;checkin&quot;,&#10;            state = FaceScannerState(&#10;                livenessState = LivenessState.VERIFYING_FACE,&#10;                instructionText = &quot;Memproses verifikasi wajah...&quot;,&#10;                isProcessing = true,&#10;                showCountdown = false&#10;            )&#10;        )&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true, name = &quot;Success State&quot;)&#10;@Composable&#10;fun PreviewFaceScannerSuccess() {&#10;    MaterialTheme {&#10;        FaceScannerScreenPreview(&#10;            action = &quot;checkin&quot;,&#10;            state = FaceScannerState(&#10;                livenessState = LivenessState.SUCCESS,&#10;                instructionText = &quot;Verifikasi berhasil!&quot;,&#10;                isProcessing = false,&#10;                showCountdown = false&#10;            )&#10;        )&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true, name = &quot;Failure State&quot;)&#10;@Composable&#10;fun PreviewFaceScannerFailure() {&#10;    MaterialTheme {&#10;        FaceScannerScreenPreview(&#10;            action = &quot;checkout&quot;,&#10;            state = FaceScannerState(&#10;                livenessState = LivenessState.FAILURE,&#10;                instructionText = &quot;Verifikasi gagal&quot;,&#10;                errorMessage = &quot;Wajah tidak terdeteksi dengan jelas. Silakan coba lagi.&quot;,&#10;                isProcessing = false,&#10;                showCountdown = false&#10;            )&#10;        )&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true, name = &quot;Timeout State&quot;)&#10;@Composable&#10;fun PreviewFaceScannerTimeout() {&#10;    MaterialTheme {&#10;        FaceScannerScreenPreview(&#10;            action = &quot;checkin&quot;,&#10;            state = FaceScannerState(&#10;                livenessState = LivenessState.TIMEOUT,&#10;                instructionText = &quot;Waktu habis&quot;,&#10;                errorMessage = &quot;Waktu verifikasi telah habis. Silakan coba lagi.&quot;,&#10;                isProcessing = false,&#10;                showCountdown = false&#10;            )&#10;        )&#10;    }&#10;}&#10;&#10;// Simplified preview composable without camera and ViewModel dependencies&#10;@Composable&#10;private fun FaceScannerScreenPreview(&#10;    action: String,&#10;    state: FaceScannerState&#10;) {&#10;    Box(modifier = Modifier.fillMaxSize()) {&#10;        // Mock camera background&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .background(Color.Black)&#10;        )&#10;&#10;        // Top Info Section&#10;        TopInfoSection(&#10;            modifier = Modifier&#10;                .align(Alignment.TopCenter)&#10;                .padding(top = 48.dp, start = 24.dp, end = 24.dp),&#10;            action = action&#10;        )&#10;&#10;        // Instruction Section&#10;        InstructionSection(&#10;            modifier = Modifier&#10;                .align(Alignment.BottomCenter)&#10;                .padding(bottom = 48.dp, start = 24.dp, end = 24.dp),&#10;            uiState = state,&#10;            onRetryClick = {},&#10;            onCloseClick = {}&#10;        )&#10;&#10;        // Loading Overlay for processing state&#10;        if (state.isProcessing) {&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .background(Color.Black.copy(alpha = 0.3f)),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Card(&#10;                    modifier = Modifier.padding(32.dp),&#10;                    colors = CardDefaults.cardColors(&#10;                        containerColor = MaterialTheme.colorScheme.surface&#10;                    )&#10;                ) {&#10;                    Column(&#10;                        modifier = Modifier.padding(24.dp),&#10;                        horizontalAlignment = Alignment.CenterHorizontally,&#10;                        verticalArrangement = Arrangement.spacedBy(16.dp)&#10;                    ) {&#10;                        CircularProgressIndicator()&#10;                        Text(&#10;                            text = state.instructionText,&#10;                            style = MaterialTheme.typography.bodyMedium,&#10;                            textAlign = TextAlign.Center&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.infinite_track.presentation.screen.attendance.face&#10;&#10;import android.graphics.Bitmap&#10;import androidx.camera.core.CameraSelector&#10;import androidx.camera.core.ImageProxy&#10;import androidx.camera.lifecycle.ProcessCameraProvider&#10;import androidx.camera.view.PreviewView&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Close&#10;import androidx.compose.material.icons.filled.SentimentSatisfied&#10;import androidx.compose.material.icons.filled.Visibility&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.CircularProgressIndicator&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.LinearProgressIndicator&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.OutlinedButton&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.DisposableEffect&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.onSizeChanged&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.viewinterop.AndroidView&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import androidx.navigation.NavController&#10;import com.example.infinite_track.presentation.components.button.ButtonStateType&#10;import com.example.infinite_track.presentation.components.button.ButtonStyle&#10;import com.example.infinite_track.presentation.components.button.StatefulButton&#10;import com.example.infinite_track.presentation.components.cameras.FaceBoundingBox&#10;import com.example.infinite_track.presentation.components.loading.LoadingAnimation&#10;import com.example.infinite_track.presentation.theme.Blue_500&#10;import com.google.accompanist.permissions.ExperimentalPermissionsApi&#10;import com.google.accompanist.permissions.isGranted&#10;import com.google.accompanist.permissions.rememberPermissionState&#10;import com.google.accompanist.permissions.shouldShowRationale&#10;import java.util.concurrent.ExecutorService&#10;import java.util.concurrent.Executors&#10;import androidx.camera.core.Preview as CameraPreview&#10;&#10;@OptIn(ExperimentalMaterial3Api::class, ExperimentalPermissionsApi::class)&#10;@Composable&#10;fun FaceScannerScreen(&#10;    action: String,&#10;    navController: NavController,&#10;    modifier: Modifier = Modifier,&#10;    viewModel: FaceScannerViewModel = hiltViewModel()&#10;) {&#10;    val uiState by viewModel.uiState.collectAsStateWithLifecycle()&#10;&#10;    // Camera permission state&#10;    val cameraPermissionState = rememberPermissionState(&#10;        android.Manifest.permission.CAMERA&#10;    )&#10;&#10;    // Camera executor&#10;    val cameraExecutor = remember { Executors.newSingleThreadExecutor() }&#10;&#10;    // Request camera permission when screen opens&#10;    LaunchedEffect(Unit) {&#10;        if (!cameraPermissionState.status.isGranted) {&#10;            cameraPermissionState.launchPermissionRequest()&#10;        }&#10;    }&#10;&#10;    // Handle navigation based on verification result&#10;    LaunchedEffect(uiState.livenessState) {&#10;        when (uiState.livenessState) {&#10;            LivenessState.SUCCESS -&gt; {&#10;                // FIXED: Send success result and navigate back to proceed with attendance&#10;                navController.previousBackStackEntry?.savedStateHandle?.set(&#10;                    &quot;face_verification_result&quot;,&#10;                    true&#10;                )&#10;                navController.popBackStack()&#10;            }&#10;&#10;            LivenessState.TIMEOUT -&gt; {&#10;                // TIMEOUT means user ran out of time - send failure and go back&#10;                navController.previousBackStackEntry?.savedStateHandle?.set(&#10;                    &quot;face_verification_result&quot;,&#10;                    false&#10;                )&#10;                navController.popBackStack()&#10;            }&#10;&#10;            // FAILURE stays on screen to allow retry - no automatic navigation&#10;            LivenessState.FAILURE -&gt; {&#10;                // Stay on screen, show retry button - user can try again&#10;                println(&quot;DEBUG: Face verification failed - staying on screen for retry&quot;)&#10;            }&#10;&#10;            else -&gt; {&#10;                // Continue with current state - don't navigate anywhere&#10;            }&#10;        }&#10;    }&#10;&#10;    // Cleanup camera executor when composable is disposed&#10;    DisposableEffect(Unit) {&#10;        onDispose {&#10;            cameraExecutor.shutdown()&#10;        }&#10;    }&#10;&#10;    Box(modifier = modifier.fillMaxSize()) {&#10;        when {&#10;            cameraPermissionState.status.isGranted -&gt; {&#10;                // Camera permission granted - show camera interface&#10;                CameraContent(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    action = action,&#10;                    uiState = uiState,&#10;                    cameraExecutor = cameraExecutor,&#10;                    onImageAnalysis = { imageProxy, bitmap -&gt;&#10;                        viewModel.processImageProxy(imageProxy, bitmap)&#10;                    },&#10;                    onRetryClick = {&#10;                        viewModel.resetScanner()&#10;                    },&#10;                    onCloseClick = {&#10;                        navController.popBackStack()&#10;                    }&#10;                )&#10;            }&#10;&#10;            cameraPermissionState.status.shouldShowRationale -&gt; {&#10;                // Show rationale for camera permission&#10;                CameraPermissionRationale(&#10;                    onRequestPermission = {&#10;                        cameraPermissionState.launchPermissionRequest()&#10;                    },&#10;                    onCloseClick = {&#10;                        navController.popBackStack()&#10;                    }&#10;                )&#10;            }&#10;&#10;            else -&gt; {&#10;                // Permission denied - show permission request UI&#10;                CameraPermissionDenied(&#10;                    onRequestPermission = {&#10;                        cameraPermissionState.launchPermissionRequest()&#10;                    },&#10;                    onCloseClick = {&#10;                        navController.popBackStack()&#10;                    }&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun CameraContent(&#10;    modifier: Modifier = Modifier,&#10;    action: String,&#10;    uiState: FaceScannerState,&#10;    cameraExecutor: ExecutorService,&#10;    onImageAnalysis: (ImageProxy, Bitmap) -&gt; Unit,&#10;    onRetryClick: () -&gt; Unit,&#10;    onCloseClick: () -&gt; Unit&#10;) {&#10;    val density = LocalDensity.current&#10;    var previewSize by remember { mutableStateOf&lt;androidx.compose.ui.geometry.Size?&gt;(null) }&#10;&#10;    // Get screen dimensions for proper scaling&#10;    val configuration = androidx.compose.ui.platform.LocalConfiguration.current&#10;    val screenWidth = configuration.screenWidthDp.dp&#10;    val screenHeight = configuration.screenHeightDp.dp&#10;&#10;    Box(&#10;        modifier = modifier&#10;            .fillMaxSize()&#10;            .onSizeChanged { size -&gt;&#10;                // Capture actual preview size for coordinate scaling&#10;                previewSize = androidx.compose.ui.geometry.Size(&#10;                    width = size.width.toFloat(),&#10;                    height = size.height.toFloat()&#10;                )&#10;                println(&quot;Preview size captured: ${size.width}x${size.height}&quot;)&#10;            }&#10;    ) {&#10;        // Layer 1: Camera Preview with proper CameraX integration&#10;        CameraPreview(&#10;            modifier = Modifier.fillMaxSize(),&#10;            cameraExecutor = cameraExecutor,&#10;            onImageAnalysis = { imageProxy, bitmap -&gt;&#10;                onImageAnalysis(imageProxy, bitmap)&#10;            }&#10;        )&#10;&#10;        // Layer 2: Face Bounding Box Overlay with proper coordinate scaling&#10;        FaceBoundingBox(&#10;            modifier = Modifier.fillMaxSize(),&#10;            boundingBox = uiState.boundingBox,&#10;            livenessState = uiState.livenessState,&#10;            previewSize = previewSize, // Pass actual preview size&#10;            imageSize = uiState.imageSize // Pass image size from ViewModel&#10;        )&#10;&#10;        // Layer 3: Top Info Section - More compact&#10;        TopInfoSection(&#10;            modifier = Modifier&#10;                .align(Alignment.TopCenter)&#10;                .padding(top = 16.dp, start = 16.dp, end = 16.dp),&#10;            action = action&#10;        )&#10;&#10;        // Layer 4: Instruction Section with dynamic content&#10;        InstructionSection(&#10;            modifier = Modifier&#10;                .align(Alignment.BottomCenter)&#10;                .padding(bottom = 16.dp, start = 16.dp, end = 16.dp),&#10;            uiState = uiState,&#10;            onRetryClick = onRetryClick,&#10;            onCloseClick = onCloseClick&#10;        )&#10;&#10;        // Layer 5: Loading Overlay for processing state&#10;        if (uiState.isProcessing) {&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .background(Color.Black.copy(alpha = 0.3f)),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Card(&#10;                    modifier = Modifier.padding(32.dp),&#10;                    colors = CardDefaults.cardColors(&#10;                        containerColor = MaterialTheme.colorScheme.surface&#10;                    )&#10;                ) {&#10;                    Column(&#10;                        modifier = Modifier.padding(24.dp),&#10;                        horizontalAlignment = Alignment.CenterHorizontally,&#10;                        verticalArrangement = Arrangement.spacedBy(16.dp)&#10;                    ) {&#10;                        LoadingAnimation()&#10;                        Text(&#10;                            text = uiState.instructionText,&#10;                            style = MaterialTheme.typography.bodyMedium,&#10;                            textAlign = TextAlign.Center&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun CameraPreview(&#10;    modifier: Modifier = Modifier,&#10;    cameraExecutor: ExecutorService,&#10;    onImageAnalysis: (ImageProxy, Bitmap) -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val lifecycleOwner = androidx.lifecycle.compose.LocalLifecycleOwner.current&#10;    val previewView = remember {&#10;        PreviewView(context).apply {&#10;            scaleType = PreviewView.ScaleType.FILL_CENTER&#10;        }&#10;    }&#10;&#10;    // Use LaunchedEffect instead of AndroidView update to prevent rebinding&#10;    LaunchedEffect(Unit) {&#10;        val cameraProviderFuture = ProcessCameraProvider.getInstance(context)&#10;&#10;        try {&#10;            val cameraProvider = cameraProviderFuture.get()&#10;&#10;            // Unbind all use cases before rebinding&#10;            cameraProvider.unbindAll()&#10;&#10;            // Preview use case&#10;            val preview = CameraPreview.Builder()&#10;                .build()&#10;                .also {&#10;                    it.surfaceProvider = previewView.surfaceProvider&#10;                }&#10;&#10;            // Image analysis use case&#10;            val imageAnalysis = androidx.camera.core.ImageAnalysis.Builder()&#10;                .setBackpressureStrategy(androidx.camera.core.ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST)&#10;                .build()&#10;                .also { analysis -&gt;&#10;                    analysis.setAnalyzer(cameraExecutor) { imageProxy -&gt;&#10;                        try {&#10;                            val bitmap = imageProxyToBitmap(imageProxy)&#10;                            if (bitmap != null) {&#10;                                onImageAnalysis(imageProxy, bitmap)&#10;                            }&#10;                        } catch (e: Exception) {&#10;                            println(&quot;Error in image analysis: ${e.message}&quot;)&#10;                            imageProxy.close()&#10;                        }&#10;                    }&#10;                }&#10;&#10;            // Select front camera&#10;            val cameraSelector = CameraSelector.DEFAULT_FRONT_CAMERA&#10;&#10;            // Bind use cases to camera (only once)&#10;            cameraProvider.bindToLifecycle(&#10;                lifecycleOwner,&#10;                cameraSelector,&#10;                preview,&#10;                imageAnalysis&#10;            )&#10;&#10;            println(&quot;Camera bound successfully with preview and image analysis&quot;)&#10;&#10;        } catch (exc: Exception) {&#10;            println(&quot;Camera binding failed: ${exc.message}&quot;)&#10;            exc.printStackTrace()&#10;        }&#10;    }&#10;&#10;    // Simple AndroidView without update block&#10;    AndroidView(&#10;        factory = { previewView },&#10;        modifier = modifier&#10;    )&#10;}&#10;&#10;@Composable&#10;private fun TopInfoSection(&#10;    modifier: Modifier = Modifier,&#10;    action: String&#10;) {&#10;    Column(&#10;        modifier = modifier.fillMaxWidth(),&#10;        horizontalAlignment = Alignment.CenterHorizontally,&#10;        verticalArrangement = Arrangement.Center&#10;    ) {&#10;        Text(&#10;            text = &quot;Verifikasi Wajah&quot;,&#10;            style = MaterialTheme.typography.titleMedium,&#10;            color = Color.White,&#10;            fontWeight = FontWeight.Bold,&#10;            textAlign = TextAlign.Center,&#10;            modifier = Modifier.fillMaxWidth()&#10;        )&#10;        Spacer(modifier = Modifier.height(2.dp))&#10;        Text(&#10;            text = if (action == &quot;checkin&quot;) &quot;Check In&quot; else &quot;Check Out&quot;,&#10;            style = MaterialTheme.typography.bodyMedium,&#10;            color = Color.White.copy(alpha = 0.9f),&#10;            fontWeight = FontWeight.Medium,&#10;            textAlign = TextAlign.Center,&#10;            modifier = Modifier.fillMaxWidth()&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun InstructionSection(&#10;    modifier: Modifier = Modifier,&#10;    uiState: FaceScannerState,&#10;    onRetryClick: () -&gt; Unit,&#10;    onCloseClick: () -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = modifier.fillMaxWidth(),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.surface.copy(alpha = 0.50f)&#10;        ),&#10;        shape = RoundedCornerShape(16.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(12.dp),&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.spacedBy(8.dp)&#10;        ) {&#10;            // Status Icon&#10;            val icon = when (uiState.livenessState) {&#10;                LivenessState.WAITING_FOR_LIVENESS -&gt; {&#10;                    if (uiState.currentChallenge == LivenessChallenge.BLINK) {&#10;                        Icons.Default.Visibility&#10;                    } else {&#10;                        Icons.Default.SentimentSatisfied&#10;                    }&#10;                }&#10;&#10;                LivenessState.SUCCESS -&gt; Icons.Default.SentimentSatisfied&#10;                else -&gt; Icons.Default.Visibility&#10;            }&#10;&#10;            val iconColor = when (uiState.livenessState) {&#10;                LivenessState.SUCCESS -&gt; Color(0xFF00FFC2)&#10;                LivenessState.FAILURE, LivenessState.TIMEOUT -&gt; Color(0xFFFF3B30)&#10;                LivenessState.WAITING_FOR_LIVENESS -&gt; Color(0xFFFFD60A)&#10;                else -&gt; Color(0xFF00A3FF)&#10;            }&#10;&#10;            Icon(&#10;                imageVector = icon,&#10;                contentDescription = null,&#10;                modifier = Modifier.size(36.dp),&#10;                tint = iconColor&#10;            )&#10;&#10;            // Instruction Text&#10;            Text(&#10;                text = uiState.instructionText,&#10;                style = MaterialTheme.typography.bodyMedium,&#10;                textAlign = TextAlign.Center,&#10;                fontWeight = FontWeight.Medium&#10;            )&#10;&#10;            // Progress Indicator (for countdown)&#10;            if (uiState.showCountdown &amp;&amp; uiState.livenessState != LivenessState.SUCCESS) {&#10;                Row(&#10;                    verticalAlignment = Alignment.CenterVertically,&#10;                    horizontalArrangement = Arrangement.spacedBy(6.dp)&#10;                ) {&#10;                    LinearProgressIndicator(&#10;                        progress = uiState.progress,&#10;                        color = Blue_500,&#10;                        modifier = Modifier&#10;                            .weight(1f)&#10;                            .height(3.dp)&#10;                            .clip(RoundedCornerShape(2.dp))&#10;                    )&#10;                    Text(&#10;                        text = &quot;${uiState.timeRemaining}s&quot;,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f)&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Error Message&#10;            uiState.errorMessage?.let { errorMessage -&gt;&#10;                Text(&#10;                    text = errorMessage,&#10;                    style = MaterialTheme.typography.bodySmall,&#10;                    color = Color(0xFFFF3B30),&#10;                    textAlign = TextAlign.Center&#10;                )&#10;            }&#10;&#10;            // Action Buttons&#10;            Row(&#10;                horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;            ) {&#10;                // Close Button menggunakan StatefulButton dengan state Error&#10;                StatefulButton(&#10;                    text = &quot;Tutup&quot;,&#10;                    onClick = onCloseClick,&#10;                    modifier = Modifier.weight(1f),&#10;                    style = ButtonStyle.Outlined,&#10;                    stateType = ButtonStateType.Error,&#10;                    enabled = true&#10;                )&#10;&#10;                // Retry Button (show when failed or timeout) menggunakan StatefulButton&#10;                if (uiState.livenessState == LivenessState.FAILURE ||&#10;                    uiState.livenessState == LivenessState.TIMEOUT&#10;                ) {&#10;                    StatefulButton(&#10;                        text = &quot;Coba Lagi&quot;,&#10;                        onClick = onRetryClick,&#10;                        modifier = Modifier.weight(1f),&#10;                        style = ButtonStyle.Elevated,&#10;                        stateType = ButtonStateType.Info,&#10;                        enabled = true&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;// Helper function to convert ImageProxy to Bitmap - FIXED VERSION&#10;private fun imageProxyToBitmap(imageProxy: ImageProxy): Bitmap? {&#10;    return try {&#10;        // DON'T close imageProxy here - let FaceDetectorHelper handle it&#10;        // Get the YUV_420_888 image from camera&#10;        val image = imageProxy.image&#10;        if (image != null) {&#10;            val planes = image.planes&#10;            val yBuffer = planes[0].buffer&#10;            val uBuffer = planes[1].buffer&#10;            val vBuffer = planes[2].buffer&#10;&#10;            val ySize = yBuffer.remaining()&#10;            val uSize = uBuffer.remaining()&#10;            val vSize = vBuffer.remaining()&#10;&#10;            val nv21 = ByteArray(ySize + uSize + vSize)&#10;&#10;            // U and V are swapped&#10;            yBuffer.get(nv21, 0, ySize)&#10;            vBuffer.get(nv21, ySize, vSize)&#10;            uBuffer.get(nv21, ySize + vSize, uSize)&#10;&#10;            val yuvImage = android.graphics.YuvImage(&#10;                nv21,&#10;                android.graphics.ImageFormat.NV21,&#10;                image.width,&#10;                image.height,&#10;                null&#10;            )&#10;&#10;            val out = java.io.ByteArrayOutputStream()&#10;            yuvImage.compressToJpeg(&#10;                android.graphics.Rect(0, 0, image.width, image.height),&#10;                75,&#10;                out&#10;            )&#10;&#10;            val imageBytes = out.toByteArray()&#10;            val bitmap =&#10;                android.graphics.BitmapFactory.decodeByteArray(imageBytes, 0, imageBytes.size)&#10;&#10;            // Close the output stream&#10;            out.close()&#10;&#10;            println(&quot;Successfully converted ImageProxy to Bitmap: ${bitmap?.width}x${bitmap?.height}&quot;)&#10;            bitmap&#10;        } else {&#10;            println(&quot;ImageProxy.image is null&quot;)&#10;            null&#10;        }&#10;    } catch (e: Exception) {&#10;        println(&quot;Error converting ImageProxy to Bitmap: ${e.message}&quot;)&#10;        e.printStackTrace()&#10;        null&#10;    }&#10;    // DON'T close imageProxy here - FaceDetectorHelper will close it&#10;}&#10;&#10;// Permission UI Components&#10;@Composable&#10;private fun CameraPermissionRationale(&#10;    onRequestPermission: () -&gt; Unit,&#10;    onCloseClick: () -&gt; Unit&#10;) {&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(MaterialTheme.colorScheme.background),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(32.dp),&#10;            colors = CardDefaults.cardColors(&#10;                containerColor = MaterialTheme.colorScheme.surface&#10;            ),&#10;            shape = RoundedCornerShape(16.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(24.dp),&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#10;                verticalArrangement = Arrangement.spacedBy(16.dp)&#10;            ) {&#10;                Icon(&#10;                    imageVector = Icons.Default.Visibility,&#10;                    contentDescription = null,&#10;                    modifier = Modifier.size(64.dp),&#10;                    tint = MaterialTheme.colorScheme.primary&#10;                )&#10;&#10;                Text(&#10;                    text = &quot;Izin Kamera Diperlukan&quot;,&#10;                    style = MaterialTheme.typography.headlineSmall,&#10;                    fontWeight = FontWeight.Bold,&#10;                    textAlign = TextAlign.Center&#10;                )&#10;&#10;                Text(&#10;                    text = &quot;Aplikasi memerlukan akses kamera untuk melakukan verifikasi wajah. Fitur ini membantu memastikan keamanan absensi Anda.&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    textAlign = TextAlign.Center,&#10;                    color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.8f)&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                Row(&#10;                    horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;                    modifier = Modifier.fillMaxWidth()&#10;                ) {&#10;                    OutlinedButton(&#10;                        onClick = onCloseClick,&#10;                        modifier = Modifier.weight(1f)&#10;                    ) {&#10;                        Text(&quot;Batal&quot;)&#10;                    }&#10;&#10;                    Button(&#10;                        onClick = onRequestPermission,&#10;                        modifier = Modifier.weight(1f)&#10;                    ) {&#10;                        Text(&quot;Berikan Izin&quot;)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun CameraPermissionDenied(&#10;    onRequestPermission: () -&gt; Unit,&#10;    onCloseClick: () -&gt; Unit&#10;) {&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(MaterialTheme.colorScheme.background),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(32.dp),&#10;            colors = CardDefaults.cardColors(&#10;                containerColor = MaterialTheme.colorScheme.surface&#10;            ),&#10;            shape = RoundedCornerShape(16.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(24.dp),&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#10;                verticalArrangement = Arrangement.spacedBy(16.dp)&#10;            ) {&#10;                Icon(&#10;                    imageVector = Icons.Default.Close,&#10;                    contentDescription = null,&#10;                    modifier = Modifier.size(64.dp),&#10;                    tint = Color(0xFFFF3B30)&#10;                )&#10;&#10;                Text(&#10;                    text = &quot;Akses Kamera Dibutuhkan&quot;,&#10;                    style = MaterialTheme.typography.headlineSmall,&#10;                    fontWeight = FontWeight.Bold,&#10;                    textAlign = TextAlign.Center&#10;                )&#10;&#10;                Text(&#10;                    text = &quot;Tanpa akses kamera, fitur verifikasi wajah tidak dapat berfungsi. Silakan berikan izin kamera untuk melanjutkan proses absensi.&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    textAlign = TextAlign.Center,&#10;                    color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.8f)&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                Row(&#10;                    horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;                    modifier = Modifier.fillMaxWidth()&#10;                ) {&#10;                    OutlinedButton(&#10;                        onClick = onCloseClick,&#10;                        modifier = Modifier.weight(1f)&#10;                    ) {&#10;                        Text(&quot;Tutup&quot;)&#10;                    }&#10;&#10;                    Button(&#10;                        onClick = onRequestPermission,&#10;                        modifier = Modifier.weight(1f)&#10;                    ) {&#10;                        Text(&quot;Coba Lagi&quot;)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;// Preview Composables for different states&#10;@Preview(showBackground = true, name = &quot;Check In - Initial State&quot;)&#10;@Composable&#10;fun PreviewFaceScannerCheckIn() {&#10;    MaterialTheme {&#10;        FaceScannerScreenPreview(&#10;            action = &quot;checkin&quot;,&#10;            state = FaceScannerState(&#10;                livenessState = LivenessState.IDLE,&#10;                instructionText = &quot;Posisikan wajah Anda dalam frame&quot;,&#10;                isProcessing = false,&#10;                showCountdown = false&#10;            )&#10;        )&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true, name = &quot;Check Out - Waiting for Liveness&quot;)&#10;@Composable&#10;fun PreviewFaceScannerCheckOutWaiting() {&#10;    MaterialTheme {&#10;        FaceScannerScreenPreview(&#10;            action = &quot;checkout&quot;,&#10;            state = FaceScannerState(&#10;                livenessState = LivenessState.WAITING_FOR_LIVENESS,&#10;                currentChallenge = LivenessChallenge.BLINK,&#10;                instructionText = &quot;Silakan berkedip untuk verifikasi&quot;,&#10;                isProcessing = false,&#10;                showCountdown = true,&#10;                progress = 0.6f,&#10;                timeRemaining = 4&#10;            )&#10;        )&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true, name = &quot;Processing State&quot;)&#10;@Composable&#10;fun PreviewFaceScannerProcessing() {&#10;    MaterialTheme {&#10;        FaceScannerScreenPreview(&#10;            action = &quot;checkin&quot;,&#10;            state = FaceScannerState(&#10;                livenessState = LivenessState.VERIFYING_FACE,&#10;                instructionText = &quot;Memproses verifikasi wajah...&quot;,&#10;                isProcessing = true,&#10;                showCountdown = false&#10;            )&#10;        )&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true, name = &quot;Success State&quot;)&#10;@Composable&#10;fun PreviewFaceScannerSuccess() {&#10;    MaterialTheme {&#10;        FaceScannerScreenPreview(&#10;            action = &quot;checkin&quot;,&#10;            state = FaceScannerState(&#10;                livenessState = LivenessState.SUCCESS,&#10;                instructionText = &quot;Verifikasi berhasil!&quot;,&#10;                isProcessing = false,&#10;                showCountdown = false&#10;            )&#10;        )&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true, name = &quot;Failure State&quot;)&#10;@Composable&#10;fun PreviewFaceScannerFailure() {&#10;    MaterialTheme {&#10;        FaceScannerScreenPreview(&#10;            action = &quot;checkout&quot;,&#10;            state = FaceScannerState(&#10;                livenessState = LivenessState.FAILURE,&#10;                instructionText = &quot;Verifikasi gagal&quot;,&#10;                errorMessage = &quot;Wajah tidak terdeteksi dengan jelas. Silakan coba lagi.&quot;,&#10;                isProcessing = false,&#10;                showCountdown = false&#10;            )&#10;        )&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true, name = &quot;Timeout State&quot;)&#10;@Composable&#10;fun PreviewFaceScannerTimeout() {&#10;    MaterialTheme {&#10;        FaceScannerScreenPreview(&#10;            action = &quot;checkin&quot;,&#10;            state = FaceScannerState(&#10;                livenessState = LivenessState.TIMEOUT,&#10;                instructionText = &quot;Waktu habis&quot;,&#10;                errorMessage = &quot;Waktu verifikasi telah habis. Silakan coba lagi.&quot;,&#10;                isProcessing = false,&#10;                showCountdown = false&#10;            )&#10;        )&#10;    }&#10;}&#10;&#10;// Simplified preview composable without camera and ViewModel dependencies&#10;@Composable&#10;private fun FaceScannerScreenPreview(&#10;    action: String,&#10;    state: FaceScannerState&#10;) {&#10;    Box(modifier = Modifier.fillMaxSize()) {&#10;        // Mock camera background&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .background(Color.Black)&#10;        )&#10;&#10;        // Top Info Section&#10;        TopInfoSection(&#10;            modifier = Modifier&#10;                .align(Alignment.TopCenter)&#10;                .padding(top = 48.dp, start = 24.dp, end = 24.dp),&#10;            action = action&#10;        )&#10;&#10;        // Instruction Section&#10;        InstructionSection(&#10;            modifier = Modifier&#10;                .align(Alignment.BottomCenter)&#10;                .padding(bottom = 48.dp, start = 24.dp, end = 24.dp),&#10;            uiState = state,&#10;            onRetryClick = {},&#10;            onCloseClick = {}&#10;        )&#10;&#10;        // Loading Overlay for processing state&#10;        if (state.isProcessing) {&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .background(Color.Black.copy(alpha = 0.3f)),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Card(&#10;                    modifier = Modifier.padding(32.dp),&#10;                    colors = CardDefaults.cardColors(&#10;                        containerColor = MaterialTheme.colorScheme.surface&#10;                    )&#10;                ) {&#10;                    Column(&#10;                        modifier = Modifier.padding(24.dp),&#10;                        horizontalAlignment = Alignment.CenterHorizontally,&#10;                        verticalArrangement = Arrangement.spacedBy(16.dp)&#10;                    ) {&#10;                        CircularProgressIndicator()&#10;                        Text(&#10;                            text = state.instructionText,&#10;                            style = MaterialTheme.typography.bodyMedium,&#10;                            textAlign = TextAlign.Center&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/presentation/screen/attendance/face/FaceScannerViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/presentation/screen/attendance/face/FaceScannerViewModel.kt" />
              <option name="originalContent" value="package com.example.infinite_track.presentation.screen.attendance.face&#10;&#10;import android.graphics.Bitmap&#10;import androidx.camera.core.ImageProxy&#10;import androidx.compose.ui.geometry.Rect&#10;import androidx.compose.ui.geometry.Size&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.infinite_track.data.face.FaceDetectorHelper&#10;import com.example.infinite_track.domain.use_case.auth.VerifyFaceUseCase&#10;import com.google.mlkit.vision.face.Face&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;&#10;/**&#10; * Enum untuk tantangan liveness detection&#10; */&#10;enum class LivenessChallenge {&#10;    BLINK, SMILE&#10;}&#10;&#10;/**&#10; * Enum untuk status proses liveness detection&#10; */&#10;enum class LivenessState {&#10;    IDLE,&#10;    DETECTING_FACE,&#10;    WAITING_FOR_LIVENESS,&#10;    LIVENESS_DETECTED,&#10;    VERIFYING_FACE,&#10;    SUCCESS,&#10;    FAILURE,&#10;    TIMEOUT&#10;}&#10;&#10;/**&#10; * Data class untuk state lengkap face scanner&#10; */&#10;data class FaceScannerState(&#10;    val livenessState: LivenessState = LivenessState.IDLE,&#10;    val currentChallenge: LivenessChallenge = LivenessChallenge.BLINK,&#10;    val instructionText: String = &quot;&quot;,&#10;    val boundingBox: Rect? = null, // Changed to androidx.compose.ui.geometry.Rect&#10;    val progress: Float = 0f,&#10;    val errorMessage: String? = null,&#10;    val isProcessing: Boolean = false,&#10;    val timeRemaining: Int = 20, // 20 detik sesuai kebutuhan&#10;    val showCountdown: Boolean = false,&#10;    val imageSize: Size? = null // Add image size for coordinate scaling&#10;)&#10;&#10;/**&#10; * ViewModel untuk mengatur logika face scanning dengan liveness detection&#10; */&#10;@HiltViewModel&#10;class FaceScannerViewModel @Inject constructor(&#10;    private val faceDetectorHelper: FaceDetectorHelper,&#10;    private val verifyFaceUseCase: VerifyFaceUseCase&#10;) : ViewModel() {&#10;&#10;    companion object {&#10;        private const val TIMEOUT_SECONDS = 20&#10;        private const val LIVENESS_HOLD_DURATION = 1500L // 1.5 detik hold untuk stabilitas&#10;    }&#10;&#10;    // Change from mutableStateOf to StateFlow for better compatibility&#10;    private val _uiState = MutableStateFlow(FaceScannerState())&#10;    val uiState: StateFlow&lt;FaceScannerState&gt; = _uiState.asStateFlow()&#10;&#10;    private var timeoutJob: Job? = null&#10;    private var livenessJob: Job? = null&#10;    private var currentDetectedFace: Face? = null&#10;    private var currentImageBitmap: Bitmap? = null&#10;&#10;    init {&#10;        initializeScanner()&#10;    }&#10;&#10;    /**&#10;     * Inisialisasi scanner dengan random challenge&#10;     */&#10;    private fun initializeScanner() {&#10;        // Pilih challenge secara acak&#10;        val randomChallenge = if ((0..1).random() == 0) {&#10;            LivenessChallenge.BLINK&#10;        } else {&#10;            LivenessChallenge.SMILE&#10;        }&#10;&#10;        val instructionText = when (randomChallenge) {&#10;            LivenessChallenge.BLINK -&gt; &quot;Posisikan wajah Anda di dalam frame, lalu kedipkan mata&quot;&#10;            LivenessChallenge.SMILE -&gt; &quot;Posisikan wajah Anda di dalam frame, lalu tersenyum&quot;&#10;        }&#10;&#10;        _uiState.value = _uiState.value.copy(&#10;            currentChallenge = randomChallenge,&#10;            instructionText = instructionText,&#10;            livenessState = LivenessState.DETECTING_FACE,&#10;            timeRemaining = TIMEOUT_SECONDS,&#10;            showCountdown = true,&#10;            isProcessing = false,&#10;            errorMessage = null,&#10;            boundingBox = null,&#10;            progress = 0f&#10;        )&#10;&#10;        startTimeout()&#10;    }&#10;&#10;    /**&#10;     * Proses frame dari kamera untuk deteksi wajah dan verifikasi liveness&#10;     */&#10;    fun processImageProxy(imageProxy: ImageProxy, imageBitmap: Bitmap) {&#10;        // Jangan proses jika sedang dalam proses atau sudah timeout/selesai&#10;        if (_uiState.value.isProcessing ||&#10;            _uiState.value.livenessState == LivenessState.SUCCESS ||&#10;            _uiState.value.livenessState == LivenessState.TIMEOUT ||&#10;            _uiState.value.livenessState == LivenessState.FAILURE&#10;        ) {&#10;            imageProxy.close()&#10;            return&#10;        }&#10;&#10;        currentImageBitmap = imageBitmap&#10;&#10;        // Panggil FaceDetectorHelper untuk mendeteksi wajah&#10;        faceDetectorHelper.detect(imageProxy) { result -&gt;&#10;            result.onSuccess { face -&gt;&#10;                handleFaceDetected(face, imageBitmap.width, imageBitmap.height)&#10;            }.onFailure { exception -&gt;&#10;                handleFaceDetectionError(exception.message ?: &quot;Error mendeteksi wajah&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Handle ketika wajah berhasil terdeteksi&#10;     */&#10;    private fun handleFaceDetected(face: Face, imageWidth: Int, imageHeight: Int) {&#10;        currentDetectedFace = face&#10;&#10;        // Convert android.graphics.Rect to androidx.compose.ui.geometry.Rect&#10;        val androidRect = face.boundingBox&#10;        val composeRect = Rect(&#10;            left = androidRect.left.toFloat(),&#10;            top = androidRect.top.toFloat(),&#10;            right = androidRect.right.toFloat(),&#10;            bottom = androidRect.bottom.toFloat()&#10;        )&#10;&#10;        // Update bounding box dan image size untuk UI dengan coordinate scaling yang proper&#10;        _uiState.value = _uiState.value.copy(&#10;            boundingBox = composeRect,&#10;            imageSize = Size(&#10;                width = imageWidth.toFloat(),&#10;                height = imageHeight.toFloat()&#10;            )&#10;        )&#10;&#10;        // Debug log untuk melihat koordinat&#10;        println(&quot;Face detected - Android Rect: $androidRect&quot;)&#10;        println(&quot;Face detected - Compose Rect: $composeRect&quot;)&#10;        println(&quot;Image size: ${imageWidth}x${imageHeight}&quot;)&#10;&#10;        // Cek apakah wajah berada di posisi yang baik&#10;        if (!faceDetectorHelper.isFaceWellPositioned(face, imageWidth, imageHeight)) {&#10;            _uiState.value = _uiState.value.copy(&#10;                livenessState = LivenessState.DETECTING_FACE,&#10;                instructionText = &quot;Posisikan wajah Anda lebih dekat dan di tengah frame&quot;&#10;            )&#10;            return&#10;        }&#10;&#10;        // Wajah sudah di posisi yang baik, lanjut ke pengecekan liveness&#10;        when (_uiState.value.livenessState) {&#10;            LivenessState.DETECTING_FACE -&gt; {&#10;                // Transisi ke waiting for liveness&#10;                _uiState.value = _uiState.value.copy(&#10;                    livenessState = LivenessState.WAITING_FOR_LIVENESS,&#10;                    instructionText = when (_uiState.value.currentChallenge) {&#10;                        LivenessChallenge.BLINK -&gt; &quot;Wajah terdeteksi! Sekarang kedipkan mata Anda&quot;&#10;                        LivenessChallenge.SMILE -&gt; &quot;Wajah terdeteksi! Sekarang tersenyum&quot;&#10;                    }&#10;                )&#10;            }&#10;&#10;            LivenessState.WAITING_FOR_LIVENESS -&gt; {&#10;                // Cek apakah challenge liveness terpenuhi&#10;                checkLivenessChallenge(face)&#10;            }&#10;&#10;            else -&gt; {&#10;                // State lain tidak perlu di-handle di sini&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Cek apakah challenge liveness saat ini terpenuhi&#10;     */&#10;    private fun checkLivenessChallenge(face: Face) {&#10;        val isLivenessDetected = when (_uiState.value.currentChallenge) {&#10;            LivenessChallenge.BLINK -&gt; faceDetectorHelper.verifyBlink(face)&#10;            LivenessChallenge.SMILE -&gt; faceDetectorHelper.verifySmile(face)&#10;        }&#10;&#10;        if (isLivenessDetected) {&#10;            _uiState.value = _uiState.value.copy(&#10;                livenessState = LivenessState.LIVENESS_DETECTED,&#10;                instructionText = &quot;Liveness terdeteksi! Tetap di posisi...&quot;&#10;            )&#10;&#10;            // Tahan deteksi sebentar untuk stabilitas, lalu lanjut verifikasi&#10;            livenessJob?.cancel()&#10;            livenessJob = viewModelScope.launch {&#10;                delay(LIVENESS_HOLD_DURATION)&#10;                proceedWithFaceVerification()&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Lanjutkan dengan verifikasi wajah setelah liveness terkonfirmasi&#10;     */&#10;    private fun proceedWithFaceVerification() {&#10;        val face = currentDetectedFace&#10;        val bitmap = currentImageBitmap&#10;&#10;        if (face == null || bitmap == null) {&#10;            handleVerificationError(&quot;Gagal mengambil data wajah&quot;)&#10;            return&#10;        }&#10;&#10;        _uiState.value = _uiState.value.copy(&#10;            livenessState = LivenessState.VERIFYING_FACE,&#10;            isProcessing = true,&#10;            instructionText = &quot;Memverifikasi identitas Anda...&quot;,&#10;            showCountdown = false&#10;        )&#10;&#10;        viewModelScope.launch {&#10;            try {&#10;                    handleVerificationError(&quot;Gagal mengekstrak wajah dari gambar&quot;)&#10;                    return@launch&#10;                }&#10;&#10;                // Verifikasi wajah menggunakan VerifyFaceUseCase&#10;                verifyFaceUseCase(faceBitmap)&#10;                    .onSuccess { isMatch -&gt;&#10;                        if (isMatch) {&#10;                        }&#10;                    .onFailure { exception -&gt;&#10;                        handleVerificationError(&#10;                        )&#10;                    }&#10;&#10;            } catch (e: Exception) {&#10;                handleVerificationError(&quot;Terjadi kesalahan: ${e.message}&quot;)&#10;            }&#10;        }&#10;&#10;    /**&#10;     * Handle sukses verifikasi wajah&#10;     */&#10;    private fun handleVerificationSuccess() {&#10;        timeoutJob?.cancel()&#10;&#10;        _uiState.value = _uiState.value.copy(&#10;            livenessState = LivenessState.SUCCESS,&#10;            isProcessing = false,&#10;            instructionText = &quot;Verifikasi berhasil! Identitas terkonfirmasi.&quot;,&#10;            progress = 1f,&#10;            showCountdown = false,&#10;            errorMessage = null&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Handle error deteksi wajah&#10;     */&#10;    private fun handleFaceDetectionError(errorMessage: String) {&#10;        // Hanya update instruction jika masih dalam tahap deteksi&#10;        if (_uiState.value.livenessState == LivenessState.DETECTING_FACE) {&#10;            _uiState.value = _uiState.value.copy(&#10;                instructionText = &quot;Mencari wajah... Pastikan wajah terlihat jelas di dalam frame&quot;,&#10;                boundingBox = null&#10;            )&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Handle error verifikasi wajah&#10;     */&#10;    private fun handleVerificationError(errorMessage: String) {&#10;        timeoutJob?.cancel()&#10;        livenessJob?.cancel()&#10;&#10;        _uiState.value = _uiState.value.copy(&#10;            livenessState = LivenessState.FAILURE,&#10;            isProcessing = false,&#10;            instructionText = &quot;Verifikasi gagal&quot;,&#10;            errorMessage = errorMessage,&#10;            showCountdown = false&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Mulai countdown timer untuk timeout&#10;     */&#10;    private fun startTimeout() {&#10;        timeoutJob?.cancel()&#10;        timeoutJob = viewModelScope.launch {&#10;            repeat(TIMEOUT_SECONDS) { second -&gt;&#10;                val remainingTime = TIMEOUT_SECONDS - second&#10;                _uiState.value = _uiState.value.copy(&#10;                    timeRemaining = remainingTime,&#10;                    progress = second.toFloat() / TIMEOUT_SECONDS&#10;                )&#10;                delay(1000)&#10;&#10;                // Cek apakah proses sudah selesai&#10;                if (_uiState.value.livenessState == LivenessState.SUCCESS ||&#10;                    _uiState.value.livenessState == LivenessState.FAILURE&#10;                ) {&#10;                    return@launch&#10;                }&#10;            }&#10;&#10;            // Timeout tercapai&#10;            handleTimeout()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Handle timeout&#10;     */&#10;    private fun handleTimeout() {&#10;        livenessJob?.cancel()&#10;&#10;        _uiState.value = _uiState.value.copy(&#10;            livenessState = LivenessState.TIMEOUT,&#10;            isProcessing = false,&#10;            instructionText = &quot;Waktu habis&quot;,&#10;            errorMessage = &quot;Tidak dapat mendeteksi wajah dalam waktu $TIMEOUT_SECONDS detik. Silakan coba lagi.&quot;,&#10;            showCountdown = false,&#10;            timeRemaining = 0&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Reset scanner untuk mencoba lagi&#10;     */&#10;    fun resetScanner() {&#10;        timeoutJob?.cancel()&#10;        livenessJob?.cancel()&#10;        currentDetectedFace = null&#10;        currentImageBitmap = null&#10;&#10;        initializeScanner()&#10;    }&#10;&#10;    /**&#10;     * Bersihkan resources ketika ViewModel dihancurkan&#10;     */&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        timeoutJob?.cancel()&#10;        livenessJob?.cancel()&#10;        faceDetectorHelper.release()&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.infinite_track.presentation.screen.attendance.face&#10;&#10;import android.graphics.Bitmap&#10;import androidx.camera.core.ImageProxy&#10;import androidx.compose.ui.geometry.Rect&#10;import androidx.compose.ui.geometry.Size&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.infinite_track.data.face.FaceDetectorHelper&#10;import com.example.infinite_track.domain.use_case.auth.VerifyFaceUseCase&#10;import com.google.mlkit.vision.face.Face&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;&#10;/**&#10; * Enum untuk tantangan liveness detection&#10; */&#10;enum class LivenessChallenge {&#10;    BLINK, SMILE&#10;}&#10;&#10;/**&#10; * Enum untuk status proses liveness detection&#10; */&#10;enum class LivenessState {&#10;    IDLE,&#10;    DETECTING_FACE,&#10;    WAITING_FOR_LIVENESS,&#10;    LIVENESS_DETECTED,&#10;    VERIFYING_FACE,&#10;    SUCCESS,&#10;    FAILURE,&#10;    TIMEOUT&#10;}&#10;&#10;/**&#10; * Data class untuk state lengkap face scanner&#10; */&#10;data class FaceScannerState(&#10;    val livenessState: LivenessState = LivenessState.IDLE,&#10;    val currentChallenge: LivenessChallenge = LivenessChallenge.BLINK,&#10;    val instructionText: String = &quot;&quot;,&#10;    val boundingBox: Rect? = null, // Changed to androidx.compose.ui.geometry.Rect&#10;    val progress: Float = 0f,&#10;    val errorMessage: String? = null,&#10;    val isProcessing: Boolean = false,&#10;    val timeRemaining: Int = 20, // 20 detik sesuai kebutuhan&#10;    val showCountdown: Boolean = false,&#10;    val imageSize: Size? = null // Add image size for coordinate scaling&#10;)&#10;&#10;/**&#10; * ViewModel untuk mengatur logika face scanning dengan liveness detection&#10; */&#10;@HiltViewModel&#10;class FaceScannerViewModel @Inject constructor(&#10;    private val faceDetectorHelper: FaceDetectorHelper,&#10;    private val verifyFaceUseCase: VerifyFaceUseCase&#10;) : ViewModel() {&#10;&#10;    companion object {&#10;        private const val TIMEOUT_SECONDS = 20&#10;        private const val LIVENESS_HOLD_DURATION = 1500L // 1.5 detik hold untuk stabilitas&#10;    }&#10;&#10;    // Change from mutableStateOf to StateFlow for better compatibility&#10;    private val _uiState = MutableStateFlow(FaceScannerState())&#10;    val uiState: StateFlow&lt;FaceScannerState&gt; = _uiState.asStateFlow()&#10;&#10;    private var timeoutJob: Job? = null&#10;    private var livenessJob: Job? = null&#10;    private var currentDetectedFace: Face? = null&#10;    private var currentImageBitmap: Bitmap? = null&#10;&#10;    init {&#10;        initializeScanner()&#10;    }&#10;&#10;    /**&#10;     * Inisialisasi scanner dengan random challenge&#10;     */&#10;    private fun initializeScanner() {&#10;        // Pilih challenge secara acak&#10;        val randomChallenge = if ((0..1).random() == 0) {&#10;            LivenessChallenge.BLINK&#10;        } else {&#10;            LivenessChallenge.SMILE&#10;        }&#10;&#10;        val instructionText = when (randomChallenge) {&#10;            LivenessChallenge.BLINK -&gt; &quot;Posisikan wajah Anda di dalam frame, lalu kedipkan mata&quot;&#10;            LivenessChallenge.SMILE -&gt; &quot;Posisikan wajah Anda di dalam frame, lalu tersenyum&quot;&#10;        }&#10;&#10;        _uiState.value = _uiState.value.copy(&#10;            currentChallenge = randomChallenge,&#10;            instructionText = instructionText,&#10;            livenessState = LivenessState.DETECTING_FACE,&#10;            timeRemaining = TIMEOUT_SECONDS,&#10;            showCountdown = true,&#10;            isProcessing = false,&#10;            errorMessage = null,&#10;            boundingBox = null,&#10;            progress = 0f&#10;        )&#10;&#10;        startTimeout()&#10;    }&#10;&#10;    /**&#10;     * Proses frame dari kamera untuk deteksi wajah dan verifikasi liveness&#10;     */&#10;    fun processImageProxy(imageProxy: ImageProxy, imageBitmap: Bitmap) {&#10;        // Jangan proses jika sedang dalam proses atau sudah timeout/selesai&#10;        if (_uiState.value.isProcessing ||&#10;            _uiState.value.livenessState == LivenessState.SUCCESS ||&#10;            _uiState.value.livenessState == LivenessState.TIMEOUT ||&#10;            _uiState.value.livenessState == LivenessState.FAILURE&#10;        ) {&#10;            imageProxy.close()&#10;            return&#10;        }&#10;&#10;        currentImageBitmap = imageBitmap&#10;&#10;        // Panggil FaceDetectorHelper untuk mendeteksi wajah&#10;        faceDetectorHelper.detect(imageProxy) { result -&gt;&#10;            result.onSuccess { face -&gt;&#10;                handleFaceDetected(face, imageBitmap.width, imageBitmap.height)&#10;            }.onFailure { exception -&gt;&#10;                handleFaceDetectionError(exception.message ?: &quot;Error mendeteksi wajah&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Handle ketika wajah berhasil terdeteksi&#10;     */&#10;    private fun handleFaceDetected(face: Face, imageWidth: Int, imageHeight: Int) {&#10;        currentDetectedFace = face&#10;&#10;        // Convert android.graphics.Rect to androidx.compose.ui.geometry.Rect&#10;        val androidRect = face.boundingBox&#10;        val composeRect = Rect(&#10;            left = androidRect.left.toFloat(),&#10;            top = androidRect.top.toFloat(),&#10;            right = androidRect.right.toFloat(),&#10;            bottom = androidRect.bottom.toFloat()&#10;        )&#10;&#10;        // Update bounding box dan image size untuk UI dengan coordinate scaling yang proper&#10;        _uiState.value = _uiState.value.copy(&#10;            boundingBox = composeRect,&#10;            imageSize = Size(&#10;                width = imageWidth.toFloat(),&#10;                height = imageHeight.toFloat()&#10;            )&#10;        )&#10;&#10;        // Debug log untuk melihat koordinat&#10;        println(&quot;Face detected - Android Rect: $androidRect&quot;)&#10;        println(&quot;Face detected - Compose Rect: $composeRect&quot;)&#10;        println(&quot;Image size: ${imageWidth}x${imageHeight}&quot;)&#10;&#10;        // Cek apakah wajah berada di posisi yang baik&#10;        if (!faceDetectorHelper.isFaceWellPositioned(face, imageWidth, imageHeight)) {&#10;            _uiState.value = _uiState.value.copy(&#10;                livenessState = LivenessState.DETECTING_FACE,&#10;                instructionText = &quot;Posisikan wajah Anda lebih dekat dan di tengah frame&quot;&#10;            )&#10;            return&#10;        }&#10;&#10;        // Wajah sudah di posisi yang baik, lanjut ke pengecekan liveness&#10;        when (_uiState.value.livenessState) {&#10;            LivenessState.DETECTING_FACE -&gt; {&#10;                // Transisi ke waiting for liveness&#10;                _uiState.value = _uiState.value.copy(&#10;                    livenessState = LivenessState.WAITING_FOR_LIVENESS,&#10;                    instructionText = when (_uiState.value.currentChallenge) {&#10;                        LivenessChallenge.BLINK -&gt; &quot;Wajah terdeteksi! Sekarang kedipkan mata Anda&quot;&#10;                        LivenessChallenge.SMILE -&gt; &quot;Wajah terdeteksi! Sekarang tersenyum&quot;&#10;                    }&#10;                )&#10;            }&#10;&#10;            LivenessState.WAITING_FOR_LIVENESS -&gt; {&#10;                // Cek apakah challenge liveness terpenuhi&#10;                checkLivenessChallenge(face)&#10;            }&#10;&#10;            else -&gt; {&#10;                // State lain tidak perlu di-handle di sini&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Cek apakah challenge liveness saat ini terpenuhi&#10;     */&#10;    private fun checkLivenessChallenge(face: Face) {&#10;        val isLivenessDetected = when (_uiState.value.currentChallenge) {&#10;            LivenessChallenge.BLINK -&gt; faceDetectorHelper.verifyBlink(face)&#10;            LivenessChallenge.SMILE -&gt; faceDetectorHelper.verifySmile(face)&#10;        }&#10;&#10;        if (isLivenessDetected) {&#10;            _uiState.value = _uiState.value.copy(&#10;                livenessState = LivenessState.LIVENESS_DETECTED,&#10;                instructionText = &quot;Liveness terdeteksi! Tetap di posisi...&quot;&#10;            )&#10;&#10;            // Tahan deteksi sebentar untuk stabilitas, lalu lanjut verifikasi&#10;            livenessJob?.cancel()&#10;            livenessJob = viewModelScope.launch {&#10;                delay(LIVENESS_HOLD_DURATION)&#10;                proceedWithFaceVerification()&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Lanjutkan dengan verifikasi wajah setelah liveness terkonfirmasi&#10;     */&#10;    private fun proceedWithFaceVerification() {&#10;        val face = currentDetectedFace&#10;        val bitmap = currentImageBitmap&#10;&#10;        if (face == null || bitmap == null) {&#10;            handleVerificationError(&quot;Gagal mengambil data wajah&quot;)&#10;            return&#10;        }&#10;&#10;        _uiState.value = _uiState.value.copy(&#10;            livenessState = LivenessState.VERIFYING_FACE,&#10;            isProcessing = true,&#10;            instructionText = &quot;Memverifikasi identitas Anda...&quot;,&#10;            showCountdown = false&#10;        )&#10;&#10;        viewModelScope.launch {&#10;            try {&#10;                // DEBUG: Log bitmap info sebelum ekstraksi&#10;                println(&quot;DEBUG: Original bitmap size: ${bitmap.width}x${bitmap.height}&quot;)&#10;                println(&quot;DEBUG: Face bounding box: ${face.boundingBox}&quot;)&#10;                &#10;                // Ekstrak bitmap wajah dari gambar penuh&#10;                val faceBitmap = faceDetectorHelper.extractFaceBitmap(face, bitmap)&#10;&#10;                if (faceBitmap == null) {&#10;                    handleVerificationError(&quot;Gagal mengekstrak wajah dari gambar&quot;)&#10;                    return@launch&#10;                }&#10;&#10;                // DEBUG: Log face bitmap info setelah ekstraksi&#10;                println(&quot;DEBUG: Extracted face bitmap size: ${faceBitmap.width}x${faceBitmap.height}&quot;)&#10;                &#10;                // Verifikasi wajah menggunakan VerifyFaceUseCase&#10;                println(&quot;DEBUG: Starting face verification...&quot;)&#10;                verifyFaceUseCase(faceBitmap)&#10;                    .onSuccess { isMatch -&gt;&#10;                        println(&quot;DEBUG: Face verification completed. Match: $isMatch&quot;)&#10;                        if (isMatch) {&#10;                            handleVerificationSuccess()&#10;                        } else {&#10;                            handleVerificationError(&quot;Wajah tidak cocok dengan data yang tersimpan. Silakan coba lagi.&quot;)&#10;                        }&#10;                    }&#10;                    .onFailure { exception -&gt;&#10;                        println(&quot;DEBUG: Face verification failed with exception: ${exception.message}&quot;)&#10;                        handleVerificationError(&#10;                            exception.message ?: &quot;Gagal memverifikasi wajah. Silakan coba lagi.&quot;&#10;                        )&#10;                    }&#10;&#10;            } catch (e: Exception) {&#10;                println(&quot;DEBUG: Exception in proceedWithFaceVerification: ${e.message}&quot;)&#10;                handleVerificationError(&quot;Terjadi kesalahan: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Handle sukses verifikasi wajah&#10;     */&#10;    private fun handleVerificationSuccess() {&#10;        timeoutJob?.cancel()&#10;        livenessJob?.cancel()&#10;&#10;        _uiState.value = _uiState.value.copy(&#10;            livenessState = LivenessState.SUCCESS,&#10;            isProcessing = false,&#10;            instructionText = &quot;Verifikasi berhasil! Identitas terkonfirmasi.&quot;,&#10;            progress = 1f,&#10;            showCountdown = false,&#10;            errorMessage = null&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Handle error deteksi wajah&#10;     */&#10;    private fun handleFaceDetectionError(errorMessage: String) {&#10;        // Hanya update instruction jika masih dalam tahap deteksi&#10;        if (_uiState.value.livenessState == LivenessState.DETECTING_FACE) {&#10;            _uiState.value = _uiState.value.copy(&#10;                instructionText = &quot;Mencari wajah... Pastikan wajah terlihat jelas di dalam frame&quot;,&#10;                boundingBox = null&#10;            )&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Handle error verifikasi wajah&#10;     */&#10;    private fun handleVerificationError(errorMessage: String) {&#10;        timeoutJob?.cancel()&#10;        livenessJob?.cancel()&#10;&#10;        _uiState.value = _uiState.value.copy(&#10;            livenessState = LivenessState.FAILURE,&#10;            isProcessing = false,&#10;            instructionText = &quot;Verifikasi gagal&quot;,&#10;            errorMessage = errorMessage,&#10;            showCountdown = false&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Mulai countdown timer untuk timeout&#10;     */&#10;    private fun startTimeout() {&#10;        timeoutJob?.cancel()&#10;        timeoutJob = viewModelScope.launch {&#10;            repeat(TIMEOUT_SECONDS) { second -&gt;&#10;                val remainingTime = TIMEOUT_SECONDS - second&#10;                _uiState.value = _uiState.value.copy(&#10;                    timeRemaining = remainingTime,&#10;                    progress = second.toFloat() / TIMEOUT_SECONDS&#10;                )&#10;                delay(1000)&#10;&#10;                // Cek apakah proses sudah selesai&#10;                if (_uiState.value.livenessState == LivenessState.SUCCESS ||&#10;                    _uiState.value.livenessState == LivenessState.FAILURE&#10;                ) {&#10;                    return@launch&#10;                }&#10;            }&#10;&#10;            // Timeout tercapai&#10;            handleTimeout()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Handle timeout&#10;     */&#10;    private fun handleTimeout() {&#10;        livenessJob?.cancel()&#10;&#10;        _uiState.value = _uiState.value.copy(&#10;            livenessState = LivenessState.TIMEOUT,&#10;            isProcessing = false,&#10;            instructionText = &quot;Waktu habis&quot;,&#10;            errorMessage = &quot;Tidak dapat mendeteksi wajah dalam waktu $TIMEOUT_SECONDS detik. Silakan coba lagi.&quot;,&#10;            showCountdown = false,&#10;            timeRemaining = 0&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Reset scanner untuk mencoba lagi&#10;     */&#10;    fun resetScanner() {&#10;        timeoutJob?.cancel()&#10;        livenessJob?.cancel()&#10;        currentDetectedFace = null&#10;        currentImageBitmap = null&#10;&#10;        initializeScanner()&#10;    }&#10;&#10;    /**&#10;     * Bersihkan resources ketika ViewModel dihancurkan&#10;     */&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        timeoutJob?.cancel()&#10;        livenessJob?.cancel()&#10;        faceDetectorHelper.release()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>