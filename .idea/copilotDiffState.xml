<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/data/repository/attendance/AttendanceRepositoryImpl.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/data/repository/attendance/AttendanceRepositoryImpl.kt" />
              <option name="originalContent" value="package com.example.infinite_track.data.repository.attendance&#10;&#10;import android.util.Log&#10;import com.example.infinite_track.data.mapper.attendance.toActiveSession&#10;import com.example.infinite_track.data.mapper.attendance.toDomain&#10;import com.example.infinite_track.data.mapper.attendance.toDto&#10;import com.example.infinite_track.data.soucre.local.preferences.AttendancePreference&#10;import com.example.infinite_track.data.soucre.network.request.CheckOutRequestDto&#10;import com.example.infinite_track.data.soucre.network.request.LocationEventRequest&#10;import com.example.infinite_track.data.soucre.network.retrofit.ApiService&#10;import com.example.infinite_track.domain.model.attendance.ActiveAttendanceSession&#10;import com.example.infinite_track.domain.model.attendance.AttendanceRequestModel&#10;import com.example.infinite_track.domain.model.attendance.TodayStatus&#10;import com.example.infinite_track.domain.repository.AttendanceRepository&#10;import kotlinx.coroutines.flow.first&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class AttendanceRepositoryImpl @Inject constructor(&#10;    private val apiService: ApiService,&#10;    private val attendancePreference: AttendancePreference&#10;) : AttendanceRepository {&#10;&#10;    companion object {&#10;        private const val TAG = &quot;AttendanceRepository&quot;&#10;    }&#10;&#10;    /**&#10;     * Gets the current day's attendance status&#10;     */&#10;    override suspend fun getTodayStatus(): Result&lt;TodayStatus&gt; {&#10;        return try {&#10;            val response = apiService.getTodayStatus()&#10;            if (response.success) {&#10;                // Convert DTO to domain model using mapper&#10;                Result.success(response.data.toDomain())&#10;            } else {&#10;                Result.failure(Exception(response.message ?: &quot;Unknown error&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error getting today's status&quot;, e)&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Performs check-in operation - simplified without client-side location validation&#10;     * Backend will handle all location validation&#10;     */&#10;    override suspend fun checkIn(request: AttendanceRequestModel): Result&lt;ActiveAttendanceSession&gt; {&#10;        return try {&#10;            // Convert domain model to DTO using mapper&#10;            val requestDto = request.toDto()&#10;&#10;            // Call API for check-in - backend handles location validation&#10;            val response = apiService.checkIn(requestDto)&#10;&#10;            if (response.success) {&#10;                // Save the attendance ID for later checkout&#10;                attendancePreference.saveActiveAttendanceId(response.data.idAttendance)&#10;                Log.d(&#10;                    TAG,&#10;                    &quot;Check-in successful, saved attendance ID: ${response.data.idAttendance}&quot;&#10;                )&#10;&#10;                // Convert DTO to ActiveAttendanceSession domain model using mapper&#10;                Result.success(response.data.toActiveSession())&#10;            } else {&#10;                Result.failure(Exception(response.message))&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error during check-in&quot;, e)&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Performs check-out operation with attendanceId and coordinates&#10;     * Backend will handle location validation for checkout&#10;     */&#10;    override suspend fun checkOut(&#10;        attendanceId: Int,&#10;        latitude: Double,&#10;        longitude: Double&#10;    ): Result&lt;ActiveAttendanceSession&gt; {&#10;        return try {&#10;            // Create checkout request DTO with coordinates&#10;            val checkOutRequestDto = CheckOutRequestDto(&#10;                latitude = latitude,&#10;                longitude = longitude&#10;            )&#10;&#10;            // Call API for check-out with attendanceId in URL and coordinates in body&#10;            val response = apiService.checkOut(attendanceId, checkOutRequestDto)&#10;&#10;            if (response.success) {&#10;                // Clear the active attendance ID&#10;                attendancePreference.clearActiveAttendanceId()&#10;                Log.d(TAG, &quot;Check-out successful, cleared attendance ID&quot;)&#10;&#10;                // Convert DTO to ActiveAttendanceSession domain model using mapper&#10;                Result.success(response.data.toActiveSession())&#10;            } else {&#10;                Result.failure(Exception(response.message))&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error during check-out&quot;, e)&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Retrieves the active attendance ID from preferences&#10;     */&#10;    override suspend fun getActiveAttendanceId(): Int? {&#10;        return try {&#10;            attendancePreference.getActiveAttendanceId().first()&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error getting active attendance ID&quot;, e)&#10;            null&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Sends location event (ENTER/EXIT) to backend&#10;     */&#10;    override suspend fun sendLocationEvent(request: LocationEventRequest): Result&lt;Unit&gt; {&#10;        return try {&#10;            val response = apiService.sendLocationEvent(request)&#10;            if (response.isSuccessful) {&#10;                Log.d(TAG, &quot;Location event sent successfully: ${request.eventType}&quot;)&#10;                Result.success(Unit)&#10;            } else {&#10;                Result.failure(Exception(&quot;Failed to send location event: ${response.code()} ${response.message()}&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error sending location event&quot;, e)&#10;            Result.failure(e)&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.infinite_track.data.repository.attendance&#10;&#10;import android.util.Log&#10;import com.example.infinite_track.data.mapper.attendance.toActiveSession&#10;import com.example.infinite_track.data.mapper.attendance.toDomain&#10;import com.example.infinite_track.data.mapper.attendance.toDto&#10;import com.example.infinite_track.data.soucre.local.preferences.AttendancePreference&#10;import com.example.infinite_track.data.soucre.network.request.CheckOutRequestDto&#10;import com.example.infinite_track.data.soucre.network.request.LocationEventRequest&#10;import com.example.infinite_track.data.soucre.network.retrofit.ApiService&#10;import com.example.infinite_track.domain.model.attendance.ActiveAttendanceSession&#10;import com.example.infinite_track.domain.model.attendance.AttendanceRequestModel&#10;import com.example.infinite_track.domain.model.attendance.TodayStatus&#10;import com.example.infinite_track.domain.repository.AttendanceRepository&#10;import kotlinx.coroutines.flow.first&#10;import org.json.JSONObject&#10;import retrofit2.HttpException&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class AttendanceRepositoryImpl @Inject constructor(&#10;    private val apiService: ApiService,&#10;    private val attendancePreference: AttendancePreference&#10;) : AttendanceRepository {&#10;&#10;    companion object {&#10;        private const val TAG = &quot;AttendanceRepository&quot;&#10;    }&#10;&#10;    /**&#10;     * Extract error message from HTTP response body&#10;     */&#10;    private fun extractErrorMessage(exception: HttpException): String {&#10;        return try {&#10;            val errorBody = exception.response()?.errorBody()?.string()&#10;            if (!errorBody.isNullOrEmpty()) {&#10;                val jsonObject = JSONObject(errorBody)&#10;                val message = jsonObject.optString(&quot;message&quot;, &quot;&quot;)&#10;                if (message.isNotEmpty()) {&#10;                    Log.d(TAG, &quot;Extracted error message: $message&quot;)&#10;                    return message&#10;                }&#10;            }&#10;            // Fallback to HTTP status message&#10;            &quot;HTTP ${exception.code()} ${exception.message()}&quot;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Failed to extract error message&quot;, e)&#10;            &quot;HTTP ${exception.code()} ${exception.message()}&quot;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Gets the current day's attendance status&#10;     */&#10;    override suspend fun getTodayStatus(): Result&lt;TodayStatus&gt; {&#10;        return try {&#10;            val response = apiService.getTodayStatus()&#10;            if (response.success) {&#10;                // Convert DTO to domain model using mapper&#10;                Result.success(response.data.toDomain())&#10;            } else {&#10;                Result.failure(Exception(response.message ?: &quot;Unknown error&quot;))&#10;            }&#10;        } catch (e: HttpException) {&#10;            Log.e(TAG, &quot;HTTP Error getting today's status&quot;, e)&#10;            val errorMessage = extractErrorMessage(e)&#10;            Result.failure(Exception(errorMessage))&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error getting today's status&quot;, e)&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Performs check-in operation - simplified without client-side location validation&#10;     * Backend will handle all location validation&#10;     */&#10;    override suspend fun checkIn(request: AttendanceRequestModel): Result&lt;ActiveAttendanceSession&gt; {&#10;        return try {&#10;            // Convert domain model to DTO using mapper&#10;            val requestDto = request.toDto()&#10;&#10;            // Call API for check-in - backend handles location validation&#10;            val response = apiService.checkIn(requestDto)&#10;&#10;            if (response.success) {&#10;                // Save the attendance ID for later checkout&#10;                attendancePreference.saveActiveAttendanceId(response.data.idAttendance)&#10;                Log.d(&#10;                    TAG,&#10;                    &quot;Check-in successful, saved attendance ID: ${response.data.idAttendance}&quot;&#10;                )&#10;&#10;                // Convert DTO to ActiveAttendanceSession domain model using mapper&#10;                Result.success(response.data.toActiveSession())&#10;            } else {&#10;                Result.failure(Exception(response.message))&#10;            }&#10;        } catch (e: HttpException) {&#10;            Log.e(TAG, &quot;HTTP Error during check-in&quot;, e)&#10;            val errorMessage = extractErrorMessage(e)&#10;            Result.failure(Exception(errorMessage))&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error during check-in&quot;, e)&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Performs check-out operation with attendanceId and coordinates&#10;     * Backend will handle location validation for checkout&#10;     */&#10;    override suspend fun checkOut(&#10;        attendanceId: Int,&#10;        latitude: Double,&#10;        longitude: Double&#10;    ): Result&lt;ActiveAttendanceSession&gt; {&#10;        return try {&#10;            // Create checkout request DTO with coordinates&#10;            val checkOutRequestDto = CheckOutRequestDto(&#10;                latitude = latitude,&#10;                longitude = longitude&#10;            )&#10;&#10;            // Call API for check-out with attendanceId in URL and coordinates in body&#10;            val response = apiService.checkOut(attendanceId, checkOutRequestDto)&#10;&#10;            if (response.success) {&#10;                // Clear the active attendance ID&#10;                attendancePreference.clearActiveAttendanceId()&#10;                Log.d(TAG, &quot;Check-out successful, cleared attendance ID&quot;)&#10;&#10;                // Convert DTO to ActiveAttendanceSession domain model using mapper&#10;                Result.success(response.data.toActiveSession())&#10;            } else {&#10;                Result.failure(Exception(response.message))&#10;            }&#10;        } catch (e: HttpException) {&#10;            Log.e(TAG, &quot;HTTP Error during check-out&quot;, e)&#10;            val errorMessage = extractErrorMessage(e)&#10;            Result.failure(Exception(errorMessage))&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error during check-out&quot;, e)&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Retrieves the active attendance ID from preferences&#10;     */&#10;    override suspend fun getActiveAttendanceId(): Int? {&#10;        return try {&#10;            attendancePreference.getActiveAttendanceId().first()&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error getting active attendance ID&quot;, e)&#10;            null&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Sends location event (ENTER/EXIT) to backend&#10;     */&#10;    override suspend fun sendLocationEvent(request: LocationEventRequest): Result&lt;Unit&gt; {&#10;        return try {&#10;            val response = apiService.sendLocationEvent(request)&#10;            if (response.isSuccessful) {&#10;                Log.d(TAG, &quot;Location event sent successfully: ${request.eventType}&quot;)&#10;                Result.success(Unit)&#10;            } else {&#10;                Result.failure(Exception(&quot;Failed to send location event: ${response.code()} ${response.message()}&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error sending location event&quot;, e)&#10;            Result.failure(e)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/presentation/screen/attendance/AttendanceScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/presentation/screen/attendance/AttendanceScreen.kt" />
              <option name="originalContent" value="package com.example.infinite_track.presentation.screen.attendance&#10;&#10;import androidx.compose.animation.AnimatedVisibility&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.statusBarsPadding&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.LocationOn&#10;import androidx.compose.material3.BottomSheetScaffold&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.rememberBottomSheetScaffoldState&#10;import androidx.compose.material3.rememberStandardBottomSheetState&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.blur&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import androidx.navigation.NavController&#10;import com.example.infinite_track.R&#10;import com.example.infinite_track.domain.model.attendance.TargetLocationInfo&#10;import com.example.infinite_track.domain.model.location.LocationResult&#10;import com.example.infinite_track.domain.model.wfa.WfaRecommendation&#10;import com.example.infinite_track.presentation.components.button.attendance.AttendanceBottomSheetContent&#10;import com.example.infinite_track.presentation.components.empty.ErrorAnimation&#10;import com.example.infinite_track.presentation.components.loading.LoadingAnimation&#10;import com.example.infinite_track.presentation.components.maps.AttendanceMap&#10;import com.example.infinite_track.presentation.components.maps.MarkerView&#10;import com.example.infinite_track.presentation.components.maps.MarkerViewWfa&#10;import com.example.infinite_track.presentation.navigation.Screen&#10;import com.example.infinite_track.presentation.screen.attendance.components.AttendanceTopBar&#10;import com.example.infinite_track.presentation.theme.Infinite_TrackTheme&#10;import com.example.infinite_track.utils.DialogHelper&#10;import com.example.infinite_track.utils.UiState&#10;import com.mapbox.geojson.Point&#10;import com.mapbox.maps.CameraOptions&#10;import com.mapbox.maps.MapView&#10;import com.mapbox.maps.MapboxDelicateApi&#10;import com.mapbox.maps.plugin.animation.MapAnimationOptions&#10;import com.mapbox.maps.plugin.animation.flyTo&#10;&#10;@OptIn(ExperimentalMaterial3Api::class, MapboxDelicateApi::class)&#10;@Composable&#10;fun AttendanceScreen(&#10;    navController: NavController,&#10;    viewModel: AttendanceViewModel = hiltViewModel()&#10;) {&#10;    var mapViewInstance by remember { mutableStateOf&lt;MapView?&gt;(null) }&#10;&#10;    // Observasi state dari ViewModel yang sudah disederhanakan&#10;    val uiState by viewModel.uiState.collectAsStateWithLifecycle()&#10;&#10;    // Handle hasil pencarian lokasi dari LocationSearchScreen&#10;    val selectedLocation = navController.currentBackStackEntry&#10;        ?.savedStateHandle&#10;        ?.get&lt;LocationResult&gt;(&quot;selected_location&quot;)&#10;&#10;    // Process hasil pencarian lokasi&#10;    LaunchedEffect(selectedLocation) {&#10;        selectedLocation?.let { location -&gt;&#10;            // Kirim lokasi terpilih ke ViewModel untuk diproses&#10;            viewModel.onLocationSelected(location)&#10;            // Hapus state agar tidak diproses lagi saat re-komposisi&#10;            navController.currentBackStackEntry&#10;                ?.savedStateHandle&#10;                ?.remove&lt;LocationResult&gt;(&quot;selected_location&quot;)&#10;        }&#10;    }&#10;&#10;    // BottomSheet state&#10;    val bottomSheetState = rememberStandardBottomSheetState(&#10;        skipHiddenState = false&#10;    )&#10;    val scaffoldState = rememberBottomSheetScaffoldState(&#10;        bottomSheetState = bottomSheetState&#10;    )&#10;&#10;    // =======================================================&#10;    // NEW: State-driven LaunchedEffect for Navigation&#10;    // =======================================================&#10;    LaunchedEffect(uiState.navigationTarget) {&#10;        uiState.navigationTarget?.let { target -&gt;&#10;            when (target) {&#10;                is NavigationTarget.FaceScanner -&gt; {&#10;                    val action = if (target.isCheckIn) &quot;checkin&quot; else &quot;checkout&quot;&#10;                    val route = Screen.FaceScanner.createRoute(action)&#10;                    navController.navigate(route)&#10;                    android.util.Log.d(&#10;                        &quot;AttendanceScreen&quot;,&#10;                        &quot;Navigating to face scanner for $action&quot;&#10;                    )&#10;                }&#10;                is NavigationTarget.WfaBooking -&gt; {&#10;                    navController.navigate(target.route)&#10;                    android.util.Log.d(&#10;                        &quot;AttendanceScreen&quot;,&#10;                        &quot;Navigating to WFA booking screen with route: ${target.route}&quot;&#10;                    )&#10;                }&#10;                is NavigationTarget.LocationSearch -&gt; {&#10;                    navController.navigate(target.params)&#10;                    android.util.Log.d(&#10;                        &quot;AttendanceScreen&quot;,&#10;                        &quot;Navigating to location search with params: ${target.params}&quot;&#10;                    )&#10;                }&#10;            }&#10;            // Notify ViewModel that navigation has been handled&#10;            viewModel.onNavigationHandled()&#10;        }&#10;    }&#10;&#10;    // =======================================================&#10;    // NEW: State-driven LaunchedEffect for Map Animation&#10;    // =======================================================&#10;    LaunchedEffect(uiState.mapAnimationTarget) {&#10;        uiState.mapAnimationTarget?.let { animationTarget -&gt;&#10;            when (animationTarget) {&#10;                is MapAnimationTarget.AnimateToLocation -&gt; {&#10;                    mapViewInstance?.let { mapView -&gt;&#10;                        val cameraOptions = CameraOptions.Builder()&#10;                            .center(animationTarget.point)&#10;                            .zoom(animationTarget.zoomLevel)&#10;                            .pitch(0.0)&#10;                            .bearing(0.0)&#10;                            .build()&#10;&#10;                        mapView.mapboxMap.flyTo(&#10;                            cameraOptions,&#10;                            MapAnimationOptions.Builder()&#10;                                .duration(1200L)&#10;                                .build()&#10;                        )&#10;&#10;                        android.util.Log.d(&#10;                            &quot;AttendanceScreen&quot;,&#10;                            &quot;Camera animated to ${animationTarget.point.latitude()}, ${animationTarget.point.longitude()} with zoom ${animationTarget.zoomLevel}&quot;&#10;                        )&#10;                    }&#10;                }&#10;&#10;                is MapAnimationTarget.AnimateToFitBounds -&gt; {&#10;                    mapViewInstance?.let { mapView -&gt;&#10;                        if (animationTarget.points.isNotEmpty()) {&#10;                            val cameraOptions = mapView.mapboxMap.cameraForCoordinates(&#10;                                coordinates = animationTarget.points,&#10;                                camera = CameraOptions.Builder().build(),&#10;                                coordinatesPadding = com.mapbox.maps.EdgeInsets(&#10;                                    50.0,&#10;                                    50.0,&#10;                                    50.0,&#10;                                    50.0&#10;                                ),&#10;                                maxZoom = null,&#10;                                offset = null&#10;                            )&#10;&#10;                            mapView.mapboxMap.flyTo(&#10;                                cameraOptions,&#10;                                MapAnimationOptions.Builder()&#10;                                    .duration(1500L)&#10;                                    .build()&#10;                            )&#10;&#10;                            android.util.Log.d(&#10;                                &quot;AttendanceScreen&quot;,&#10;                                &quot;Camera animated to fit ${animationTarget.points.size} WFA locations&quot;&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;&#10;                is MapAnimationTarget.ShowLocationError -&gt; {&#10;                    android.util.Log.e(&#10;                        &quot;AttendanceScreen&quot;,&#10;                        &quot;Failed to get current location for focus&quot;&#10;                    )&#10;                    // Could show a Toast or Snackbar here&#10;                }&#10;            }&#10;            // Notify ViewModel that map animation has been handled&#10;            viewModel.onMapAnimationHandled()&#10;        }&#10;    }&#10;&#10;    // Start location updates when UI is ready and data is loaded successfully&#10;    LaunchedEffect(uiState.uiState) {&#10;        if (uiState.uiState is UiState.Success) {&#10;            // Only start location updates after data is loaded and UI is ready&#10;            viewModel.startLocationUpdates()&#10;            android.util.Log.d(&quot;AttendanceScreen&quot;, &quot;Location updates started after UI ready&quot;)&#10;        }&#10;    }&#10;&#10;    // Penanganan state utama berdasarkan UiState dengan smart cast fix&#10;    when (val currentUiState = uiState.uiState) {&#10;        is UiState.Idle -&gt; {&#10;            // Initial idle state - could show a splash or continue to loading&#10;            Box(&#10;                modifier = Modifier.fillMaxSize(),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                LoadingAnimation()&#10;            }&#10;        }&#10;&#10;        is UiState.Loading -&gt; {&#10;            // Tampilkan loading animation&#10;            Box(&#10;                modifier = Modifier.fillMaxSize(),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                LoadingAnimation()&#10;            }&#10;        }&#10;&#10;        is UiState.Error -&gt; {&#10;            Box(&#10;                modifier = Modifier.fillMaxSize(),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Column(&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    ErrorAnimation()&#10;                    Text(&#10;                        text = currentUiState.errorMessage,&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        color = MaterialTheme.colorScheme.error,&#10;                        textAlign = TextAlign.Center,&#10;                        modifier = Modifier.padding(16.dp)&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        is UiState.Success -&gt; {&#10;            // Tampilkan konten utama dengan BottomSheet&#10;            BottomSheetScaffold(&#10;                scaffoldState = scaffoldState,&#10;                containerColor = Color.Black.copy(alpha = 0.1f),&#10;                contentColor = Color.Transparent,&#10;                sheetContainerColor = Color.Transparent,&#10;                sheetContentColor = Color.Unspecified,&#10;                sheetShape = RoundedCornerShape(topStart = 24.dp, topEnd = 24.dp),&#10;                sheetPeekHeight = 120.dp,&#10;                sheetDragHandle = null,&#10;                sheetContent = {&#10;                    // Enhanced Liquid Glass Background Container&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .clip(RoundedCornerShape(topStart = 24.dp, topEnd = 24.dp))&#10;                            .background(&#10;                                brush = Brush.linearGradient(&#10;                                    colors = listOf(&#10;                                        Color.White.copy(alpha = 0.98f),&#10;                                        Color.White.copy(alpha = 0.95f),&#10;                                        Color(0xFFE3F2FD).copy(alpha = 0.92f),&#10;                                        Color(0xFFBBDEFB).copy(alpha = 0.88f)&#10;                                    )&#10;                                )&#10;                            )&#10;                    ) {&#10;                        // Glass effect overlays&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .matchParentSize()&#10;                                .background(&#10;                                    brush = Brush.radialGradient(&#10;                                        colors = listOf(&#10;                                            Color.White.copy(alpha = 0.6f),&#10;                                            Color.Transparent,&#10;                                            Color(0xFF81D4FA).copy(alpha = 0.3f)&#10;                                        ),&#10;                                        radius = 1000f&#10;                                    )&#10;                                )&#10;                                .blur(2.dp)&#10;                        )&#10;&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .matchParentSize()&#10;                                .background(&#10;                                    brush = Brush.linearGradient(&#10;                                        colors = listOf(&#10;                                            Color.Transparent,&#10;                                            Color.White.copy(alpha = 0.4f),&#10;                                            Color.Transparent&#10;                                        )&#10;                                    )&#10;                                )&#10;                        )&#10;&#10;                        // Content with drag handle&#10;                        Column(modifier = Modifier.fillMaxWidth()) {&#10;                            // Custom drag handle&#10;                            Box(&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .padding(top = 12.dp, bottom = 8.dp),&#10;                                contentAlignment = Alignment.Center&#10;                            ) {&#10;                                Box(&#10;                                    modifier = Modifier&#10;                                        .width(40.dp)&#10;                                        .height(4.dp)&#10;                                        .clip(RoundedCornerShape(2.dp))&#10;                                        .background(Color.Gray.copy(alpha = 0.3f))&#10;                                )&#10;                            }&#10;&#10;                            AttendanceBottomSheetContent(&#10;                                modifier = Modifier.padding(top = 0.dp),&#10;                                targetLocationInfo = uiState.targetLocation?.let { target -&gt;&#10;                                    TargetLocationInfo(&#10;                                        description = target.description,&#10;                                        locationName = target.category&#10;                                    )&#10;                                },&#10;                                currentLocationAddress = uiState.currentUserAddress.ifEmpty { &quot;Mengambil lokasi saat ini...&quot; },&#10;                                selectedWorkMode = uiState.selectedWorkMode,&#10;                                isBookingEnabled = uiState.isBookingEnabled,&#10;                                isCheckInEnabled = uiState.isButtonEnabled, // Use isButtonEnabled from uiState&#10;                                checkInButtonText = uiState.buttonText,&#10;                                onSearchLocationClick = {&#10;                                    navController.navigate(&quot;location_search&quot;)&#10;                                },&#10;                                onModeSelected = { mode -&gt; viewModel.onWorkModeSelected(mode) },&#10;                                onBookingClick = { viewModel.onBookingClicked() },&#10;                                onCheckInClick = { viewModel.onAttendanceButtonClicked() }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            ) { _ -&gt; // Renamed paddingValues to _ to indicate it's intentionally unused&#10;                Box(modifier = Modifier.fillMaxSize()) {&#10;                    // Fullscreen Map dengan data dari ViewModel - Updated with WFO, WFH, and WFA locations&#10;                    AttendanceMap(&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        wfoLocation = if (uiState.isWfaModeActive) null else uiState.wfoLocation, // Hide WFO when WFA active&#10;                        wfhLocation = if (uiState.isWfaModeActive) null else uiState.wfhLocation, // Hide WFH when WFA active&#10;                        wfaRecommendations = uiState.wfaRecommendations, // WFA recommendations&#10;                        selectedWfaLocation = uiState.selectedWfaLocation, // Selected WFA location&#10;                        targetLocation = uiState.targetLocationMarker, // Keep for backward compatibility&#10;                        currentUserLocation = uiState.currentUserLatitude?.let { lat -&gt;&#10;                            uiState.currentUserLongitude?.let { lng -&gt;&#10;                                Point.fromLngLat(lng, lat)&#10;                            }&#10;                        },&#10;                        onMarkerClick = { location -&gt; viewModel.onMarkerClicked(location) },&#10;                        onWfaMarkerClick = { recommendation: WfaRecommendation -&gt;&#10;                            viewModel.onWfaMarkerClicked(&#10;                                recommendation&#10;                            )&#10;                        }, // Handle WFA marker clicks&#10;                        onMapReady = { mapView -&gt;&#10;                            mapViewInstance = mapView&#10;                            // Notify ViewModel that map is ready for initial focus&#10;                            viewModel.onMapReady()&#10;                        },&#10;                        onCameraIdle = { point -&gt;&#10;                            viewModel.onMapIdle(point)&#10;                        } // Handle Pick on Map functionality&#10;                    )&#10;&#10;                    // Top bar with location focus button - fixed parameters&#10;                    AttendanceTopBar(&#10;                        modifier = Modifier&#10;                            .statusBarsPadding()&#10;                            .padding(16.dp),&#10;                        onBackClicked = { navController.navigateUp() },&#10;                        onFocusLocationClicked = { viewModel.onFocusLocationClicked() }&#10;                    )&#10;&#10;                    // Pick on Map Crosshair - shows static pin in center when Pick on Map mode is active&#10;                    AnimatedVisibility(&#10;                        visible = uiState.isPickOnMapModeActive,&#10;                        modifier = Modifier.align(Alignment.Center)&#10;                    ) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.LocationOn,&#10;                            contentDescription = &quot;Pick Location&quot;,&#10;                            tint = Color.Red,&#10;                            modifier = Modifier.size(32.dp)&#10;                        )&#10;                    }&#10;&#10;                    uiState.selectedMarkerInfo?.let { selectedMarker -&gt;&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .fillMaxSize()&#10;                                .padding(top = 80.dp),&#10;                            contentAlignment = Alignment.TopCenter&#10;                        ) {&#10;                            MarkerView(&#10;                                title = selectedMarker.description,&#10;                                description = &quot;Kategori: ${selectedMarker.category}&quot;,&#10;                                radius = &quot;${selectedMarker.radius} meter&quot;,&#10;                                coordinates = &quot;${selectedMarker.latitude}, ${selectedMarker.longitude}&quot;,&#10;                                onClose = { viewModel.onDismissMarkerInfo() }&#10;                            )&#10;                        }&#10;                    }&#10;&#10;                    // Display WFA marker details when clicked&#10;                    uiState.selectedWfaMarkerInfo?.let { selectedWfaMarker -&gt;&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .fillMaxSize()&#10;                                .padding(top = 80.dp, start = 16.dp, end = 16.dp),&#10;                            contentAlignment = Alignment.TopCenter&#10;                        ) {&#10;                            MarkerViewWfa(&#10;                                recommendation = selectedWfaMarker,&#10;                                onClick = { viewModel.onDismissWfaMarkerInfo() }&#10;                            )&#10;                        }&#10;                    }&#10;&#10;                    // Loading overlay for WFA recommendations&#10;                    if (uiState.isLoadingWfaRecommendations) {&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .fillMaxSize()&#10;                                .background(Color.Black.copy(alpha = 0.3f)),&#10;                            contentAlignment = Alignment.Center&#10;                        ) {&#10;                            LoadingAnimation()&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // =======================================================&#10;    // NEW: State-driven LaunchedEffect for Dialog Handling&#10;    // =======================================================&#10;    LaunchedEffect(uiState.activeDialog) {&#10;        uiState.activeDialog?.let { dialog -&gt;&#10;            when (dialog) {&#10;                is DialogState.Success -&gt; {&#10;                    // Show success dialog with dynamic message from server&#10;                    DialogHelper.showDialogSuccess(&#10;                        context = navController.context,&#10;                        title = &quot;Absensi Berhasil&quot;,&#10;                        textContent = dialog.message,&#10;                        imageRes = R.drawable.icon_success,&#10;                        onConfirm = {&#10;                            // Navigate to HomeScreen after success&#10;                            navController.navigate(Screen.Home.route) {&#10;                                // Clear backstack to prevent going back to attendance&#10;                                popUpTo(Screen.Home.route) {&#10;                                    inclusive = false&#10;                                }&#10;                            }&#10;                            // Notify ViewModel that dialog has been handled&#10;                            viewModel.onDialogDismissed()&#10;                        }&#10;                    )&#10;                }&#10;&#10;                is DialogState.Error -&gt; {&#10;                    // Show error dialog with dynamic message from server&#10;                    DialogHelper.showDialogError(&#10;                        context = navController.context,&#10;                        title = &quot;Absensi Gagal&quot;,&#10;                        textContent = dialog.message,&#10;                        onConfirm = {&#10;                            // Stay on AttendanceScreen - no navigation needed&#10;                            // User can try again&#10;                            viewModel.onDialogDismissed()&#10;                        }&#10;                    )&#10;                }&#10;&#10;                is DialogState.LocationError -&gt; {&#10;                    // Show location error dialog&#10;                    DialogHelper.showDialogError(&#10;                        context = navController.context,&#10;                        title = &quot;Error Lokasi&quot;,&#10;                        textContent = dialog.message,&#10;                        onConfirm = {&#10;                            viewModel.onDialogDismissed()&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Handle face verification result from FaceScannerScreen&#10;    LaunchedEffect(Unit) {&#10;        // Get face verification result from savedStateHandle&#10;        val faceVerificationResult = navController.currentBackStackEntry&#10;            ?.savedStateHandle&#10;            ?.getLiveData&lt;Boolean&gt;(&quot;face_verification_result&quot;)&#10;&#10;        faceVerificationResult?.observeForever { isSuccess -&gt;&#10;            if (isSuccess != null) {&#10;                // FIXED: Only process if verification was successful&#10;                // If failed, user should stay on FaceScannerScreen for retry&#10;                if (isSuccess) {&#10;                    // Call ViewModel to handle the successful result&#10;                    viewModel.onFaceVerificationResult(isSuccess)&#10;                } else {&#10;                    // Face verification failed - don't process, let user retry on scanner screen&#10;                    android.util.Log.d(&#10;                        &quot;AttendanceScreen&quot;,&#10;                        &quot;Face verification failed - user should retry on scanner screen&quot;&#10;                    )&#10;                }&#10;&#10;                // Clear the result to prevent re-processing&#10;                navController.currentBackStackEntry&#10;                    ?.savedStateHandle&#10;                    ?.remove&lt;Boolean&gt;(&quot;face_verification_result&quot;)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun AttendanceScreenPreview() {&#10;    Infinite_TrackTheme {&#10;        Box(modifier = Modifier.fillMaxSize()) {&#10;            AttendanceMap(&#10;                modifier = Modifier.fillMaxSize(),&#10;                onMapReady = { }&#10;            )&#10;            AttendanceTopBar(&#10;                modifier = Modifier&#10;                    .align(Alignment.TopCenter)&#10;                    .statusBarsPadding()&#10;                    .padding(horizontal = 20.dp),&#10;                onBackClicked = { },&#10;                onFocusLocationClicked = { }&#10;            )&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.infinite_track.presentation.screen.attendance&#10;&#10;import androidx.compose.animation.AnimatedVisibility&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.statusBarsPadding&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.LocationOn&#10;import androidx.compose.material3.BottomSheetScaffold&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.rememberBottomSheetScaffoldState&#10;import androidx.compose.material3.rememberStandardBottomSheetState&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.blur&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import androidx.navigation.NavController&#10;import com.example.infinite_track.R&#10;import com.example.infinite_track.domain.model.attendance.TargetLocationInfo&#10;import com.example.infinite_track.domain.model.location.LocationResult&#10;import com.example.infinite_track.domain.model.wfa.WfaRecommendation&#10;import com.example.infinite_track.presentation.components.button.attendance.AttendanceBottomSheetContent&#10;import com.example.infinite_track.presentation.components.empty.ErrorAnimation&#10;import com.example.infinite_track.presentation.components.loading.LoadingAnimation&#10;import com.example.infinite_track.presentation.components.maps.AttendanceMap&#10;import com.example.infinite_track.presentation.components.maps.MarkerView&#10;import com.example.infinite_track.presentation.components.maps.MarkerViewWfa&#10;import com.example.infinite_track.presentation.navigation.Screen&#10;import com.example.infinite_track.presentation.screen.attendance.components.AttendanceTopBar&#10;import com.example.infinite_track.presentation.theme.Infinite_TrackTheme&#10;import com.example.infinite_track.utils.DialogHelper&#10;import com.example.infinite_track.utils.UiState&#10;import com.mapbox.geojson.Point&#10;import com.mapbox.maps.CameraOptions&#10;import com.mapbox.maps.MapView&#10;import com.mapbox.maps.MapboxDelicateApi&#10;import com.mapbox.maps.plugin.animation.MapAnimationOptions&#10;import com.mapbox.maps.plugin.animation.flyTo&#10;&#10;@OptIn(ExperimentalMaterial3Api::class, MapboxDelicateApi::class)&#10;@Composable&#10;fun AttendanceScreen(&#10;    navController: NavController,&#10;    viewModel: AttendanceViewModel = hiltViewModel()&#10;) {&#10;    var mapViewInstance by remember { mutableStateOf&lt;MapView?&gt;(null) }&#10;&#10;    // Observasi state dari ViewModel yang sudah disederhanakan&#10;    val uiState by viewModel.uiState.collectAsStateWithLifecycle()&#10;&#10;    // Handle hasil pencarian lokasi dari LocationSearchScreen&#10;    val selectedLocation = navController.currentBackStackEntry&#10;        ?.savedStateHandle&#10;        ?.get&lt;LocationResult&gt;(&quot;selected_location&quot;)&#10;&#10;    // Process hasil pencarian lokasi&#10;    LaunchedEffect(selectedLocation) {&#10;        selectedLocation?.let { location -&gt;&#10;            // Kirim lokasi terpilih ke ViewModel untuk diproses&#10;            viewModel.onLocationSelected(location)&#10;            // Hapus state agar tidak diproses lagi saat re-komposisi&#10;            navController.currentBackStackEntry&#10;                ?.savedStateHandle&#10;                ?.remove&lt;LocationResult&gt;(&quot;selected_location&quot;)&#10;        }&#10;    }&#10;&#10;    // BottomSheet state&#10;    val bottomSheetState = rememberStandardBottomSheetState(&#10;        skipHiddenState = false&#10;    )&#10;    val scaffoldState = rememberBottomSheetScaffoldState(&#10;        bottomSheetState = bottomSheetState&#10;    )&#10;&#10;    // =======================================================&#10;    // NEW: State-driven LaunchedEffect for Navigation&#10;    // =======================================================&#10;    LaunchedEffect(uiState.navigationTarget) {&#10;        uiState.navigationTarget?.let { target -&gt;&#10;            when (target) {&#10;                is NavigationTarget.FaceScanner -&gt; {&#10;                    val action = if (target.isCheckIn) &quot;checkin&quot; else &quot;checkout&quot;&#10;                    val route = Screen.FaceScanner.createRoute(action)&#10;                    navController.navigate(route)&#10;                    android.util.Log.d(&#10;                        &quot;AttendanceScreen&quot;,&#10;                        &quot;Navigating to face scanner for $action&quot;&#10;                    )&#10;                }&#10;                is NavigationTarget.WfaBooking -&gt; {&#10;                    navController.navigate(target.route)&#10;                    android.util.Log.d(&#10;                        &quot;AttendanceScreen&quot;,&#10;                        &quot;Navigating to WFA booking screen with route: ${target.route}&quot;&#10;                    )&#10;                }&#10;                is NavigationTarget.LocationSearch -&gt; {&#10;                    navController.navigate(target.params)&#10;                    android.util.Log.d(&#10;                        &quot;AttendanceScreen&quot;,&#10;                        &quot;Navigating to location search with params: ${target.params}&quot;&#10;                    )&#10;                }&#10;            }&#10;            // Notify ViewModel that navigation has been handled&#10;            viewModel.onNavigationHandled()&#10;        }&#10;    }&#10;&#10;    // =======================================================&#10;    // NEW: State-driven LaunchedEffect for Map Animation&#10;    // =======================================================&#10;    LaunchedEffect(uiState.mapAnimationTarget) {&#10;        uiState.mapAnimationTarget?.let { animationTarget -&gt;&#10;            when (animationTarget) {&#10;                is MapAnimationTarget.AnimateToLocation -&gt; {&#10;                    mapViewInstance?.let { mapView -&gt;&#10;                        val cameraOptions = CameraOptions.Builder()&#10;                            .center(animationTarget.point)&#10;                            .zoom(animationTarget.zoomLevel)&#10;                            .pitch(0.0)&#10;                            .bearing(0.0)&#10;                            .build()&#10;&#10;                        mapView.mapboxMap.flyTo(&#10;                            cameraOptions,&#10;                            MapAnimationOptions.Builder()&#10;                                .duration(1200L)&#10;                                .build()&#10;                        )&#10;&#10;                        android.util.Log.d(&#10;                            &quot;AttendanceScreen&quot;,&#10;                            &quot;Camera animated to ${animationTarget.point.latitude()}, ${animationTarget.point.longitude()} with zoom ${animationTarget.zoomLevel}&quot;&#10;                        )&#10;                    }&#10;                }&#10;&#10;                is MapAnimationTarget.AnimateToFitBounds -&gt; {&#10;                    mapViewInstance?.let { mapView -&gt;&#10;                        if (animationTarget.points.isNotEmpty()) {&#10;                            val cameraOptions = mapView.mapboxMap.cameraForCoordinates(&#10;                                coordinates = animationTarget.points,&#10;                                camera = CameraOptions.Builder().build(),&#10;                                coordinatesPadding = com.mapbox.maps.EdgeInsets(&#10;                                    50.0,&#10;                                    50.0,&#10;                                    50.0,&#10;                                    50.0&#10;                                ),&#10;                                maxZoom = null,&#10;                                offset = null&#10;                            )&#10;&#10;                            mapView.mapboxMap.flyTo(&#10;                                cameraOptions,&#10;                                MapAnimationOptions.Builder()&#10;                                    .duration(1500L)&#10;                                    .build()&#10;                            )&#10;&#10;                            android.util.Log.d(&#10;                                &quot;AttendanceScreen&quot;,&#10;                                &quot;Camera animated to fit ${animationTarget.points.size} WFA locations&quot;&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;&#10;                is MapAnimationTarget.ShowLocationError -&gt; {&#10;                    android.util.Log.e(&#10;                        &quot;AttendanceScreen&quot;,&#10;                        &quot;Failed to get current location for focus&quot;&#10;                    )&#10;                    // Could show a Toast or Snackbar here&#10;                }&#10;            }&#10;            // Notify ViewModel that map animation has been handled&#10;            viewModel.onMapAnimationHandled()&#10;        }&#10;    }&#10;&#10;    // Start location updates when UI is ready and data is loaded successfully&#10;    LaunchedEffect(uiState.uiState) {&#10;        if (uiState.uiState is UiState.Success) {&#10;            // Only start location updates after data is loaded and UI is ready&#10;            viewModel.startLocationUpdates()&#10;            android.util.Log.d(&quot;AttendanceScreen&quot;, &quot;Location updates started after UI ready&quot;)&#10;        }&#10;    }&#10;&#10;    // Penanganan state utama berdasarkan UiState dengan smart cast fix&#10;    when (val currentUiState = uiState.uiState) {&#10;        is UiState.Idle -&gt; {&#10;            // Initial idle state - could show a splash or continue to loading&#10;            Box(&#10;                modifier = Modifier.fillMaxSize(),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                LoadingAnimation()&#10;            }&#10;        }&#10;&#10;        is UiState.Loading -&gt; {&#10;            // Tampilkan loading animation&#10;            Box(&#10;                modifier = Modifier.fillMaxSize(),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                LoadingAnimation()&#10;            }&#10;        }&#10;&#10;        is UiState.Error -&gt; {&#10;            Box(&#10;                modifier = Modifier.fillMaxSize(),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Column(&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    ErrorAnimation()&#10;                    Text(&#10;                        text = currentUiState.errorMessage,&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        color = MaterialTheme.colorScheme.error,&#10;                        textAlign = TextAlign.Center,&#10;                        modifier = Modifier.padding(16.dp)&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        is UiState.Success -&gt; {&#10;            // Tampilkan konten utama dengan BottomSheet&#10;            BottomSheetScaffold(&#10;                scaffoldState = scaffoldState,&#10;                containerColor = Color.Black.copy(alpha = 0.1f),&#10;                contentColor = Color.Transparent,&#10;                sheetContainerColor = Color.Transparent,&#10;                sheetContentColor = Color.Unspecified,&#10;                sheetShape = RoundedCornerShape(topStart = 24.dp, topEnd = 24.dp),&#10;                sheetPeekHeight = 120.dp,&#10;                sheetDragHandle = null,&#10;                sheetContent = {&#10;                    // Enhanced Liquid Glass Background Container&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .clip(RoundedCornerShape(topStart = 24.dp, topEnd = 24.dp))&#10;                            .background(&#10;                                brush = Brush.linearGradient(&#10;                                    colors = listOf(&#10;                                        Color.White.copy(alpha = 0.98f),&#10;                                        Color.White.copy(alpha = 0.95f),&#10;                                        Color(0xFFE3F2FD).copy(alpha = 0.92f),&#10;                                        Color(0xFFBBDEFB).copy(alpha = 0.88f)&#10;                                    )&#10;                                )&#10;                            )&#10;                    ) {&#10;                        // Glass effect overlays&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .matchParentSize()&#10;                                .background(&#10;                                    brush = Brush.radialGradient(&#10;                                        colors = listOf(&#10;                                            Color.White.copy(alpha = 0.6f),&#10;                                            Color.Transparent,&#10;                                            Color(0xFF81D4FA).copy(alpha = 0.3f)&#10;                                        ),&#10;                                        radius = 1000f&#10;                                    )&#10;                                )&#10;                                .blur(2.dp)&#10;                        )&#10;&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .matchParentSize()&#10;                                .background(&#10;                                    brush = Brush.linearGradient(&#10;                                        colors = listOf(&#10;                                            Color.Transparent,&#10;                                            Color.White.copy(alpha = 0.4f),&#10;                                            Color.Transparent&#10;                                        )&#10;                                    )&#10;                                )&#10;                        )&#10;&#10;                        // Content with drag handle&#10;                        Column(modifier = Modifier.fillMaxWidth()) {&#10;                            // Custom drag handle&#10;                            Box(&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .padding(top = 12.dp, bottom = 8.dp),&#10;                                contentAlignment = Alignment.Center&#10;                            ) {&#10;                                Box(&#10;                                    modifier = Modifier&#10;                                        .width(40.dp)&#10;                                        .height(4.dp)&#10;                                        .clip(RoundedCornerShape(2.dp))&#10;                                        .background(Color.Gray.copy(alpha = 0.3f))&#10;                                )&#10;                            }&#10;&#10;                            AttendanceBottomSheetContent(&#10;                                modifier = Modifier.padding(top = 0.dp),&#10;                                targetLocationInfo = uiState.targetLocation?.let { target -&gt;&#10;                                    TargetLocationInfo(&#10;                                        description = target.description,&#10;                                        locationName = target.category&#10;                                    )&#10;                                },&#10;                                currentLocationAddress = uiState.currentUserAddress.ifEmpty { &quot;Mengambil lokasi saat ini...&quot; },&#10;                                selectedWorkMode = uiState.selectedWorkMode,&#10;                                isBookingEnabled = uiState.isBookingEnabled,&#10;                                isCheckInEnabled = uiState.isButtonEnabled, // Use isButtonEnabled from uiState&#10;                                checkInButtonText = uiState.buttonText,&#10;                                onSearchLocationClick = {&#10;                                    navController.navigate(&quot;location_search&quot;)&#10;                                },&#10;                                onModeSelected = { mode -&gt; viewModel.onWorkModeSelected(mode) },&#10;                                onBookingClick = { viewModel.onBookingClicked() },&#10;                                onCheckInClick = { viewModel.onAttendanceButtonClicked() }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            ) { _ -&gt; // Renamed paddingValues to _ to indicate it's intentionally unused&#10;                Box(modifier = Modifier.fillMaxSize()) {&#10;                    // Fullscreen Map dengan data dari ViewModel - Updated with WFO, WFH, and WFA locations&#10;                    AttendanceMap(&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        wfoLocation = if (uiState.isWfaModeActive) null else uiState.wfoLocation, // Hide WFO when WFA active&#10;                        wfhLocation = if (uiState.isWfaModeActive) null else uiState.wfhLocation, // Hide WFH when WFA active&#10;                        wfaRecommendations = uiState.wfaRecommendations, // WFA recommendations&#10;                        selectedWfaLocation = uiState.selectedWfaLocation, // Selected WFA location&#10;                        targetLocation = uiState.targetLocationMarker, // Keep for backward compatibility&#10;                        currentUserLocation = uiState.currentUserLatitude?.let { lat -&gt;&#10;                            uiState.currentUserLongitude?.let { lng -&gt;&#10;                                Point.fromLngLat(lng, lat)&#10;                            }&#10;                        },&#10;                        onMarkerClick = { location -&gt; viewModel.onMarkerClicked(location) },&#10;                        onWfaMarkerClick = { recommendation: WfaRecommendation -&gt;&#10;                            viewModel.onWfaMarkerClicked(&#10;                                recommendation&#10;                            )&#10;                        }, // Handle WFA marker clicks&#10;                        onMapReady = { mapView -&gt;&#10;                            mapViewInstance = mapView&#10;                            // Notify ViewModel that map is ready for initial focus&#10;                            viewModel.onMapReady()&#10;                        },&#10;                        onCameraIdle = { point -&gt;&#10;                            viewModel.onMapIdle(point)&#10;                        } // Handle Pick on Map functionality&#10;                    )&#10;&#10;                    // Top bar with location focus button - fixed parameters&#10;                    AttendanceTopBar(&#10;                        modifier = Modifier&#10;                            .statusBarsPadding()&#10;                            .padding(16.dp),&#10;                        onBackClicked = { navController.navigateUp() },&#10;                        onFocusLocationClicked = { viewModel.onFocusLocationClicked() }&#10;                    )&#10;&#10;                    // Pick on Map Crosshair - shows static pin in center when Pick on Map mode is active&#10;                    AnimatedVisibility(&#10;                        visible = uiState.isPickOnMapModeActive,&#10;                        modifier = Modifier.align(Alignment.Center)&#10;                    ) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.LocationOn,&#10;                            contentDescription = &quot;Pick Location&quot;,&#10;                            tint = Color.Red,&#10;                            modifier = Modifier.size(32.dp)&#10;                        )&#10;                    }&#10;&#10;                    uiState.selectedMarkerInfo?.let { selectedMarker -&gt;&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .fillMaxSize()&#10;                                .padding(top = 80.dp),&#10;                            contentAlignment = Alignment.TopCenter&#10;                        ) {&#10;                            MarkerView(&#10;                                title = selectedMarker.description,&#10;                                description = &quot;Kategori: ${selectedMarker.category}&quot;,&#10;                                radius = &quot;${selectedMarker.radius} meter&quot;,&#10;                                coordinates = &quot;${selectedMarker.latitude}, ${selectedMarker.longitude}&quot;,&#10;                                onClose = { viewModel.onDismissMarkerInfo() }&#10;                            )&#10;                        }&#10;                    }&#10;&#10;                    // Display WFA marker details when clicked&#10;                    uiState.selectedWfaMarkerInfo?.let { selectedWfaMarker -&gt;&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .fillMaxSize()&#10;                                .padding(top = 80.dp, start = 16.dp, end = 16.dp),&#10;                            contentAlignment = Alignment.TopCenter&#10;                        ) {&#10;                            MarkerViewWfa(&#10;                                recommendation = selectedWfaMarker,&#10;                                onClick = { viewModel.onDismissWfaMarkerInfo() }&#10;                            )&#10;                        }&#10;                    }&#10;&#10;                    // Loading overlay for WFA recommendations&#10;                    if (uiState.isLoadingWfaRecommendations) {&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .fillMaxSize()&#10;                                .background(Color.Black.copy(alpha = 0.3f)),&#10;                            contentAlignment = Alignment.Center&#10;                        ) {&#10;                            LoadingAnimation()&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // =======================================================&#10;    // NEW: State-driven LaunchedEffect for Dialog Handling&#10;    // =======================================================&#10;    LaunchedEffect(uiState.activeDialog) {&#10;        uiState.activeDialog?.let { dialog -&gt;&#10;            when (dialog) {&#10;                is DialogState.Success -&gt; {&#10;                    // Show success dialog with dynamic message from server&#10;                    DialogHelper.showDialogSuccess(&#10;                        context = navController.context,&#10;                        title = &quot;Absensi Berhasil&quot;,&#10;                        textContent = dialog.message,&#10;                        imageRes = R.drawable.icon_success,&#10;                        onConfirm = {&#10;                            // Navigate to HomeScreen after success&#10;                            navController.navigate(Screen.Home.route) {&#10;                                // Clear backstack to prevent going back to attendance&#10;                                popUpTo(Screen.Home.route) {&#10;                                    inclusive = false&#10;                                }&#10;                            }&#10;                            // Notify ViewModel that dialog has been handled&#10;                            viewModel.onDialogDismissed()&#10;                        }&#10;                    )&#10;                }&#10;&#10;                is DialogState.Error -&gt; {&#10;                    // Show error dialog with dynamic message from server&#10;                    DialogHelper.showDialogError(&#10;                        context = navController.context,&#10;                        title = &quot;Absensi Gagal&quot;,&#10;                        textContent = dialog.message,&#10;                        onConfirm = {&#10;                            // Stay on AttendanceScreen - no navigation needed&#10;                            // User can try again&#10;                            viewModel.onDialogDismissed()&#10;                        }&#10;                    )&#10;                }&#10;&#10;                is DialogState.LocationError -&gt; {&#10;                    // Show location error dialog&#10;                    DialogHelper.showDialogError(&#10;                        context = navController.context,&#10;                        title = &quot;Error Lokasi&quot;,&#10;                        textContent = dialog.message,&#10;                        onConfirm = {&#10;                            viewModel.onDialogDismissed()&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Handle face verification result from FaceScannerScreen&#10;    LaunchedEffect(Unit) {&#10;        // Get face verification result from savedStateHandle&#10;        val faceVerificationResult = navController.currentBackStackEntry&#10;            ?.savedStateHandle&#10;            ?.getLiveData&lt;Boolean&gt;(&quot;face_verification_result&quot;)&#10;&#10;        faceVerificationResult?.observeForever { isSuccess -&gt;&#10;            if (isSuccess != null) {&#10;                // FIXED: Only process if verification was successful&#10;                // If failed, user should stay on FaceScannerScreen for retry&#10;                if (isSuccess) {&#10;                    // Call ViewModel to handle the successful result&#10;                    viewModel.onFaceVerificationResult(isSuccess)&#10;                } else {&#10;                    // Face verification failed - don't process, let user retry on scanner screen&#10;                    android.util.Log.d(&#10;                        &quot;AttendanceScreen&quot;,&#10;                        &quot;Face verification failed - user should retry on scanner screen&quot;&#10;                    )&#10;                }&#10;&#10;                // Clear the result to prevent re-processing&#10;                navController.currentBackStackEntry&#10;                    ?.savedStateHandle&#10;                    ?.remove&lt;Boolean&gt;(&quot;face_verification_result&quot;)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun AttendanceScreenPreview() {&#10;    Infinite_TrackTheme {&#10;        Box(modifier = Modifier.fillMaxSize()) {&#10;            AttendanceMap(&#10;                modifier = Modifier.fillMaxSize(),&#10;                onMapReady = { }&#10;            )&#10;            AttendanceTopBar(&#10;                modifier = Modifier&#10;                    .align(Alignment.TopCenter)&#10;                    .statusBarsPadding()&#10;                    .padding(horizontal = 20.dp),&#10;                onBackClicked = { },&#10;                onFocusLocationClicked = { }&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/presentation/screen/attendance/AttendanceViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/presentation/screen/attendance/AttendanceViewModel.kt" />
              <option name="originalContent" value="package com.example.infinite_track.presentation.screen.attendance&#10;&#10;import android.util.Log&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.infinite_track.data.soucre.local.preferences.AttendancePreference&#10;import com.example.infinite_track.domain.model.attendance.AttendanceRequestModel&#10;import com.example.infinite_track.domain.model.attendance.Location&#10;import com.example.infinite_track.domain.model.attendance.TodayStatus&#10;import com.example.infinite_track.domain.model.location.LocationResult&#10;import com.example.infinite_track.domain.model.wfa.WfaRecommendation&#10;import com.example.infinite_track.domain.use_case.attendance.CheckInUseCase&#10;import com.example.infinite_track.domain.use_case.attendance.CheckOutUseCase&#10;import com.example.infinite_track.domain.use_case.attendance.GetTodayStatusUseCase&#10;import com.example.infinite_track.domain.use_case.auth.GetLoggedInUserUseCase&#10;import com.example.infinite_track.domain.use_case.location.GetCurrentAddressUseCase&#10;import com.example.infinite_track.domain.use_case.location.GetCurrentCoordinatesUseCase&#10;import com.example.infinite_track.domain.use_case.location.ReverseGeocodeUseCase&#10;import com.example.infinite_track.domain.use_case.wfa.GetWfaRecommendationsUseCase&#10;import com.example.infinite_track.presentation.geofencing.GeofenceManager&#10;import com.example.infinite_track.presentation.navigation.Screen&#10;import com.example.infinite_track.utils.UiState&#10;import com.mapbox.geojson.Point&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;&#10;/**&#10; * Sealed class untuk merepresentasikan target navigasi&#10; */&#10;sealed class NavigationTarget {&#10;    data class FaceScanner(val isCheckIn: Boolean) : NavigationTarget()&#10;    data class WfaBooking(val route: String) : NavigationTarget()&#10;    data class LocationSearch(val params: String) : NavigationTarget()&#10;}&#10;&#10;/**&#10; * Sealed class untuk merepresentasikan state dialog&#10; */&#10;sealed class DialogState {&#10;    data class Success(val message: String) : DialogState()&#10;    data class Error(val message: String) : DialogState()&#10;    data class LocationError(val message: String) : DialogState()&#10;}&#10;&#10;/**&#10; * Sealed class untuk map animation commands&#10; */&#10;sealed class MapAnimationTarget {&#10;    data class AnimateToLocation(val point: Point, val zoomLevel: Double) : MapAnimationTarget()&#10;    data class AnimateToFitBounds(val points: List&lt;Point&gt;) : MapAnimationTarget()&#10;    object ShowLocationError : MapAnimationTarget()&#10;}&#10;&#10;/**&#10; * Simplified state object focused on reactive geofence integration&#10; * Now supports WFO, WFH, and WFA location markers with Pick on Map functionality&#10; * Updated for state-driven architecture&#10; */&#10;data class AttendanceScreenState(&#10;    val uiState: UiState&lt;Unit&gt; = UiState.Loading,&#10;    val todayStatus: TodayStatus? = null,&#10;    val targetLocation: Location? = null, // Keep for backward compatibility&#10;    val wfoLocation: Location? = null,    // Work From Office location&#10;    val wfhLocation: Location? = null,    // Work From Home location&#10;    val wfaRecommendations: List&lt;WfaRecommendation&gt; = emptyList(), // WFA recommendations&#10;    val selectedWfaLocation: WfaRecommendation? = null, // Selected WFA location&#10;    val selectedWfaMarkerInfo: WfaRecommendation? = null, // For showing WFA marker details&#10;    val isWfaModeActive: Boolean = false, // Flag for WFA mode&#10;    val isLoadingWfaRecommendations: Boolean = false, // Loading state for WFA recommendations&#10;    val currentUserAddress: String = &quot;&quot;,&#10;    val currentUserLatitude: Double? = null,&#10;    val currentUserLongitude: Double? = null,&#10;    val isBookingEnabled: Boolean = false,&#10;    val selectedWorkMode: String = &quot;Work From Office&quot;,&#10;    // Map-specific properties&#10;    val targetLocationMarker: Location? = null,&#10;    val selectedMarkerInfo: Location? = null,&#10;    // Pick on Map properties&#10;    val pickedLocation: LocationResult? = null, // Location picked by user on map&#10;    val isPickOnMapModeActive: Boolean = false, // Flag for Pick on Map mode&#10;    val error: String? = null, // Error message for network failures&#10;    // Attendance button state&#10;    val buttonText: String = &quot;Loading...&quot;,&#10;    val isButtonEnabled: Boolean = false,&#10;    val isCheckInMode: Boolean = true, // Track whether we're in check-in or check-out mode&#10;&#10;    // NEW: State-driven properties for navigation and dialogs&#10;    val navigationTarget: NavigationTarget? = null, // Navigation commands&#10;    val activeDialog: DialogState? = null, // Dialog state&#10;    val mapAnimationTarget: MapAnimationTarget? = null // Map animation commands&#10;)&#10;&#10;/**&#10; * Sealed class for attendance events sent to UI - DEPRECATED&#10; * Keep for backward compatibility during migration&#10; */&#10;@Suppress(&quot;DEPRECATION&quot;)&#10;@Deprecated(&quot;Use DialogState in AttendanceScreenState instead&quot;)&#10;sealed class AttendanceEvent {&#10;    data class ShowSuccessDialog(val message: String) : AttendanceEvent()&#10;    data class ShowErrorDialog(val message: String) : AttendanceEvent()&#10;}&#10;&#10;/**&#10; * Simplified ViewModel that is fully reactive to geofence state&#10; * Removed manual GPS tracking and distance calculation logic&#10; * Uses geofence as the single source of truth for validation&#10; * UPDATED: Migrated to fully state-driven architecture&#10; */&#10;@HiltViewModel&#10;class AttendanceViewModel @Inject constructor(&#10;    private val getTodayStatusUseCase: GetTodayStatusUseCase,&#10;    private val getCurrentAddressUseCase: GetCurrentAddressUseCase,&#10;    private val getCurrentCoordinatesUseCase: GetCurrentCoordinatesUseCase,&#10;    private val getWfaRecommendationsUseCase: GetWfaRecommendationsUseCase,&#10;    private val reverseGeocodeUseCase: ReverseGeocodeUseCase,&#10;    private val attendancePreference: AttendancePreference,&#10;    private val geofenceManager: GeofenceManager,&#10;    private val getLoggedInUserUseCase: GetLoggedInUserUseCase,&#10;    // Add UseCase dependencies for attendance operations&#10;    private val checkInUseCase: CheckInUseCase,&#10;    private val checkOutUseCase: CheckOutUseCase&#10;) : ViewModel() {&#10;&#10;    // Main UI state - now the SINGLE source of truth&#10;    private val _uiState = MutableStateFlow(AttendanceScreenState())&#10;    val uiState: StateFlow&lt;AttendanceScreenState&gt; = _uiState.asStateFlow()&#10;&#10;    // Job for UI-focused location updates (display purposes only)&#10;    private var displayLocationJob: Job? = null&#10;&#10;    companion object {&#10;        private const val TAG = &quot;AttendanceViewModel&quot;&#10;        private const val DISPLAY_UPDATE_INTERVAL = 10000L // 10 seconds for UI updates&#10;    }&#10;&#10;    init {&#10;        initializeData()&#10;    }&#10;&#10;    // ===========================================&#10;    // NEW: Functions for consuming state events&#10;    // ===========================================&#10;&#10;    /**&#10;     * Called by UI after navigation is handled&#10;     * Resets navigationTarget to null&#10;     */&#10;    fun onNavigationHandled() {&#10;        _uiState.value = _uiState.value.copy(navigationTarget = null)&#10;    }&#10;&#10;    /**&#10;     * Called by UI after dialog is dismissed&#10;     * Resets activeDialog to null&#10;     */&#10;    fun onDialogDismissed() {&#10;        _uiState.value = _uiState.value.copy(activeDialog = null)&#10;    }&#10;&#10;    /**&#10;     * Called by UI after map animation is completed&#10;     * Resets mapAnimationTarget to null&#10;     */&#10;    fun onMapAnimationHandled() {&#10;        _uiState.value = _uiState.value.copy(mapAnimationTarget = null)&#10;    }&#10;&#10;    /**&#10;     * Initialize data by fetching both WFO and WFH locations&#10;     */&#10;    private fun initializeData() {&#10;        viewModelScope.launch {&#10;            try {&#10;                _uiState.value = _uiState.value.copy(uiState = UiState.Loading)&#10;&#10;                // Fetch both locations concurrently&#10;                fetchTodayStatus()&#10;                fetchUserHomeLocation()&#10;&#10;                // Don't start location updates automatically - let UI control this&#10;&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error initializing data&quot;, e)&#10;                _uiState.value = _uiState.value.copy(&#10;                    uiState = UiState.Error(&quot;Failed to initialize attendance data: ${e.message}&quot;)&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Fetch today status to get WFO location&#10;     * FIXED: Now uses isButtonEnabled from calculateDynamicButtonState directly&#10;     */&#10;    private suspend fun fetchTodayStatus() {&#10;        try {&#10;            getTodayStatusUseCase().onSuccess { todayStatus -&gt;&#10;                Log.d(TAG, &quot;Today status fetched successfully: $todayStatus&quot;)&#10;&#10;                val isBookingEnabled = todayStatus.activeMode.isNotEmpty()&#10;                val selectedMode = todayStatus.activeMode.ifEmpty { &quot;Work From Office&quot; }&#10;&#10;                // Calculate button state based on today's status&#10;                val (buttonText, isButtonEnabled, isCheckInMode) = calculateDynamicButtonState(&#10;                    todayStatus&#10;                )&#10;&#10;                _uiState.value = _uiState.value.copy(&#10;                    todayStatus = todayStatus,&#10;                    targetLocation = todayStatus.activeLocation,&#10;                    wfoLocation = todayStatus.activeLocation, // WFO location from today status&#10;                    targetLocationMarker = todayStatus.activeLocation,&#10;                    isBookingEnabled = isBookingEnabled,&#10;                    selectedWorkMode = selectedMode,&#10;                    // FIXED: Now uses isButtonEnabled from calculateDynamicButtonState&#10;                    buttonText = buttonText,&#10;                    isButtonEnabled = isButtonEnabled,&#10;                    isCheckInMode = isCheckInMode,&#10;                    uiState = UiState.Success(Unit)&#10;                )&#10;&#10;                // Setup geofence for active location (validation purposes)&#10;                todayStatus.activeLocation?.let { location -&gt;&#10;                    setupGeofence(location)&#10;                }&#10;&#10;                // Send initial camera focus event to WFO location&#10;                todayStatus.activeLocation?.let { location -&gt;&#10;                    val wfoPoint = Point.fromLngLat(location.longitude, location.latitude)&#10;                    viewModelScope.launch {&#10;                        _uiState.value = _uiState.value.copy(&#10;                            mapAnimationTarget = MapAnimationTarget.AnimateToLocation(&#10;                                wfoPoint,&#10;                                15.0&#10;                            )&#10;                        )&#10;                    }&#10;                    Log.d(TAG, &quot;Initial camera focus event sent to WFO location&quot;)&#10;                }&#10;&#10;                Log.d(TAG, &quot;WFO location updated: ${todayStatus.activeLocation}&quot;)&#10;                Log.d(&#10;                    TAG,&#10;                    &quot;Button state updated: $buttonText, enabled: $isButtonEnabled, mode: $isCheckInMode&quot;&#10;                )&#10;&#10;            }.onFailure { exception -&gt;&#10;                Log.e(TAG, &quot;Failed to fetch today status&quot;, exception)&#10;                _uiState.value = _uiState.value.copy(&#10;                    uiState = UiState.Error(&quot;Failed to load attendance status: ${exception.message}&quot;),&#10;                    buttonText = &quot;Error&quot;,&#10;                    isButtonEnabled = false&#10;                )&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Unexpected error in fetchTodayStatus&quot;, e)&#10;            _uiState.value = _uiState.value.copy(&#10;                uiState = UiState.Error(&quot;Unexpected error: ${e.message}&quot;),&#10;                buttonText = &quot;Error&quot;,&#10;                isButtonEnabled = false&#10;            )&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Calculate dynamic button state based on today's status&#10;     * Returns Triple(buttonText, isEnabled, isCheckInMode)&#10;     * FIXED: Tombol selalu aktif kecuali sudah selesai absensi - validasi lokasi diserahkan ke backend&#10;     */&#10;    private fun calculateDynamicButtonState(todayStatus: TodayStatus): Triple&lt;String, Boolean, Boolean&gt; {&#10;        return when {&#10;            // PRIORITAS 1: Belum check-in sama sekali (checked_in_at == null)&#10;            // Selalu aktif - biarkan backend yang validasi lokasi&#10;            todayStatus.checkedInAt == null -&gt; {&#10;                Triple(&quot;Check-in di sini&quot;, true, true)&#10;            }&#10;&#10;            // PRIORITAS 2: Sudah check-in, bisa check-out (checked_in_at != null &amp;&amp; can_check_out == true)&#10;            // Selalu aktif - biarkan backend yang validasi lokasi&#10;            todayStatus.checkedInAt != null &amp;&amp; todayStatus.canCheckOut -&gt; {&#10;                Triple(&quot;Check-out di sini&quot;, true, false)&#10;            }&#10;&#10;            // PRIORITAS 3: Sudah selesai absensi hari ini&#10;            // Hanya kondisi ini yang tombolnya nonaktif&#10;            else -&gt; {&#10;                Triple(&quot;Anda sudah absen hari ini&quot;, false, false)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Fetch user home location from logged in user data&#10;     */&#10;    private suspend fun fetchUserHomeLocation() {&#10;        try {&#10;            getLoggedInUserUseCase().collect { user -&gt;&#10;                Log.d(TAG, &quot;User data fetched successfully&quot;)&#10;&#10;                // Extract WFH location from user profile if available&#10;                val wfhLocation = if (user?.latitude != null &amp;&amp; user.longitude != null) {&#10;                    Location(&#10;                        locationId = user.id, // Use user ID as location ID&#10;                        latitude = user.latitude,&#10;                        longitude = user.longitude,&#10;                        radius = user.radius ?: 100, // Default 100m radius if not specified&#10;                        description = user.locationDescription ?: &quot;Work From Home Location&quot;,&#10;                        category = user.locationCategoryName ?: &quot;Home&quot;&#10;                    )&#10;                } else {&#10;                    null // No home location data available&#10;                }&#10;&#10;                _uiState.value = _uiState.value.copy(&#10;                    wfhLocation = wfhLocation&#10;                )&#10;&#10;                Log.d(TAG, &quot;WFH location updated: $wfhLocation&quot;)&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.w(TAG, &quot;Unexpected error in fetchUserHomeLocation&quot;, e)&#10;            // Continue without WFH location&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Setup geofence for validation (background monitoring)&#10;     * UPDATED: Improved integration with new GeofenceManager clean slate approach&#10;     */&#10;    private fun setupGeofence(location: Location) {&#10;        try {&#10;            Log.d(TAG, &quot;Setting up geofence for location: ${location.description}&quot;)&#10;            Log.d(&#10;                TAG,&#10;                &quot;Location details - ID: ${location.locationId}, Lat: ${location.latitude}, Lng: ${location.longitude}, Radius: ${location.radius}m&quot;&#10;            )&#10;&#10;            geofenceManager.addGeofence(&#10;                id = location.locationId.toString(),&#10;                latitude = location.latitude,&#10;                longitude = location.longitude,&#10;                radius = location.radius.toFloat()&#10;            )&#10;&#10;            Log.d(TAG, &quot;Geofence setup request sent for location: ${location.description}&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Failed to setup geofence for location: ${location.description}&quot;, e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Start location updates for display purposes only (UI updates)&#10;     * This runs only while ViewModel is active for better UX&#10;     */&#10;    private fun startDisplayLocationUpdates() {&#10;        displayLocationJob?.cancel()&#10;&#10;        displayLocationJob = viewModelScope.launch {&#10;            while (true) {&#10;                try {&#10;                    updateDisplayLocation()&#10;                    delay(DISPLAY_UPDATE_INTERVAL)&#10;                } catch (e: Exception) {&#10;                    Log.e(TAG, &quot;Error in display location updates&quot;, e)&#10;                    delay(DISPLAY_UPDATE_INTERVAL)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Update location data for display purposes only&#10;     * Does not affect validation logic&#10;     */&#10;    private suspend fun updateDisplayLocation() {&#10;        try {&#10;            // Update current address for display - menggunakan Geocoding API yang sudah diperbaiki&#10;            getCurrentAddressUseCase().onSuccess { address -&gt;&#10;                _uiState.value = _uiState.value.copy(currentUserAddress = address)&#10;                Log.d(TAG, &quot;Display address updated: $address&quot;)&#10;            }.onFailure { exception -&gt;&#10;                Log.w(TAG, &quot;Failed to get display address&quot;, exception)&#10;                // Set fallback address jika gagal&#10;                _uiState.value = _uiState.value.copy(currentUserAddress = &quot;Mengambil alamat...&quot;)&#10;            }&#10;&#10;            // Update current coordinates for map display - menggunakan database fallback untuk display&#10;            getCurrentCoordinatesUseCase(useRealTimeGPS = false).onSuccess { coordinates -&gt;&#10;                val (latitude, longitude) = coordinates&#10;                _uiState.value = _uiState.value.copy(&#10;                    currentUserLatitude = latitude,&#10;                    currentUserLongitude = longitude&#10;                )&#10;                Log.d(TAG, &quot;Display coordinates updated: $latitude, $longitude&quot;)&#10;            }.onFailure { exception -&gt;&#10;                Log.w(TAG, &quot;Failed to get display coordinates&quot;, exception)&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Unexpected error in updateDisplayLocation&quot;, e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Handle work mode selection with Pick on Map integration&#10;     * UPDATED: Added geofence cleanup when switching modes&#10;     */&#10;    fun onWorkModeSelected(mode: String) {&#10;        Log.d(TAG, &quot;Work mode selected: $mode&quot;)&#10;&#10;        // Clean up any existing geofence before switching modes&#10;        Log.d(TAG, &quot;Cleaning up geofences before mode switch...&quot;)&#10;        geofenceManager.removeAllGeofences()&#10;&#10;        _uiState.value = _uiState.value.copy(&#10;            selectedWorkMode = mode,&#10;            isWfaModeActive = mode == &quot;WFA&quot; || mode == &quot;Work From Anywhere&quot;&#10;        )&#10;&#10;        viewModelScope.launch {&#10;            when (mode) {&#10;                &quot;WFA&quot;, &quot;Work From Anywhere&quot; -&gt; {&#10;                    // Reset previous WFA selection and enter Pick on Map mode&#10;                    _uiState.value = _uiState.value.copy(&#10;                        selectedWfaLocation = null,&#10;                        pickedLocation = null&#10;                    )&#10;                    onEnterPickOnMapMode()&#10;                    fetchWfaRecommendations()&#10;                }&#10;&#10;                &quot;Work From Home&quot;, &quot;WFH&quot; -&gt; {&#10;                    onExitPickOnMapMode()&#10;                    _uiState.value.wfhLocation?.let { wfhLocation -&gt;&#10;                        // Setup geofence for WFH location&#10;                        setupGeofence(wfhLocation)&#10;&#10;                        val wfhPoint = Point.fromLngLat(wfhLocation.longitude, wfhLocation.latitude)&#10;                        _uiState.value = _uiState.value.copy(&#10;                            mapAnimationTarget = MapAnimationTarget.AnimateToLocation(&#10;                                point = wfhPoint,&#10;                                zoomLevel = 15.0&#10;                            )&#10;                        )&#10;                        Log.d(TAG, &quot;Auto-focusing camera to WFH location and setting up geofence&quot;)&#10;                    }&#10;                }&#10;&#10;                &quot;Work From Office&quot;, &quot;WFO&quot; -&gt; {&#10;                    onExitPickOnMapMode()&#10;                    _uiState.value.wfoLocation?.let { wfoLocation -&gt;&#10;                        // Setup geofence for WFO location&#10;                        setupGeofence(wfoLocation)&#10;&#10;                        val wfoPoint = Point.fromLngLat(wfoLocation.longitude, wfoLocation.latitude)&#10;                        _uiState.value = _uiState.value.copy(&#10;                            mapAnimationTarget = MapAnimationTarget.AnimateToLocation(&#10;                                point = wfoPoint,&#10;                                zoomLevel = 15.0&#10;                            )&#10;                        )&#10;                        Log.d(TAG, &quot;Auto-focusing camera to WFO location and setting up geofence&quot;)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Fetch WFA recommendations based on current user location&#10;     * Menggunakan GPS real-time, bukan lokasi WFH yang tersimpan&#10;     */&#10;    private fun fetchWfaRecommendations() {&#10;        viewModelScope.launch {&#10;            try {&#10;                Log.d(TAG, &quot;Fetching WFA recommendations - getting fresh GPS location...&quot;)&#10;&#10;                // Set loading state for WFA recommendations&#10;                _uiState.value = _uiState.value.copy(isLoadingWfaRecommendations = true)&#10;&#10;                // PENTING: Gunakan GPS real-time untuk WFA recommendations&#10;                getCurrentCoordinatesUseCase(useRealTimeGPS = true).onSuccess { coordinates -&gt;&#10;                    val (lat, lng) = coordinates&#10;&#10;                    Log.d(TAG, &quot;Using GPS real-time location for WFA: $lat, $lng&quot;)&#10;&#10;                    getWfaRecommendationsUseCase(lat, lng).onSuccess { recommendations -&gt;&#10;                        _uiState.value = _uiState.value.copy(wfaRecommendations = recommendations)&#10;&#10;                        // Send event to zoom out and show all recommendations&#10;                        if (recommendations.isNotEmpty()) {&#10;                            val points =&#10;                                recommendations.map { Point.fromLngLat(it.longitude, it.latitude) }&#10;                            _uiState.value = _uiState.value.copy(&#10;                                mapAnimationTarget = MapAnimationTarget.AnimateToFitBounds(points)&#10;                            )&#10;                            Log.d(&#10;                                TAG,&#10;                                &quot;WFA recommendations fetched: ${recommendations.size} locations&quot;&#10;                            )&#10;                        } else {&#10;                            Log.w(TAG, &quot;No WFA recommendations found for GPS location: $lat, $lng&quot;)&#10;                        }&#10;                    }.onFailure { exception -&gt;&#10;                        Log.e(TAG, &quot;Failed to fetch WFA recommendations&quot;, exception)&#10;                        // Keep empty list on error&#10;                        _uiState.value = _uiState.value.copy(wfaRecommendations = emptyList())&#10;                    }&#10;&#10;                }.onFailure { exception -&gt;&#10;                    Log.e(TAG, &quot;Failed to get GPS location for WFA recommendations&quot;, exception)&#10;                    // Fallback to cached location if GPS fails&#10;                    val lat = _uiState.value.currentUserLatitude ?: return@launch&#10;                    val lng = _uiState.value.currentUserLongitude ?: return@launch&#10;&#10;                    Log.w(TAG, &quot;GPS failed, using cached location for WFA: $lat, $lng&quot;)&#10;&#10;                    getWfaRecommendationsUseCase(lat, lng).onSuccess { recommendations -&gt;&#10;                        _uiState.value = _uiState.value.copy(wfaRecommendations = recommendations)&#10;                        if (recommendations.isNotEmpty()) {&#10;                            val points =&#10;                                recommendations.map { Point.fromLngLat(it.longitude, it.latitude) }&#10;                            _uiState.value = _uiState.value.copy(&#10;                                mapAnimationTarget = MapAnimationTarget.AnimateToFitBounds(points)&#10;                            )&#10;                            Log.d(&#10;                                TAG,&#10;                                &quot;WFA recommendations fetched with cached location: ${recommendations.size} locations&quot;&#10;                            )&#10;                        }&#10;                    }.onFailure { exception -&gt;&#10;                        Log.e(&#10;                            TAG,&#10;                            &quot;Failed to fetch WFA recommendations with cached location&quot;,&#10;                            exception&#10;                        )&#10;                        _uiState.value = _uiState.value.copy(wfaRecommendations = emptyList())&#10;                    }&#10;                }&#10;&#10;                // Reset loading state&#10;                _uiState.value = _uiState.value.copy(isLoadingWfaRecommendations = false)&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Unexpected error in fetchWfaRecommendations&quot;, e)&#10;                _uiState.value = _uiState.value.copy(&#10;                    wfaRecommendations = emptyList(),&#10;                    isLoadingWfaRecommendations = false&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Handle WFA marker click - Updated to show marker details&#10;     */&#10;    fun onWfaMarkerClicked(recommendation: WfaRecommendation) {&#10;        Log.d(TAG, &quot;WFA Marker clicked: ${recommendation.name}&quot;)&#10;        _uiState.value = _uiState.value.copy(&#10;            selectedWfaLocation = recommendation,&#10;            selectedWfaMarkerInfo = recommendation // Show marker details&#10;        )&#10;&#10;        // Focus camera on selected WFA location&#10;        viewModelScope.launch {&#10;            val point = Point.fromLngLat(recommendation.longitude, recommendation.latitude)&#10;            _uiState.value = _uiState.value.copy(&#10;                mapAnimationTarget = MapAnimationTarget.AnimateToLocation(&#10;                    point,&#10;                    16.0&#10;                )&#10;            ) // Zoom closer for selected marker&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Handle WFA marker info dismissal&#10;     */&#10;    fun onDismissWfaMarkerInfo() {&#10;        Log.d(TAG, &quot;WFA marker info dialog dismissed&quot;)&#10;        _uiState.value = _uiState.value.copy(selectedWfaMarkerInfo = null)&#10;    }&#10;&#10;    /**&#10;     * Handle marker info dialog dismissal&#10;     */&#10;    fun onDismissMarkerInfo() {&#10;        Log.d(TAG, &quot;Marker info dialog dismissed&quot;)&#10;        _uiState.value = _uiState.value.copy(&#10;            selectedMarkerInfo = null,&#10;            selectedWfaMarkerInfo = null // Also dismiss WFA marker info&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Handle booking button click&#10;     */&#10;    fun onBookingClicked() {&#10;        if (_uiState.value.isWfaModeActive) {&#10;            _uiState.value.selectedWfaLocation?.let { wfaLocation -&gt;&#10;                Log.d(TAG, &quot;Booking WFA location: ${wfaLocation.name}&quot;)&#10;                // Navigate to WFA booking screen with location data (latitude and longitude only)&#10;                val route = Screen.WfaBooking.createRoute(&#10;                    latitude = wfaLocation.latitude,&#10;                    longitude = wfaLocation.longitude&#10;                    // address is no longer sent - WfaBookingViewModel will fetch it&#10;                )&#10;                viewModelScope.launch {&#10;                    _uiState.value = _uiState.value.copy(&#10;                        navigationTarget = NavigationTarget.WfaBooking(route)&#10;                    )&#10;                }&#10;            } ?: run {&#10;                Log.w(TAG, &quot;Booking clicked in WFA mode but no location selected.&quot;)&#10;            }&#10;        } else {&#10;            Log.d(TAG, &quot;Booking clicked for mode: ${_uiState.value.selectedWorkMode}&quot;)&#10;            // TODO: Implement booking logic for WFO/WFH&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Handle attendance button click - navigates to face scanner&#10;     * FIXED: Uses new Screen.FaceScanner.createRoute with action parameter&#10;     */&#10;    fun onAttendanceButtonClicked() {&#10;        // Use the reactive StateFlow value instead of recalculating&#10;        val isEnabled = _uiState.value.isButtonEnabled&#10;        val buttonText = _uiState.value.buttonText&#10;&#10;        if (!isEnabled) {&#10;            Log.d(TAG, &quot;Attendance button clicked but not enabled (geofence or server restriction)&quot;)&#10;            return&#10;        }&#10;&#10;        val isCheckIn = buttonText.contains(&quot;Check-in&quot;, ignoreCase = true)&#10;        val action = if (isCheckIn) &quot;checkin&quot; else &quot;checkout&quot;&#10;&#10;        Log.d(TAG, &quot;Attendance button clicked - $action&quot;)&#10;&#10;        // Update isCheckInMode state before navigation&#10;        _uiState.value = _uiState.value.copy(isCheckInMode = isCheckIn)&#10;&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(&#10;                navigationTarget = NavigationTarget.FaceScanner(isCheckIn)&#10;            )&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Handle face verification result - GATEWAY after face verification&#10;     * Called from FaceScannerScreen when verification is complete&#10;     */&#10;    fun onFaceVerificationResult(isSuccess: Boolean) {&#10;        Log.d(TAG, &quot;Face verification result: $isSuccess&quot;)&#10;&#10;        if (!isSuccess) {&#10;            Log.d(TAG, &quot;Face verification failed - aborting attendance process&quot;)&#10;            _uiState.value = _uiState.value.copy(&#10;                activeDialog = DialogState.Error(&quot;Verifikasi wajah gagal. Silakan coba lagi.&quot;)&#10;            )&#10;            return&#10;        }&#10;&#10;        // Check current mode and proceed accordingly&#10;        if (_uiState.value.isCheckInMode) {&#10;            proceedWithCheckIn()&#10;        } else {&#10;            proceedWithCheckOut()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Proceed with check-in after successful face verification&#10;     * FIXED: Added proper targetLocation determination logic&#10;     */&#10;    private fun proceedWithCheckIn() {&#10;        viewModelScope.launch {&#10;            try {&#10;                Log.d(TAG, &quot;Proceeding with check-in after face verification&quot;)&#10;&#10;                // Clear any previous error&#10;                _uiState.value = _uiState.value.copy(activeDialog = null)&#10;&#10;                // FIXED: Determine target location based on selected work mode&#10;                val targetLocation = when (_uiState.value.selectedWorkMode) {&#10;                    &quot;Work From Home&quot;, &quot;WFH&quot; -&gt; _uiState.value.wfhLocation&#10;                    &quot;Work From Office&quot;, &quot;WFO&quot; -&gt; _uiState.value.wfoLocation&#10;                    &quot;WFA&quot;, &quot;Work From Anywhere&quot; -&gt; {&#10;                        // For WFA, convert selectedWfaLocation to Location object&#10;                        _uiState.value.selectedWfaLocation?.let { wfaLocation -&gt;&#10;                            Location(&#10;                                locationId = 0, // WFA locations don't have fixed IDs&#10;                                latitude = wfaLocation.latitude,&#10;                                longitude = wfaLocation.longitude,&#10;                                radius = 100, // Default radius for WFA&#10;                                description = wfaLocation.name,&#10;                                category = wfaLocation.category&#10;                            )&#10;                        }&#10;                    }&#10;&#10;                    else -&gt; _uiState.value.wfoLocation // Default to WFO&#10;                }&#10;&#10;                if (targetLocation == null) {&#10;                    _uiState.value = _uiState.value.copy(&#10;                        activeDialog = DialogState.Error(&quot;Target location not available for ${_uiState.value.selectedWorkMode}. Please try again.&quot;)&#10;                    )&#10;                    return@launch&#10;                }&#10;&#10;                // Get user info for the request&#10;                getLoggedInUserUseCase().collect { user -&gt;&#10;                    if (user == null) {&#10;                        _uiState.value = _uiState.value.copy(&#10;                            activeDialog = DialogState.Error(&quot;User information not available. Please try again.&quot;)&#10;                        )&#10;                        return@collect&#10;                    }&#10;&#10;                    // FIXED: Map work mode to correct category_id&#10;                    val categoryId = when (_uiState.value.selectedWorkMode) {&#10;                        &quot;Work From Office&quot;, &quot;WFO&quot; -&gt; 1  // Work From Office&#10;                        &quot;Work From Home&quot;, &quot;WFH&quot; -&gt; 2    // Work From Home&#10;                        &quot;WFA&quot;, &quot;Work From Anywhere&quot; -&gt; 3 // Work From Anywhere&#10;                        else -&gt; 1 // Default to WFO&#10;                    }&#10;&#10;                    // Create attendance request model with proper parameters&#10;                    val attendanceRequest = AttendanceRequestModel(&#10;                        categoryId = categoryId, // Use correct category ID based on work mode&#10;                        latitude = 0.0, // Will be updated by UseCase with real-time GPS&#10;                        longitude = 0.0, // Will be updated by UseCase with real-time GPS&#10;                        notes = &quot;Check-in via mobile app&quot;,&#10;                        bookingId = null, // No booking for regular check-in&#10;                        type = &quot;checkin&quot;&#10;                    )&#10;&#10;                    // FIXED: Call CheckInUseCase with both request and target location&#10;                    checkInUseCase(attendanceRequest, targetLocation).onSuccess { activeSession -&gt;&#10;                        Log.d(TAG, &quot;Check-in successful: $activeSession&quot;)&#10;&#10;                        // Refresh today's status to get updated data&#10;                        fetchTodayStatus()&#10;&#10;                        // Send success event to UI with appropriate message&#10;                        _uiState.value = _uiState.value.copy(&#10;                            activeDialog = DialogState.Success(&quot;Check-in berhasil! Selamat bekerja hari ini.&quot;)&#10;                        )&#10;&#10;                    }.onFailure { exception -&gt;&#10;                        Log.e(TAG, &quot;Check-in failed&quot;, exception)&#10;&#10;                        // Send error event to UI with dynamic message from server&#10;                        _uiState.value = _uiState.value.copy(&#10;                            activeDialog = DialogState.Error(&#10;                                exception.message ?: &quot;Check-in gagal. Silakan coba lagi.&quot;&#10;                            )&#10;                        )&#10;                    }&#10;                }&#10;&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error in proceedWithCheckIn&quot;, e)&#10;                _uiState.value = _uiState.value.copy(&#10;                    activeDialog = DialogState.Error(&quot;Unexpected error during check-in: ${e.message}&quot;)&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Proceed with check-out after successful face verification&#10;     * PRIVATE - only called from onFaceVerificationResult&#10;     */&#10;    private fun proceedWithCheckOut() {&#10;        viewModelScope.launch {&#10;            try {&#10;                Log.d(TAG, &quot;Proceeding with check-out after face verification&quot;)&#10;&#10;                // Clear any previous error&#10;                _uiState.value = _uiState.value.copy(activeDialog = null)&#10;&#10;                // Call CheckOutUseCase - it will handle everything internally&#10;                checkOutUseCase().onSuccess { activeSession -&gt;&#10;                    Log.d(TAG, &quot;Check-out successful: $activeSession&quot;)&#10;&#10;                    // Refresh today's status to get updated data&#10;                    fetchTodayStatus()&#10;&#10;                    // Send success event to UI with appropriate message&#10;                    _uiState.value = _uiState.value.copy(&#10;                        activeDialog = DialogState.Success(&quot;Check-out berhasil! Terima kasih atas kerja keras Anda hari ini.&quot;)&#10;                    )&#10;&#10;                }.onFailure { exception -&gt;&#10;                    Log.e(TAG, &quot;Check-out failed&quot;, exception)&#10;&#10;                    // Send error event to UI with dynamic message from server&#10;                    _uiState.value = _uiState.value.copy(&#10;                        activeDialog = DialogState.Error(&#10;                            exception.message ?: &quot;Check-out gagal. Silakan coba lagi.&quot;&#10;                        )&#10;                    )&#10;                }&#10;&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error in proceedWithCheckOut&quot;, e)&#10;                _uiState.value = _uiState.value.copy(&#10;                    activeDialog = DialogState.Error(&quot;Unexpected error during check-out: ${e.message}&quot;)&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Clear error message&#10;     */&#10;    fun clearError() {&#10;        _uiState.value = _uiState.value.copy(activeDialog = null)&#10;    }&#10;&#10;    /**&#10;     * Handle map marker click&#10;     */&#10;    fun onMarkerClicked(location: Location) {&#10;        Log.d(TAG, &quot;Marker clicked for location: ${location.description}&quot;)&#10;        _uiState.value = _uiState.value.copy(selectedMarkerInfo = location)&#10;    }&#10;&#10;    /**&#10;     * Handle focus location button click&#10;     * This should ONLY focus on current user location, not work mode locations&#10;     * Always gets fresh location data when clicked&#10;     */&#10;    fun onFocusLocationClicked() {&#10;        Log.d(TAG, &quot;=== FOCUS LOCATION BUTTON CLICKED ===&quot;)&#10;        Log.d(TAG, &quot;Current work mode: ${_uiState.value.selectedWorkMode}&quot;)&#10;        Log.d(TAG, &quot;Current WFH location: ${_uiState.value.wfhLocation}&quot;)&#10;        Log.d(TAG, &quot;Getting fresh GPS coordinates...&quot;)&#10;&#10;        viewModelScope.launch {&#10;            try {&#10;                // PENTING: Gunakan GPS real-time, bukan dari database&#10;                getCurrentCoordinatesUseCase(useRealTimeGPS = true).onSuccess { coordinates -&gt;&#10;                    val (latitude, longitude) = coordinates&#10;&#10;                    Log.d(TAG, &quot;=== FRESH GPS COORDINATES RECEIVED ===&quot;)&#10;                    Log.d(TAG, &quot;GPS Real-time Latitude: $latitude&quot;)&#10;                    Log.d(TAG, &quot;GPS Real-time Longitude: $longitude&quot;)&#10;                    Log.d(TAG, &quot;WFH Latitude: ${_uiState.value.wfhLocation?.latitude}&quot;)&#10;                    Log.d(TAG, &quot;WFH Longitude: ${_uiState.value.wfhLocation?.longitude}&quot;)&#10;&#10;                    // Pastikan koordinat berbeda dari WFH&#10;                    if (latitude == _uiState.value.wfhLocation?.latitude &amp;&amp;&#10;                        longitude == _uiState.value.wfhLocation?.longitude&#10;                    ) {&#10;                        Log.w(TAG, &quot;WARNING: GPS coordinates sama dengan WFH location!&quot;)&#10;                        Log.w(TAG, &quot;Ini mungkin karena GPS masih menggunakan cached location&quot;)&#10;                    }&#10;&#10;                    // Update state untuk immediate display&#10;                    _uiState.value = _uiState.value.copy(&#10;                        currentUserLatitude = latitude,&#10;                        currentUserLongitude = longitude&#10;                    )&#10;&#10;                    // Send map animation event&#10;                    val focusPoint = Point.fromLngLat(longitude, latitude)&#10;                    _uiState.value = _uiState.value.copy(&#10;                        mapAnimationTarget = MapAnimationTarget.AnimateToLocation(&#10;                            point = focusPoint,&#10;                            zoomLevel = 15.0&#10;                        )&#10;                    )&#10;&#10;                    Log.d(TAG, &quot;=== MAP ANIMATION SENT ===&quot;)&#10;                    Log.d(TAG, &quot;Focus point: ${focusPoint.latitude()}, ${focusPoint.longitude()}&quot;)&#10;                    Log.d(TAG, &quot;This should be your CURRENT GPS location, NOT your home location!&quot;)&#10;                }.onFailure { exception -&gt;&#10;                    Log.e(TAG, &quot;=== GPS LOCATION FAILED ===&quot;)&#10;                    Log.e(TAG, &quot;Failed to get current GPS location: ${exception.message}&quot;)&#10;                    _uiState.value = _uiState.value.copy(&#10;                        mapAnimationTarget = MapAnimationTarget.ShowLocationError&#10;                    )&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;=== UNEXPECTED ERROR ===&quot;)&#10;                Log.e(TAG, &quot;Error in onFocusLocationClicked: ${e.message}&quot;)&#10;                _uiState.value = _uiState.value.copy(&#10;                    mapAnimationTarget = MapAnimationTarget.ShowLocationError&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Called when the map is ready to receive commands&#10;     * This will trigger initial camera focus to WFO location&#10;     */&#10;    fun onMapReady() {&#10;        Log.d(TAG, &quot;Map is ready, focusing to WFO location&quot;)&#10;        viewModelScope.launch {&#10;            _uiState.value.wfoLocation?.let { wfoLocation -&gt;&#10;                val wfoPoint = Point.fromLngLat(wfoLocation.longitude, wfoLocation.latitude)&#10;                _uiState.value = _uiState.value.copy(&#10;                    mapAnimationTarget = MapAnimationTarget.AnimateToLocation(&#10;                        point = wfoPoint,&#10;                        zoomLevel = 15.0&#10;                    )&#10;                )&#10;                Log.d(TAG, &quot;Initial camera focus sent to WFO location&quot;)&#10;            } ?: run {&#10;                Log.w(TAG, &quot;WFO location not available for initial focus&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Start location updates for display purposes&#10;     * This should be called by UI when location permissions are granted&#10;     */&#10;    fun startLocationUpdates() {&#10;        Log.d(TAG, &quot;Starting location updates for display&quot;)&#10;        startDisplayLocationUpdates()&#10;    }&#10;&#10;    /**&#10;     * Handle selected location from LocationSearchScreen&#10;     */&#10;    fun onLocationSelected(location: LocationResult) {&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(&#10;                selectedWfaLocation = WfaRecommendation(&#10;                    name = location.placeName,&#10;                    address = location.address,&#10;                    latitude = location.latitude,&#10;                    longitude = location.longitude,&#10;                    score = 0.0, // Default score for manually selected location&#10;                    label = &quot;Manual Selection&quot;, // Default label for manually selected location&#10;                    category = &quot;Custom&quot;, // Default category for manually selected location&#10;                    distance = 0.0 // Distance will be calculated based on current location&#10;                ),&#10;                isWfaModeActive = true&#10;            )&#10;&#10;            // Animate map to the selected location&#10;            _uiState.value = _uiState.value.copy(&#10;                mapAnimationTarget = MapAnimationTarget.AnimateToLocation(&#10;                    Point.fromLngLat(location.longitude, location.latitude),&#10;                    15.0&#10;                )&#10;            )&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Enter Pick on Map mode - enables crosshair and map interaction&#10;     */&#10;    fun onEnterPickOnMapMode() {&#10;        Log.d(TAG, &quot;Entering Pick on Map mode&quot;)&#10;        _uiState.value = _uiState.value.copy(&#10;            isPickOnMapModeActive = true,&#10;            pickedLocation = null // Reset any previously picked location&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Exit Pick on Map mode - disables crosshair and map interaction&#10;     */&#10;    fun onExitPickOnMapMode() {&#10;        Log.d(TAG, &quot;Exiting Pick on Map mode&quot;)&#10;        _uiState.value = _uiState.value.copy(&#10;            isPickOnMapModeActive = false,&#10;            pickedLocation = null&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Handle map idle event - called when user stops moving the map&#10;     * Performs reverse geocoding for the center point of the map&#10;     */&#10;    fun onMapIdle(centerPoint: Point) {&#10;        // Only perform reverse geocoding if Pick on Map mode is active&#10;        if (!_uiState.value.isPickOnMapModeActive) return&#10;&#10;        viewModelScope.launch {&#10;            try {&#10;                Log.d(&#10;                    TAG,&#10;                    &quot;Map idle detected in Pick on Map mode: ${centerPoint.latitude()}, ${centerPoint.longitude()}&quot;&#10;                )&#10;&#10;                // Perform reverse geocoding for the center point&#10;                reverseGeocodeUseCase(&#10;                    latitude = centerPoint.latitude(),&#10;                    longitude = centerPoint.longitude()&#10;                ).onSuccess { locationResult -&gt;&#10;                    Log.d(TAG, &quot;Reverse geocoding successful: ${locationResult.placeName}&quot;)&#10;&#10;                    // Update the picked location&#10;                    _uiState.value = _uiState.value.copy(&#10;                        pickedLocation = locationResult,&#10;                        selectedWfaLocation = WfaRecommendation(&#10;                            name = locationResult.placeName,&#10;                            address = locationResult.address,&#10;                            latitude = locationResult.latitude,&#10;                            longitude = locationResult.longitude,&#10;                            score = 0.0,&#10;                            label = &quot;Picked on Map&quot;,&#10;                            category = &quot;Manual Selection&quot;,&#10;                            distance = 0.0&#10;                        )&#10;                    )&#10;                }.onFailure { exception -&gt;&#10;                    Log.e(TAG, &quot;Reverse geocoding failed&quot;, exception)&#10;&#10;                    // Don't create fallback location, instead show error and keep picked location null&#10;                    _uiState.value = _uiState.value.copy(&#10;                        pickedLocation = null, // Ensure picked location is null&#10;                        selectedWfaLocation = null, // Clear any selected WFA location&#10;                        // Show error message in BottomSheet&#10;                        error = &quot;Gagal mendapatkan detail lokasi. Periksa koneksi Anda.&quot;&#10;                    )&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Unexpected error in onMapIdle&quot;, e)&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        displayLocationJob?.cancel()&#10;&#10;        // Clean up geofence when ViewModel is cleared&#10;        _uiState.value.targetLocation?.let { location -&gt;&#10;            geofenceManager.removeGeofence(location.locationId.toString())&#10;        }&#10;&#10;        Log.d(TAG, &quot;ViewModel cleared, display location tracking stopped&quot;)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.infinite_track.presentation.screen.attendance&#10;&#10;import android.util.Log&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.infinite_track.data.soucre.local.preferences.AttendancePreference&#10;import com.example.infinite_track.domain.model.attendance.AttendanceRequestModel&#10;import com.example.infinite_track.domain.model.attendance.Location&#10;import com.example.infinite_track.domain.model.attendance.TodayStatus&#10;import com.example.infinite_track.domain.model.location.LocationResult&#10;import com.example.infinite_track.domain.model.wfa.WfaRecommendation&#10;import com.example.infinite_track.domain.use_case.attendance.CheckInUseCase&#10;import com.example.infinite_track.domain.use_case.attendance.CheckOutUseCase&#10;import com.example.infinite_track.domain.use_case.attendance.GetTodayStatusUseCase&#10;import com.example.infinite_track.domain.use_case.auth.GetLoggedInUserUseCase&#10;import com.example.infinite_track.domain.use_case.location.GetCurrentAddressUseCase&#10;import com.example.infinite_track.domain.use_case.location.GetCurrentCoordinatesUseCase&#10;import com.example.infinite_track.domain.use_case.location.ReverseGeocodeUseCase&#10;import com.example.infinite_track.domain.use_case.wfa.GetWfaRecommendationsUseCase&#10;import com.example.infinite_track.presentation.geofencing.GeofenceManager&#10;import com.example.infinite_track.presentation.navigation.Screen&#10;import com.example.infinite_track.utils.UiState&#10;import com.mapbox.geojson.Point&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;&#10;/**&#10; * Sealed class untuk merepresentasikan target navigasi&#10; */&#10;sealed class NavigationTarget {&#10;    data class FaceScanner(val isCheckIn: Boolean) : NavigationTarget()&#10;    data class WfaBooking(val route: String) : NavigationTarget()&#10;    data class LocationSearch(val params: String) : NavigationTarget()&#10;}&#10;&#10;/**&#10; * Sealed class untuk merepresentasikan state dialog&#10; */&#10;sealed class DialogState {&#10;    data class Success(val message: String) : DialogState()&#10;    data class Error(val message: String) : DialogState()&#10;    data class LocationError(val message: String) : DialogState()&#10;}&#10;&#10;/**&#10; * Sealed class untuk map animation commands&#10; */&#10;sealed class MapAnimationTarget {&#10;    data class AnimateToLocation(val point: Point, val zoomLevel: Double) : MapAnimationTarget()&#10;    data class AnimateToFitBounds(val points: List&lt;Point&gt;) : MapAnimationTarget()&#10;    object ShowLocationError : MapAnimationTarget()&#10;}&#10;&#10;/**&#10; * Simplified state object focused on reactive geofence integration&#10; * Now supports WFO, WFH, and WFA location markers with Pick on Map functionality&#10; * Updated for state-driven architecture&#10; */&#10;data class AttendanceScreenState(&#10;    val uiState: UiState&lt;Unit&gt; = UiState.Loading,&#10;    val todayStatus: TodayStatus? = null,&#10;    val targetLocation: Location? = null, // Keep for backward compatibility&#10;    val wfoLocation: Location? = null,    // Work From Office location&#10;    val wfhLocation: Location? = null,    // Work From Home location&#10;    val wfaRecommendations: List&lt;WfaRecommendation&gt; = emptyList(), // WFA recommendations&#10;    val selectedWfaLocation: WfaRecommendation? = null, // Selected WFA location&#10;    val selectedWfaMarkerInfo: WfaRecommendation? = null, // For showing WFA marker details&#10;    val isWfaModeActive: Boolean = false, // Flag for WFA mode&#10;    val isLoadingWfaRecommendations: Boolean = false, // Loading state for WFA recommendations&#10;    val currentUserAddress: String = &quot;&quot;,&#10;    val currentUserLatitude: Double? = null,&#10;    val currentUserLongitude: Double? = null,&#10;    val isBookingEnabled: Boolean = false,&#10;    val selectedWorkMode: String = &quot;Work From Office&quot;,&#10;    // Map-specific properties&#10;    val targetLocationMarker: Location? = null,&#10;    val selectedMarkerInfo: Location? = null,&#10;    // Pick on Map properties&#10;    val pickedLocation: LocationResult? = null, // Location picked by user on map&#10;    val isPickOnMapModeActive: Boolean = false, // Flag for Pick on Map mode&#10;    val error: String? = null, // Error message for network failures&#10;    // Attendance button state&#10;    val buttonText: String = &quot;Loading...&quot;,&#10;    val isButtonEnabled: Boolean = false,&#10;    val isCheckInMode: Boolean = true, // Track whether we're in check-in or check-out mode&#10;&#10;    // State-driven properties for navigation and dialogs&#10;    val navigationTarget: NavigationTarget? = null, // Navigation commands&#10;    val activeDialog: DialogState? = null, // Dialog state&#10;    val mapAnimationTarget: MapAnimationTarget? = null // Map animation commands&#10;)&#10;&#10;/**&#10; * Simplified ViewModel that is fully reactive to geofence state&#10; * Removed manual GPS tracking and distance calculation logic&#10; * Uses geofence as the single source of truth for validation&#10; * UPDATED: Migrated to fully state-driven architecture&#10; */&#10;@HiltViewModel&#10;class AttendanceViewModel @Inject constructor(&#10;    private val getTodayStatusUseCase: GetTodayStatusUseCase,&#10;    private val getCurrentAddressUseCase: GetCurrentAddressUseCase,&#10;    private val getCurrentCoordinatesUseCase: GetCurrentCoordinatesUseCase,&#10;    private val getWfaRecommendationsUseCase: GetWfaRecommendationsUseCase,&#10;    private val reverseGeocodeUseCase: ReverseGeocodeUseCase,&#10;    private val attendancePreference: AttendancePreference,&#10;    private val geofenceManager: GeofenceManager,&#10;    private val getLoggedInUserUseCase: GetLoggedInUserUseCase,&#10;    // Add UseCase dependencies for attendance operations&#10;    private val checkInUseCase: CheckInUseCase,&#10;    private val checkOutUseCase: CheckOutUseCase&#10;) : ViewModel() {&#10;&#10;    // Main UI state - now the SINGLE source of truth&#10;    private val _uiState = MutableStateFlow(AttendanceScreenState())&#10;    val uiState: StateFlow&lt;AttendanceScreenState&gt; = _uiState.asStateFlow()&#10;&#10;    // Job for UI-focused location updates (display purposes only)&#10;    private var displayLocationJob: Job? = null&#10;&#10;    companion object {&#10;        private const val TAG = &quot;AttendanceViewModel&quot;&#10;        private const val DISPLAY_UPDATE_INTERVAL = 10000L // 10 seconds for UI updates&#10;    }&#10;&#10;    init {&#10;        initializeData()&#10;    }&#10;&#10;    // ===========================================&#10;    // Functions for consuming state events&#10;    // ===========================================&#10;&#10;    /**&#10;     * Called by UI after navigation is handled&#10;     * Resets navigationTarget to null&#10;     */&#10;    fun onNavigationHandled() {&#10;        _uiState.value = _uiState.value.copy(navigationTarget = null)&#10;    }&#10;&#10;    /**&#10;     * Called by UI after dialog is dismissed&#10;     * Resets activeDialog to null&#10;     */&#10;    fun onDialogDismissed() {&#10;        _uiState.value = _uiState.value.copy(activeDialog = null)&#10;    }&#10;&#10;    /**&#10;     * Called by UI after map animation is completed&#10;     * Resets mapAnimationTarget to null&#10;     */&#10;    fun onMapAnimationHandled() {&#10;        _uiState.value = _uiState.value.copy(mapAnimationTarget = null)&#10;    }&#10;&#10;    /**&#10;     * Initialize data by fetching both WFO and WFH locations&#10;     */&#10;    private fun initializeData() {&#10;        viewModelScope.launch {&#10;            try {&#10;                _uiState.value = _uiState.value.copy(uiState = UiState.Loading)&#10;&#10;                // Fetch both locations concurrently&#10;                fetchTodayStatus()&#10;                fetchUserHomeLocation()&#10;&#10;                // Don't start location updates automatically - let UI control this&#10;&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error initializing data&quot;, e)&#10;                _uiState.value = _uiState.value.copy(&#10;                    uiState = UiState.Error(&quot;Failed to initialize attendance data: ${e.message}&quot;)&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Fetch today status to get WFO location&#10;     * FIXED: Now uses isButtonEnabled from calculateDynamicButtonState directly&#10;     */&#10;    private suspend fun fetchTodayStatus() {&#10;        try {&#10;            getTodayStatusUseCase().onSuccess { todayStatus -&gt;&#10;                Log.d(TAG, &quot;Today status fetched successfully: $todayStatus&quot;)&#10;&#10;                val isBookingEnabled = todayStatus.activeMode.isNotEmpty()&#10;                val selectedMode = todayStatus.activeMode.ifEmpty { &quot;Work From Office&quot; }&#10;&#10;                // Calculate button state based on today's status&#10;                val (buttonText, isButtonEnabled, isCheckInMode) = calculateDynamicButtonState(&#10;                    todayStatus&#10;                )&#10;&#10;                _uiState.value = _uiState.value.copy(&#10;                    todayStatus = todayStatus,&#10;                    targetLocation = todayStatus.activeLocation,&#10;                    wfoLocation = todayStatus.activeLocation, // WFO location from today status&#10;                    targetLocationMarker = todayStatus.activeLocation,&#10;                    isBookingEnabled = isBookingEnabled,&#10;                    selectedWorkMode = selectedMode,&#10;                    // FIXED: Now uses isButtonEnabled from calculateDynamicButtonState&#10;                    buttonText = buttonText,&#10;                    isButtonEnabled = isButtonEnabled,&#10;                    isCheckInMode = isCheckInMode,&#10;                    uiState = UiState.Success(Unit)&#10;                )&#10;&#10;                // Setup geofence for active location (validation purposes)&#10;                todayStatus.activeLocation?.let { location -&gt;&#10;                    setupGeofence(location)&#10;                }&#10;&#10;                // Send initial camera focus event to WFO location&#10;                todayStatus.activeLocation?.let { location -&gt;&#10;                    val wfoPoint = Point.fromLngLat(location.longitude, location.latitude)&#10;                    viewModelScope.launch {&#10;                        _uiState.value = _uiState.value.copy(&#10;                            mapAnimationTarget = MapAnimationTarget.AnimateToLocation(&#10;                                wfoPoint,&#10;                                15.0&#10;                            )&#10;                        )&#10;                    }&#10;                    Log.d(TAG, &quot;Initial camera focus event sent to WFO location&quot;)&#10;                }&#10;&#10;                Log.d(TAG, &quot;WFO location updated: ${todayStatus.activeLocation}&quot;)&#10;                Log.d(&#10;                    TAG,&#10;                    &quot;Button state updated: $buttonText, enabled: $isButtonEnabled, mode: $isCheckInMode&quot;&#10;                )&#10;&#10;            }.onFailure { exception -&gt;&#10;                Log.e(TAG, &quot;Failed to fetch today status&quot;, exception)&#10;                _uiState.value = _uiState.value.copy(&#10;                    uiState = UiState.Error(&quot;Failed to load attendance status: ${exception.message}&quot;),&#10;                    buttonText = &quot;Error&quot;,&#10;                    isButtonEnabled = false&#10;                )&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Unexpected error in fetchTodayStatus&quot;, e)&#10;            _uiState.value = _uiState.value.copy(&#10;                uiState = UiState.Error(&quot;Unexpected error: ${e.message}&quot;),&#10;                buttonText = &quot;Error&quot;,&#10;                isButtonEnabled = false&#10;            )&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Calculate dynamic button state based on today's status&#10;     * Returns Triple(buttonText, isEnabled, isCheckInMode)&#10;     * FIXED: Tombol selalu aktif kecuali sudah selesai absensi - validasi lokasi diserahkan ke backend&#10;     */&#10;    private fun calculateDynamicButtonState(todayStatus: TodayStatus): Triple&lt;String, Boolean, Boolean&gt; {&#10;        return when {&#10;            // PRIORITAS 1: Belum check-in sama sekali (checked_in_at == null)&#10;            // Selalu aktif - biarkan backend yang validasi lokasi&#10;            todayStatus.checkedInAt == null -&gt; {&#10;                Triple(&quot;Check-in di sini&quot;, true, true)&#10;            }&#10;&#10;            // PRIORITAS 2: Sudah check-in, bisa check-out (checked_in_at != null &amp;&amp; can_check_out == true)&#10;            // Selalu aktif - biarkan backend yang validasi lokasi&#10;            todayStatus.checkedInAt != null &amp;&amp; todayStatus.canCheckOut -&gt; {&#10;                Triple(&quot;Check-out di sini&quot;, true, false)&#10;            }&#10;&#10;            // PRIORITAS 3: Sudah selesai absensi hari ini&#10;            // Hanya kondisi ini yang tombolnya nonaktif&#10;            else -&gt; {&#10;                Triple(&quot;Anda sudah absen hari ini&quot;, false, false)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Fetch user home location from logged in user data&#10;     */&#10;    private suspend fun fetchUserHomeLocation() {&#10;        try {&#10;            getLoggedInUserUseCase().collect { user -&gt;&#10;                Log.d(TAG, &quot;User data fetched successfully&quot;)&#10;&#10;                // Extract WFH location from user profile if available&#10;                val wfhLocation = if (user?.latitude != null &amp;&amp; user.longitude != null) {&#10;                    Location(&#10;                        locationId = user.id, // Use user ID as location ID&#10;                        latitude = user.latitude,&#10;                        longitude = user.longitude,&#10;                        radius = user.radius ?: 100, // Default 100m radius if not specified&#10;                        description = user.locationDescription ?: &quot;Work From Home Location&quot;,&#10;                        category = user.locationCategoryName ?: &quot;Home&quot;&#10;                    )&#10;                } else {&#10;                    null // No home location data available&#10;                }&#10;&#10;                _uiState.value = _uiState.value.copy(&#10;                    wfhLocation = wfhLocation&#10;                )&#10;&#10;                Log.d(TAG, &quot;WFH location updated: $wfhLocation&quot;)&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.w(TAG, &quot;Unexpected error in fetchUserHomeLocation&quot;, e)&#10;            // Continue without WFH location&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Setup geofence for validation (background monitoring)&#10;     * UPDATED: Improved integration with new GeofenceManager clean slate approach&#10;     */&#10;    private fun setupGeofence(location: Location) {&#10;        try {&#10;            Log.d(TAG, &quot;Setting up geofence for location: ${location.description}&quot;)&#10;            Log.d(&#10;                TAG,&#10;                &quot;Location details - ID: ${location.locationId}, Lat: ${location.latitude}, Lng: ${location.longitude}, Radius: ${location.radius}m&quot;&#10;            )&#10;&#10;            geofenceManager.addGeofence(&#10;                id = location.locationId.toString(),&#10;                latitude = location.latitude,&#10;                longitude = location.longitude,&#10;                radius = location.radius.toFloat()&#10;            )&#10;&#10;            Log.d(TAG, &quot;Geofence setup request sent for location: ${location.description}&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Failed to setup geofence for location: ${location.description}&quot;, e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Start location updates for display purposes only (UI updates)&#10;     * This runs only while ViewModel is active for better UX&#10;     */&#10;    private fun startDisplayLocationUpdates() {&#10;        displayLocationJob?.cancel()&#10;&#10;        displayLocationJob = viewModelScope.launch {&#10;            while (true) {&#10;                try {&#10;                    updateDisplayLocation()&#10;                    delay(DISPLAY_UPDATE_INTERVAL)&#10;                } catch (e: Exception) {&#10;                    Log.e(TAG, &quot;Error in display location updates&quot;, e)&#10;                    delay(DISPLAY_UPDATE_INTERVAL)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Update location data for display purposes only&#10;     * Does not affect validation logic&#10;     */&#10;    private suspend fun updateDisplayLocation() {&#10;        try {&#10;            // Update current address for display - menggunakan Geocoding API yang sudah diperbaiki&#10;            getCurrentAddressUseCase().onSuccess { address -&gt;&#10;                _uiState.value = _uiState.value.copy(currentUserAddress = address)&#10;                Log.d(TAG, &quot;Display address updated: $address&quot;)&#10;            }.onFailure { exception -&gt;&#10;                Log.w(TAG, &quot;Failed to get display address&quot;, exception)&#10;                // Set fallback address jika gagal&#10;                _uiState.value = _uiState.value.copy(currentUserAddress = &quot;Mengambil alamat...&quot;)&#10;            }&#10;&#10;            // Update current coordinates for map display - menggunakan database fallback untuk display&#10;            getCurrentCoordinatesUseCase(useRealTimeGPS = false).onSuccess { coordinates -&gt;&#10;                val (latitude, longitude) = coordinates&#10;                _uiState.value = _uiState.value.copy(&#10;                    currentUserLatitude = latitude,&#10;                    currentUserLongitude = longitude&#10;                )&#10;                Log.d(TAG, &quot;Display coordinates updated: $latitude, $longitude&quot;)&#10;            }.onFailure { exception -&gt;&#10;                Log.w(TAG, &quot;Failed to get display coordinates&quot;, exception)&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Unexpected error in updateDisplayLocation&quot;, e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Handle work mode selection with Pick on Map integration&#10;     * UPDATED: Added geofence cleanup when switching modes&#10;     */&#10;    fun onWorkModeSelected(mode: String) {&#10;        Log.d(TAG, &quot;Work mode selected: $mode&quot;)&#10;&#10;        // Clean up any existing geofence before switching modes&#10;        Log.d(TAG, &quot;Cleaning up geofences before mode switch...&quot;)&#10;        geofenceManager.removeAllGeofences()&#10;&#10;        _uiState.value = _uiState.value.copy(&#10;            selectedWorkMode = mode,&#10;            isWfaModeActive = mode == &quot;WFA&quot; || mode == &quot;Work From Anywhere&quot;&#10;        )&#10;&#10;        viewModelScope.launch {&#10;            when (mode) {&#10;                &quot;WFA&quot;, &quot;Work From Anywhere&quot; -&gt; {&#10;                    // Reset previous WFA selection and enter Pick on Map mode&#10;                    _uiState.value = _uiState.value.copy(&#10;                        selectedWfaLocation = null,&#10;                        pickedLocation = null&#10;                    )&#10;                    onEnterPickOnMapMode()&#10;                    fetchWfaRecommendations()&#10;                }&#10;&#10;                &quot;Work From Home&quot;, &quot;WFH&quot; -&gt; {&#10;                    onExitPickOnMapMode()&#10;                    _uiState.value.wfhLocation?.let { wfhLocation -&gt;&#10;                        // Setup geofence for WFH location&#10;                        setupGeofence(wfhLocation)&#10;&#10;                        val wfhPoint = Point.fromLngLat(wfhLocation.longitude, wfhLocation.latitude)&#10;                        _uiState.value = _uiState.value.copy(&#10;                            mapAnimationTarget = MapAnimationTarget.AnimateToLocation(&#10;                                point = wfhPoint,&#10;                                zoomLevel = 15.0&#10;                            )&#10;                        )&#10;                        Log.d(TAG, &quot;Auto-focusing camera to WFH location and setting up geofence&quot;)&#10;                    }&#10;                }&#10;&#10;                &quot;Work From Office&quot;, &quot;WFO&quot; -&gt; {&#10;                    onExitPickOnMapMode()&#10;                    _uiState.value.wfoLocation?.let { wfoLocation -&gt;&#10;                        // Setup geofence for WFO location&#10;                        setupGeofence(wfoLocation)&#10;&#10;                        val wfoPoint = Point.fromLngLat(wfoLocation.longitude, wfoLocation.latitude)&#10;                        _uiState.value = _uiState.value.copy(&#10;                            mapAnimationTarget = MapAnimationTarget.AnimateToLocation(&#10;                                point = wfoPoint,&#10;                                zoomLevel = 15.0&#10;                            )&#10;                        )&#10;                        Log.d(TAG, &quot;Auto-focusing camera to WFO location and setting up geofence&quot;)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Fetch WFA recommendations based on current user location&#10;     * Menggunakan GPS real-time, bukan lokasi WFH yang tersimpan&#10;     */&#10;    private fun fetchWfaRecommendations() {&#10;        viewModelScope.launch {&#10;            try {&#10;                Log.d(TAG, &quot;Fetching WFA recommendations - getting fresh GPS location...&quot;)&#10;&#10;                // Set loading state for WFA recommendations&#10;                _uiState.value = _uiState.value.copy(isLoadingWfaRecommendations = true)&#10;&#10;                // PENTING: Gunakan GPS real-time untuk WFA recommendations&#10;                getCurrentCoordinatesUseCase(useRealTimeGPS = true).onSuccess { coordinates -&gt;&#10;                    val (lat, lng) = coordinates&#10;&#10;                    Log.d(TAG, &quot;Using GPS real-time location for WFA: $lat, $lng&quot;)&#10;&#10;                    getWfaRecommendationsUseCase(lat, lng).onSuccess { recommendations -&gt;&#10;                        _uiState.value = _uiState.value.copy(wfaRecommendations = recommendations)&#10;&#10;                        // Send event to zoom out and show all recommendations&#10;                        if (recommendations.isNotEmpty()) {&#10;                            val points =&#10;                                recommendations.map { Point.fromLngLat(it.longitude, it.latitude) }&#10;                            _uiState.value = _uiState.value.copy(&#10;                                mapAnimationTarget = MapAnimationTarget.AnimateToFitBounds(points)&#10;                            )&#10;                            Log.d(&#10;                                TAG,&#10;                                &quot;WFA recommendations fetched: ${recommendations.size} locations&quot;&#10;                            )&#10;                        } else {&#10;                            Log.w(TAG, &quot;No WFA recommendations found for GPS location: $lat, $lng&quot;)&#10;                        }&#10;                    }.onFailure { exception -&gt;&#10;                        Log.e(TAG, &quot;Failed to fetch WFA recommendations&quot;, exception)&#10;                        // Keep empty list on error&#10;                        _uiState.value = _uiState.value.copy(wfaRecommendations = emptyList())&#10;                    }&#10;&#10;                }.onFailure { exception -&gt;&#10;                    Log.e(TAG, &quot;Failed to get GPS location for WFA recommendations&quot;, exception)&#10;                    // Fallback to cached location if GPS fails&#10;                    val lat = _uiState.value.currentUserLatitude ?: return@launch&#10;                    val lng = _uiState.value.currentUserLongitude ?: return@launch&#10;&#10;                    Log.w(TAG, &quot;GPS failed, using cached location for WFA: $lat, $lng&quot;)&#10;&#10;                    getWfaRecommendationsUseCase(lat, lng).onSuccess { recommendations -&gt;&#10;                        _uiState.value = _uiState.value.copy(wfaRecommendations = recommendations)&#10;                        if (recommendations.isNotEmpty()) {&#10;                            val points =&#10;                                recommendations.map { Point.fromLngLat(it.longitude, it.latitude) }&#10;                            _uiState.value = _uiState.value.copy(&#10;                                mapAnimationTarget = MapAnimationTarget.AnimateToFitBounds(points)&#10;                            )&#10;                            Log.d(&#10;                                TAG,&#10;                                &quot;WFA recommendations fetched with cached location: ${recommendations.size} locations&quot;&#10;                            )&#10;                        }&#10;                    }.onFailure { exception -&gt;&#10;                        Log.e(&#10;                            TAG,&#10;                            &quot;Failed to fetch WFA recommendations with cached location&quot;,&#10;                            exception&#10;                        )&#10;                        _uiState.value = _uiState.value.copy(wfaRecommendations = emptyList())&#10;                    }&#10;                }&#10;&#10;                // Reset loading state&#10;                _uiState.value = _uiState.value.copy(isLoadingWfaRecommendations = false)&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Unexpected error in fetchWfaRecommendations&quot;, e)&#10;                _uiState.value = _uiState.value.copy(&#10;                    wfaRecommendations = emptyList(),&#10;                    isLoadingWfaRecommendations = false&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Handle WFA marker click - Updated to show marker details&#10;     */&#10;    fun onWfaMarkerClicked(recommendation: WfaRecommendation) {&#10;        Log.d(TAG, &quot;WFA Marker clicked: ${recommendation.name}&quot;)&#10;        _uiState.value = _uiState.value.copy(&#10;            selectedWfaLocation = recommendation,&#10;            selectedWfaMarkerInfo = recommendation // Show marker details&#10;        )&#10;&#10;        // Focus camera on selected WFA location&#10;        viewModelScope.launch {&#10;            val point = Point.fromLngLat(recommendation.longitude, recommendation.latitude)&#10;            _uiState.value = _uiState.value.copy(&#10;                mapAnimationTarget = MapAnimationTarget.AnimateToLocation(&#10;                    point,&#10;                    16.0&#10;                )&#10;            ) // Zoom closer for selected marker&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Handle WFA marker info dismissal&#10;     */&#10;    fun onDismissWfaMarkerInfo() {&#10;        Log.d(TAG, &quot;WFA marker info dialog dismissed&quot;)&#10;        _uiState.value = _uiState.value.copy(selectedWfaMarkerInfo = null)&#10;    }&#10;&#10;    /**&#10;     * Handle marker info dialog dismissal&#10;     */&#10;    fun onDismissMarkerInfo() {&#10;        Log.d(TAG, &quot;Marker info dialog dismissed&quot;)&#10;        _uiState.value = _uiState.value.copy(&#10;            selectedMarkerInfo = null,&#10;            selectedWfaMarkerInfo = null // Also dismiss WFA marker info&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Handle booking button click&#10;     */&#10;    fun onBookingClicked() {&#10;        if (_uiState.value.isWfaModeActive) {&#10;            _uiState.value.selectedWfaLocation?.let { wfaLocation -&gt;&#10;                Log.d(TAG, &quot;Booking WFA location: ${wfaLocation.name}&quot;)&#10;                // Navigate to WFA booking screen with location data (latitude and longitude only)&#10;                val route = Screen.WfaBooking.createRoute(&#10;                    latitude = wfaLocation.latitude,&#10;                    longitude = wfaLocation.longitude&#10;                    // address is no longer sent - WfaBookingViewModel will fetch it&#10;                )&#10;                viewModelScope.launch {&#10;                    _uiState.value = _uiState.value.copy(&#10;                        navigationTarget = NavigationTarget.WfaBooking(route)&#10;                    )&#10;                }&#10;            } ?: run {&#10;                Log.w(TAG, &quot;Booking clicked in WFA mode but no location selected.&quot;)&#10;            }&#10;        } else {&#10;            Log.d(TAG, &quot;Booking clicked for mode: ${_uiState.value.selectedWorkMode}&quot;)&#10;            // TODO: Implement booking logic for WFO/WFH&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Handle attendance button click - navigates to face scanner&#10;     * FIXED: Uses new Screen.FaceScanner.createRoute with action parameter&#10;     */&#10;    fun onAttendanceButtonClicked() {&#10;        // Use the reactive StateFlow value instead of recalculating&#10;        val isEnabled = _uiState.value.isButtonEnabled&#10;        val buttonText = _uiState.value.buttonText&#10;&#10;        if (!isEnabled) {&#10;            Log.d(TAG, &quot;Attendance button clicked but not enabled (geofence or server restriction)&quot;)&#10;            return&#10;        }&#10;&#10;        val isCheckIn = buttonText.contains(&quot;Check-in&quot;, ignoreCase = true)&#10;        val action = if (isCheckIn) &quot;checkin&quot; else &quot;checkout&quot;&#10;&#10;        Log.d(TAG, &quot;Attendance button clicked - $action&quot;)&#10;&#10;        // Update isCheckInMode state before navigation&#10;        _uiState.value = _uiState.value.copy(isCheckInMode = isCheckIn)&#10;&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(&#10;                navigationTarget = NavigationTarget.FaceScanner(isCheckIn)&#10;            )&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Handle face verification result - GATEWAY after face verification&#10;     * Called from FaceScannerScreen when verification is complete&#10;     */&#10;    fun onFaceVerificationResult(isSuccess: Boolean) {&#10;        Log.d(TAG, &quot;Face verification result: $isSuccess&quot;)&#10;&#10;        if (!isSuccess) {&#10;            Log.d(TAG, &quot;Face verification failed - aborting attendance process&quot;)&#10;            _uiState.value = _uiState.value.copy(&#10;                activeDialog = DialogState.Error(&quot;Verifikasi wajah gagal. Silakan coba lagi.&quot;)&#10;            )&#10;            return&#10;        }&#10;&#10;        // Check current mode and proceed accordingly&#10;        if (_uiState.value.isCheckInMode) {&#10;            proceedWithCheckIn()&#10;        } else {&#10;            proceedWithCheckOut()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Proceed with check-in after successful face verification&#10;     * FIXED: Added proper error message extraction from server response&#10;     */&#10;    private fun proceedWithCheckIn() {&#10;        viewModelScope.launch {&#10;            try {&#10;                Log.d(TAG, &quot;Proceeding with check-in after face verification&quot;)&#10;&#10;                // Clear any previous error&#10;                _uiState.value = _uiState.value.copy(activeDialog = null)&#10;&#10;                // Determine target location based on selected work mode&#10;                val targetLocation = when (_uiState.value.selectedWorkMode) {&#10;                    &quot;Work From Home&quot;, &quot;WFH&quot; -&gt; _uiState.value.wfhLocation&#10;                    &quot;Work From Office&quot;, &quot;WFO&quot; -&gt; _uiState.value.wfoLocation&#10;                    &quot;WFA&quot;, &quot;Work From Anywhere&quot; -&gt; {&#10;                        // For WFA, convert selectedWfaLocation to Location object&#10;                        _uiState.value.selectedWfaLocation?.let { wfaLocation -&gt;&#10;                            Location(&#10;                                locationId = 0, // WFA locations don't have fixed IDs&#10;                                latitude = wfaLocation.latitude,&#10;                                longitude = wfaLocation.longitude,&#10;                                radius = 100, // Default radius for WFA&#10;                                description = wfaLocation.name,&#10;                                category = wfaLocation.category&#10;                            )&#10;                        }&#10;                    }&#10;&#10;                    else -&gt; _uiState.value.wfoLocation // Default to WFO&#10;                }&#10;&#10;                if (targetLocation == null) {&#10;                    _uiState.value = _uiState.value.copy(&#10;                        activeDialog = DialogState.Error(&quot;Target location not available for ${_uiState.value.selectedWorkMode}. Please try again.&quot;)&#10;                    )&#10;                    return@launch&#10;                }&#10;&#10;                // Get user info for the request&#10;                getLoggedInUserUseCase().collect { user -&gt;&#10;                    if (user == null) {&#10;                        _uiState.value = _uiState.value.copy(&#10;                            activeDialog = DialogState.Error(&quot;User information not available. Please try again.&quot;)&#10;                        )&#10;                        return@collect&#10;                    }&#10;&#10;                    // Map work mode to correct category_id&#10;                    val categoryId = when (_uiState.value.selectedWorkMode) {&#10;                        &quot;Work From Office&quot;, &quot;WFO&quot; -&gt; 1  // Work From Office&#10;                        &quot;Work From Home&quot;, &quot;WFH&quot; -&gt; 2    // Work From Home&#10;                        &quot;WFA&quot;, &quot;Work From Anywhere&quot; -&gt; 3 // Work From Anywhere&#10;                        else -&gt; 1 // Default to WFO&#10;                    }&#10;&#10;                    // Create attendance request model with proper parameters&#10;                    val attendanceRequest = AttendanceRequestModel(&#10;                        categoryId = categoryId, // Use correct category ID based on work mode&#10;                        latitude = 0.0, // Will be updated by UseCase with real-time GPS&#10;                        longitude = 0.0, // Will be updated by UseCase with real-time GPS&#10;                        notes = &quot;Check-in via mobile app&quot;,&#10;                        bookingId = null, // No booking for regular check-in&#10;                        type = &quot;checkin&quot;&#10;                    )&#10;&#10;                    // Call CheckInUseCase with both request and target location&#10;                    checkInUseCase(attendanceRequest, targetLocation).onSuccess { activeSession -&gt;&#10;                        Log.d(TAG, &quot;Check-in successful: $activeSession&quot;)&#10;&#10;                        // Refresh today's status to get updated data&#10;                        fetchTodayStatus()&#10;&#10;                        // Send success event to UI with appropriate message&#10;                        _uiState.value = _uiState.value.copy(&#10;                            activeDialog = DialogState.Success(&quot;Check-in berhasil! Selamat bekerja hari ini.&quot;)&#10;                        )&#10;&#10;                    }.onFailure { exception -&gt;&#10;                        Log.e(TAG, &quot;Check-in failed: ${exception.message}&quot;, exception)&#10;&#10;                        // Extract the actual error message from the exception&#10;                        val errorMessage = exception.message ?: &quot;Check-in gagal. Silakan coba lagi.&quot;&#10;                        &#10;                        // Send error event to UI with the actual server message&#10;                        _uiState.value = _uiState.value.copy(&#10;                            activeDialog = DialogState.Error(errorMessage)&#10;                        )&#10;                    }&#10;                }&#10;&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error in proceedWithCheckIn&quot;, e)&#10;                _uiState.value = _uiState.value.copy(&#10;                    activeDialog = DialogState.Error(&quot;Unexpected error during check-in: ${e.message}&quot;)&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Proceed with check-out after successful face verification&#10;     * FIXED: Added proper error message extraction from server response&#10;     */&#10;    private fun proceedWithCheckOut() {&#10;        viewModelScope.launch {&#10;            try {&#10;                Log.d(TAG, &quot;Proceeding with check-out after face verification&quot;)&#10;&#10;                // Clear any previous error&#10;                _uiState.value = _uiState.value.copy(activeDialog = null)&#10;&#10;                // Call CheckOutUseCase - it will handle everything internally&#10;                checkOutUseCase().onSuccess { activeSession -&gt;&#10;                    Log.d(TAG, &quot;Check-out successful: $activeSession&quot;)&#10;&#10;                    // Refresh today's status to get updated data&#10;                    fetchTodayStatus()&#10;&#10;                    // Send success event to UI with appropriate message&#10;                    _uiState.value = _uiState.value.copy(&#10;                        activeDialog = DialogState.Success(&quot;Check-out berhasil! Terima kasih atas kerja keras Anda hari ini.&quot;)&#10;                    )&#10;&#10;                }.onFailure { exception -&gt;&#10;                    Log.e(TAG, &quot;Check-out failed: ${exception.message}&quot;, exception)&#10;&#10;                    // Extract the actual error message from the exception&#10;                    val errorMessage = exception.message ?: &quot;Check-out gagal. Silakan coba lagi.&quot;&#10;                    &#10;                    // Send error event to UI with the actual server message&#10;                    _uiState.value = _uiState.value.copy(&#10;                        activeDialog = DialogState.Error(errorMessage)&#10;                    )&#10;                }&#10;&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error in proceedWithCheckOut&quot;, e)&#10;                _uiState.value = _uiState.value.copy(&#10;                    activeDialog = DialogState.Error(&quot;Unexpected error during check-out: ${e.message}&quot;)&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Clear error message&#10;     */&#10;    fun clearError() {&#10;        _uiState.value = _uiState.value.copy(activeDialog = null)&#10;    }&#10;&#10;    /**&#10;     * Handle map marker click&#10;     */&#10;    fun onMarkerClicked(location: Location) {&#10;        Log.d(TAG, &quot;Marker clicked for location: ${location.description}&quot;)&#10;        _uiState.value = _uiState.value.copy(selectedMarkerInfo = location)&#10;    }&#10;&#10;    /**&#10;     * Handle focus location button click&#10;     * This should ONLY focus on current user location, not work mode locations&#10;     * Always gets fresh location data when clicked&#10;     */&#10;    fun onFocusLocationClicked() {&#10;        Log.d(TAG, &quot;=== FOCUS LOCATION BUTTON CLICKED ===&quot;)&#10;        Log.d(TAG, &quot;Current work mode: ${_uiState.value.selectedWorkMode}&quot;)&#10;        Log.d(TAG, &quot;Current WFH location: ${_uiState.value.wfhLocation}&quot;)&#10;        Log.d(TAG, &quot;Getting fresh GPS coordinates...&quot;)&#10;&#10;        viewModelScope.launch {&#10;            try {&#10;                // PENTING: Gunakan GPS real-time, bukan dari database&#10;                getCurrentCoordinatesUseCase(useRealTimeGPS = true).onSuccess { coordinates -&gt;&#10;                    val (latitude, longitude) = coordinates&#10;&#10;                    Log.d(TAG, &quot;=== FRESH GPS COORDINATES RECEIVED ===&quot;)&#10;                    Log.d(TAG, &quot;GPS Real-time Latitude: $latitude&quot;)&#10;                    Log.d(TAG, &quot;GPS Real-time Longitude: $longitude&quot;)&#10;                    Log.d(TAG, &quot;WFH Latitude: ${_uiState.value.wfhLocation?.latitude}&quot;)&#10;                    Log.d(TAG, &quot;WFH Longitude: ${_uiState.value.wfhLocation?.longitude}&quot;)&#10;&#10;                    // Pastikan koordinat berbeda dari WFH&#10;                    if (latitude == _uiState.value.wfhLocation?.latitude &amp;&amp;&#10;                        longitude == _uiState.value.wfhLocation?.longitude&#10;                    ) {&#10;                        Log.w(TAG, &quot;WARNING: GPS coordinates sama dengan WFH location!&quot;)&#10;                        Log.w(TAG, &quot;Ini mungkin karena GPS masih menggunakan cached location&quot;)&#10;                    }&#10;&#10;                    // Update state untuk immediate display&#10;                    _uiState.value = _uiState.value.copy(&#10;                        currentUserLatitude = latitude,&#10;                        currentUserLongitude = longitude&#10;                    )&#10;&#10;                    // Send map animation event&#10;                    val focusPoint = Point.fromLngLat(longitude, latitude)&#10;                    _uiState.value = _uiState.value.copy(&#10;                        mapAnimationTarget = MapAnimationTarget.AnimateToLocation(&#10;                            point = focusPoint,&#10;                            zoomLevel = 15.0&#10;                        )&#10;                    )&#10;&#10;                    Log.d(TAG, &quot;=== MAP ANIMATION SENT ===&quot;)&#10;                    Log.d(TAG, &quot;Focus point: ${focusPoint.latitude()}, ${focusPoint.longitude()}&quot;)&#10;                    Log.d(TAG, &quot;This should be your CURRENT GPS location, NOT your home location!&quot;)&#10;                }.onFailure { exception -&gt;&#10;                    Log.e(TAG, &quot;=== GPS LOCATION FAILED ===&quot;)&#10;                    Log.e(TAG, &quot;Failed to get current GPS location: ${exception.message}&quot;)&#10;                    _uiState.value = _uiState.value.copy(&#10;                        mapAnimationTarget = MapAnimationTarget.ShowLocationError&#10;                    )&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;=== UNEXPECTED ERROR ===&quot;)&#10;                Log.e(TAG, &quot;Error in onFocusLocationClicked: ${e.message}&quot;)&#10;                _uiState.value = _uiState.value.copy(&#10;                    mapAnimationTarget = MapAnimationTarget.ShowLocationError&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Called when the map is ready to receive commands&#10;     * This will trigger initial camera focus to WFO location&#10;     */&#10;    fun onMapReady() {&#10;        Log.d(TAG, &quot;Map is ready, focusing to WFO location&quot;)&#10;        viewModelScope.launch {&#10;            _uiState.value.wfoLocation?.let { wfoLocation -&gt;&#10;                val wfoPoint = Point.fromLngLat(wfoLocation.longitude, wfoLocation.latitude)&#10;                _uiState.value = _uiState.value.copy(&#10;                    mapAnimationTarget = MapAnimationTarget.AnimateToLocation(&#10;                        point = wfoPoint,&#10;                        zoomLevel = 15.0&#10;                    )&#10;                )&#10;                Log.d(TAG, &quot;Initial camera focus sent to WFO location&quot;)&#10;            } ?: run {&#10;                Log.w(TAG, &quot;WFO location not available for initial focus&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Start location updates for display purposes&#10;     * This should be called by UI when location permissions are granted&#10;     */&#10;    fun startLocationUpdates() {&#10;        Log.d(TAG, &quot;Starting location updates for display&quot;)&#10;        startDisplayLocationUpdates()&#10;    }&#10;&#10;    /**&#10;     * Handle selected location from LocationSearchScreen&#10;     */&#10;    fun onLocationSelected(location: LocationResult) {&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(&#10;                selectedWfaLocation = WfaRecommendation(&#10;                    name = location.placeName,&#10;                    address = location.address,&#10;                    latitude = location.latitude,&#10;                    longitude = location.longitude,&#10;                    score = 0.0, // Default score for manually selected location&#10;                    label = &quot;Manual Selection&quot;, // Default label for manually selected location&#10;                    category = &quot;Custom&quot;, // Default category for manually selected location&#10;                    distance = 0.0 // Distance will be calculated based on current location&#10;                ),&#10;                isWfaModeActive = true&#10;            )&#10;&#10;            // Animate map to the selected location&#10;            _uiState.value = _uiState.value.copy(&#10;                mapAnimationTarget = MapAnimationTarget.AnimateToLocation(&#10;                    Point.fromLngLat(location.longitude, location.latitude),&#10;                    15.0&#10;                )&#10;            )&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Enter Pick on Map mode - enables crosshair and map interaction&#10;     */&#10;    fun onEnterPickOnMapMode() {&#10;        Log.d(TAG, &quot;Entering Pick on Map mode&quot;)&#10;        _uiState.value = _uiState.value.copy(&#10;            isPickOnMapModeActive = true,&#10;            pickedLocation = null // Reset any previously picked location&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Exit Pick on Map mode - disables crosshair and map interaction&#10;     */&#10;    fun onExitPickOnMapMode() {&#10;        Log.d(TAG, &quot;Exiting Pick on Map mode&quot;)&#10;        _uiState.value = _uiState.value.copy(&#10;            isPickOnMapModeActive = false,&#10;            pickedLocation = null&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Handle map idle event - called when user stops moving the map&#10;     * Performs reverse geocoding for the center point of the map&#10;     */&#10;    fun onMapIdle(centerPoint: Point) {&#10;        // Only perform reverse geocoding if Pick on Map mode is active&#10;        if (!_uiState.value.isPickOnMapModeActive) return&#10;&#10;        viewModelScope.launch {&#10;            try {&#10;                Log.d(&#10;                    TAG,&#10;                    &quot;Map idle detected in Pick on Map mode: ${centerPoint.latitude()}, ${centerPoint.longitude()}&quot;&#10;                )&#10;&#10;                // Perform reverse geocoding for the center point&#10;                reverseGeocodeUseCase(&#10;                    latitude = centerPoint.latitude(),&#10;                    longitude = centerPoint.longitude()&#10;                ).onSuccess { locationResult -&gt;&#10;                    Log.d(TAG, &quot;Reverse geocoding successful: ${locationResult.placeName}&quot;)&#10;&#10;                    // Update the picked location&#10;                    _uiState.value = _uiState.value.copy(&#10;                        pickedLocation = locationResult,&#10;                        selectedWfaLocation = WfaRecommendation(&#10;                            name = locationResult.placeName,&#10;                            address = locationResult.address,&#10;                            latitude = locationResult.latitude,&#10;                            longitude = locationResult.longitude,&#10;                            score = 0.0,&#10;                            label = &quot;Picked on Map&quot;,&#10;                            category = &quot;Manual Selection&quot;,&#10;                            distance = 0.0&#10;                        )&#10;                    )&#10;                }.onFailure { exception -&gt;&#10;                    Log.e(TAG, &quot;Reverse geocoding failed&quot;, exception)&#10;&#10;                    // Don't create fallback location, instead show error and keep picked location null&#10;                    _uiState.value = _uiState.value.copy(&#10;                        pickedLocation = null, // Ensure picked location is null&#10;                        selectedWfaLocation = null, // Clear any selected WFA location&#10;                        // Show error message in BottomSheet&#10;                        error = &quot;Gagal mendapatkan detail lokasi. Periksa koneksi Anda.&quot;&#10;                    )&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Unexpected error in onMapIdle&quot;, e)&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        displayLocationJob?.cancel()&#10;&#10;        // Clean up geofence when ViewModel is cleared&#10;        _uiState.value.targetLocation?.let { location -&gt;&#10;            geofenceManager.removeGeofence(location.locationId.toString())&#10;        }&#10;&#10;        Log.d(TAG, &quot;ViewModel cleared, display location tracking stopped&quot;)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>