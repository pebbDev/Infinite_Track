<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/data/face/FaceDetectorHelper.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/data/face/FaceDetectorHelper.kt" />
              <option name="originalContent" value="package com.example.infinite_track.data.face&#10;&#10;import android.graphics.Bitmap&#10;import androidx.annotation.OptIn&#10;import androidx.camera.core.ExperimentalGetImage&#10;import androidx.camera.core.ImageProxy&#10;import com.google.mlkit.vision.common.InputImage&#10;import com.google.mlkit.vision.face.Face&#10;import com.google.mlkit.vision.face.FaceDetection&#10;import com.google.mlkit.vision.face.FaceDetector&#10;import com.google.mlkit.vision.face.FaceDetectorOptions&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;/**&#10; * Enum for liveness detection results&#10; * Provides progressive feedback for user guidance&#10; */&#10;enum class LivenessResult {&#10;    SUCCESS,    // Liveness detected successfully&#10;    IN_PROGRESS, // User is on the right track, needs slight adjustment&#10;    FAILURE     // Liveness not detected&#10;}&#10;&#10;/**&#10; * Helper class for ML Kit Face Detection operations&#10; * Handles face detection, liveness verification (blink/smile), and face extraction&#10; * FIXED: Added proper reinitialization support&#10; */&#10;@Singleton&#10;class FaceDetectorHelper @Inject constructor() {&#10;&#10;    companion object {&#10;        // More flexible thresholds for progressive feedback&#10;        private const val BLINK_HIGH_THRESHOLD = 0.4f // Original threshold for SUCCESS&#10;        private const val BLINK_LOW_THRESHOLD = 0.6f  // Lower threshold for IN_PROGRESS&#10;&#10;        private const val SMILE_HIGH_THRESHOLD = 0.7f // Original threshold for SUCCESS&#10;        private const val SMILE_MEDIUM_THRESHOLD = 0.4f // Medium threshold for IN_PROGRESS&#10;    }&#10;&#10;    // PERBAIKAN: Buat detector nullable dan reinitializable&#10;    private var _faceDetector: FaceDetector? = null&#10;&#10;    // Property untuk mengakses detector yang selalu valid&#10;    private val faceDetector: FaceDetector&#10;        get() {&#10;            // Jika detector null atau sudah closed, buat yang baru&#10;            if (_faceDetector == null) {&#10;                println(&quot;FaceDetectorHelper: Creating new ML Kit detector instance&quot;)&#10;                _faceDetector = createNewDetector()&#10;            }&#10;            return _faceDetector!!&#10;        }&#10;&#10;    /**&#10;     * Create new ML Kit Face Detector instance&#10;     */&#10;    private fun createNewDetector(): FaceDetector {&#10;        val options = FaceDetectorOptions.Builder()&#10;            .setPerformanceMode(FaceDetectorOptions.PERFORMANCE_MODE_FAST)&#10;            .setLandmarkMode(FaceDetectorOptions.LANDMARK_MODE_ALL)&#10;            .setClassificationMode(FaceDetectorOptions.CLASSIFICATION_MODE_ALL)&#10;            .setMinFaceSize(0.15f) // Minimum face size relative to image&#10;            .enableTracking() // Enable face tracking for better performance&#10;            .build()&#10;&#10;        return FaceDetection.getClient(options)&#10;    }&#10;&#10;    /**&#10;     * Force reinitialize detector - call this when reset is needed&#10;     */&#10;    fun reinitialize() {&#10;        println(&quot;FaceDetectorHelper: Force reinitializing detector...&quot;)&#10;        try {&#10;            _faceDetector?.close()&#10;        } catch (e: Exception) {&#10;            println(&quot;FaceDetectorHelper: Error closing old detector: ${e.message}&quot;)&#10;        }&#10;        _faceDetector = null&#10;        // Detector akan dibuat ulang saat pertama kali diakses&#10;        println(&quot;FaceDetectorHelper: Detector marked for reinitialization&quot;)&#10;    }&#10;&#10;    /**&#10;     * Detects faces in the given image frame&#10;     * @param imageProxy Camera image frame from CameraX&#10;     * @param onResult Callback with detection result&#10;     */&#10;    @OptIn(ExperimentalGetImage::class)&#10;    fun detect(imageProxy: ImageProxy, onResult: (Result&lt;Face&gt;) -&gt; Unit) {&#10;        val mediaImage = imageProxy.image&#10;        if (mediaImage != null) {&#10;            val image = InputImage.fromMediaImage(mediaImage, imageProxy.imageInfo.rotationDegrees)&#10;&#10;            try {&#10;                // Gunakan property yang akan otomatis reinitialize jika perlu&#10;                val detector = faceDetector&#10;&#10;                detector.process(image)&#10;                    .addOnSuccessListener { faces -&gt;&#10;                        println(&quot;ML Kit face detection completed. Found ${faces.size} faces&quot;)&#10;                        if (faces.isNotEmpty()) {&#10;                            // Return the first (largest) detected face&#10;                            val largestFace =&#10;                                faces.maxByOrNull { it.boundingBox.width() * it.boundingBox.height() }&#10;                            if (largestFace != null) {&#10;                                println(&quot;Largest face found at: ${largestFace.boundingBox}&quot;)&#10;                                onResult(Result.success(largestFace))&#10;                            } else {&#10;                                println(&quot;No valid face detected despite faces list not empty&quot;)&#10;                                onResult(Result.failure(Exception(&quot;No valid face detected&quot;)))&#10;                            }&#10;                        } else {&#10;                            println(&quot;No faces detected in current frame&quot;)&#10;                            onResult(Result.failure(Exception(&quot;No faces detected&quot;)))&#10;                        }&#10;                    }&#10;                    .addOnFailureListener { exception -&gt;&#10;                        println(&quot;ML Kit face detection failed: ${exception.message}&quot;)&#10;&#10;                        // PERBAIKAN: Jika detector closed, coba reinitialize&#10;                        if (exception.message?.contains(&quot;closed&quot;) == true) {&#10;                            println(&quot;FaceDetectorHelper: Detector was closed, reinitializing...&quot;)&#10;                            reinitialize()&#10;                            onResult(Result.failure(Exception(&quot;Detector was closed, please try again&quot;)))&#10;                        } else {&#10;                            onResult(Result.failure(exception))&#10;                        }&#10;                    }&#10;                    .addOnCompleteListener {&#10;                        // Clean up resources - ALWAYS close imageProxy here&#10;                        imageProxy.close()&#10;                        println(&quot;ImageProxy closed after ML Kit processing&quot;)&#10;                    }&#10;            } catch (e: Exception) {&#10;                println(&quot;FaceDetectorHelper: Exception during detection: ${e.message}&quot;)&#10;                if (e.message?.contains(&quot;closed&quot;) == true) {&#10;                    println(&quot;FaceDetectorHelper: Detector was closed, reinitializing...&quot;)&#10;                    reinitialize()&#10;                }&#10;                onResult(Result.failure(e))&#10;                imageProxy.close()&#10;            }&#10;        } else {&#10;            println(&quot;MediaImage is null in imageProxy&quot;)&#10;            onResult(Result.failure(Exception(&quot;Image is null&quot;)))&#10;            imageProxy.close()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Verifies if the person is blinking (liveness detection) with progressive feedback&#10;     * @param face Detected face from ML Kit&#10;     * @return LivenessResult indicating blink detection status&#10;     */&#10;    fun verifyBlink(face: Face): LivenessResult {&#10;        val leftEyeOpenProbability = face.leftEyeOpenProbability&#10;        val rightEyeOpenProbability = face.rightEyeOpenProbability&#10;&#10;        return if (leftEyeOpenProbability != null &amp;&amp; rightEyeOpenProbability != null) {&#10;            val avgEyeOpenProbability = (leftEyeOpenProbability + rightEyeOpenProbability) / 2f&#10;&#10;            println(&quot;DEBUG: Blink detection - Left eye: $leftEyeOpenProbability, Right eye: $rightEyeOpenProbability, Average: $avgEyeOpenProbability&quot;)&#10;&#10;            when {&#10;                // SUCCESS: Both eyes clearly closed (blinking)&#10;                leftEyeOpenProbability &lt; BLINK_HIGH_THRESHOLD &amp;&amp; rightEyeOpenProbability &lt; BLINK_HIGH_THRESHOLD -&gt; {&#10;                    println(&quot;DEBUG: Blink SUCCESS - Both eyes closed&quot;)&#10;                    LivenessResult.SUCCESS&#10;                }&#10;                // IN_PROGRESS: One eye closed or both eyes partially closed&#10;                avgEyeOpenProbability &lt; BLINK_LOW_THRESHOLD -&gt; {&#10;                    println(&quot;DEBUG: Blink IN_PROGRESS - Getting closer to blinking&quot;)&#10;                    LivenessResult.IN_PROGRESS&#10;                }&#10;                // FAILURE: Eyes too open&#10;                else -&gt; {&#10;                    println(&quot;DEBUG: Blink FAILURE - Eyes still open&quot;)&#10;                    LivenessResult.FAILURE&#10;                }&#10;            }&#10;        } else {&#10;            println(&quot;DEBUG: Blink FAILURE - Eye probabilities not available&quot;)&#10;            LivenessResult.FAILURE // Cannot determine blink if probabilities are not available&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Verifies if the person is smiling (liveness detection) with progressive feedback&#10;     * @param face Detected face from ML Kit&#10;     * @return LivenessResult indicating smile detection status&#10;     */&#10;    fun verifySmile(face: Face): LivenessResult {&#10;        val smilingProbability = face.smilingProbability&#10;&#10;        return if (smilingProbability != null) {&#10;            println(&quot;DEBUG: Smile detection - Probability: $smilingProbability&quot;)&#10;&#10;            when {&#10;                // SUCCESS: Strong smile detected&#10;                smilingProbability &gt; SMILE_HIGH_THRESHOLD -&gt; {&#10;                    println(&quot;DEBUG: Smile SUCCESS - Strong smile detected&quot;)&#10;                    LivenessResult.SUCCESS&#10;                }&#10;                // IN_PROGRESS: Moderate smile, encourage user to smile more&#10;                smilingProbability &gt; SMILE_MEDIUM_THRESHOLD -&gt; {&#10;                    println(&quot;DEBUG: Smile IN_PROGRESS - Moderate smile, needs more&quot;)&#10;                    LivenessResult.IN_PROGRESS&#10;                }&#10;                // FAILURE: Little to no smile&#10;                else -&gt; {&#10;                    println(&quot;DEBUG: Smile FAILURE - Not smiling enough&quot;)&#10;                    LivenessResult.FAILURE&#10;                }&#10;            }&#10;        } else {&#10;            println(&quot;DEBUG: Smile FAILURE - Smile probability not available&quot;)&#10;            LivenessResult.FAILURE // Cannot determine smile if probability is not available&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Extracts and preprocesses face bitmap for consistent embedding generation&#10;     * @param face Detected face from ML Kit&#10;     * @param image Source bitmap from camera&#10;     * @return Preprocessed face bitmap or null if extraction fails&#10;     */&#10;    fun extractFaceBitmap(face: Face, image: Bitmap): Bitmap? {&#10;        return try {&#10;            val boundingBox = face.boundingBox&#10;&#10;            // DEBUG: Log original face detection info&#10;            println(&quot;DEBUG FaceDetectorHelper: Original bounding box: $boundingBox&quot;)&#10;            println(&quot;DEBUG FaceDetectorHelper: Source image size: ${image.width}x${image.height}&quot;)&#10;&#10;            // Add padding around the face for better context (10% on each side)&#10;            val padding = (boundingBox.width() * 0.1f).toInt()&#10;&#10;            // Calculate expanded bounding box with padding&#10;            val left = maxOf(0, boundingBox.left - padding)&#10;            val top = maxOf(0, boundingBox.top - padding)&#10;            val right = minOf(image.width, boundingBox.right + padding)&#10;            val bottom = minOf(image.height, boundingBox.bottom + padding)&#10;&#10;            println(&quot;DEBUG FaceDetectorHelper: Padded coordinates - left:$left, top:$top, right:$right, bottom:$bottom&quot;)&#10;            println(&quot;DEBUG FaceDetectorHelper: Crop dimensions: ${right - left}x${bottom - top}&quot;)&#10;&#10;            // Validate that we have a valid crop area&#10;            if (left &lt; right &amp;&amp; top &lt; bottom) {&#10;                // Extract face with padding&#10;                val croppedBitmap =&#10;                    Bitmap.createBitmap(image, left, top, right - left, bottom - top)&#10;                println(&quot;DEBUG FaceDetectorHelper: Cropped bitmap size: ${croppedBitmap.width}x${croppedBitmap.height}&quot;)&#10;&#10;                // KUNCI PERBAIKAN: Standardisasi ukuran dan format&#10;                val standardizedBitmap = standardizeFaceBitmap(croppedBitmap)&#10;                println(&quot;DEBUG FaceDetectorHelper: Standardized bitmap size: ${standardizedBitmap.width}x${standardizedBitmap.height}&quot;)&#10;&#10;                // Clean up intermediate bitmap&#10;                if (croppedBitmap != standardizedBitmap) {&#10;                    croppedBitmap.recycle()&#10;                }&#10;&#10;                standardizedBitmap&#10;            } else {&#10;                println(&quot;DEBUG FaceDetectorHelper: Invalid crop area - left:$left &gt;= right:$right or top:$top &gt;= bottom:$bottom&quot;)&#10;                null&#10;            }&#10;        } catch (e: Exception) {&#10;            println(&quot;DEBUG FaceDetectorHelper: Error extracting face bitmap: ${e.message}&quot;)&#10;            e.printStackTrace()&#10;            null&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Standardizes face bitmap to consistent size and format&#10;     * This ensures consistent preprocessing for both profile and camera images&#10;     */&#10;    private fun standardizeFaceBitmap(faceBitmap: Bitmap): Bitmap {&#10;        // PERBAIKAN: Gunakan ukuran yang sama dengan FaceProcessor (112x112)&#10;        val standardWidth = 112  // Sama dengan IMAGE_SIZE di FaceProcessor&#10;        val standardHeight = 112  // Sama dengan IMAGE_SIZE di FaceProcessor&#10;&#10;        return try {&#10;            // Resize to standard dimensions with high quality&#10;            Bitmap.createScaledBitmap(faceBitmap, standardWidth, standardHeight, true)&#10;        } catch (e: Exception) {&#10;            println(&quot;Error standardizing face bitmap: ${e.message}&quot;)&#10;            faceBitmap // Return original if standardization fails&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Checks if a face is well-positioned for verification&#10;     * @param face Detected face&#10;     * @param imageWidth Width of the camera frame&#10;     * @param imageHeight Height of the camera frame&#10;     * @return true if face is properly positioned&#10;     */&#10;    fun isFaceWellPositioned(face: Face, imageWidth: Int, imageHeight: Int): Boolean {&#10;        val boundingBox = face.boundingBox&#10;        val faceWidth = boundingBox.width()&#10;        val faceHeight = boundingBox.height()&#10;&#10;        // Check if face is not too small or too large&#10;        val minFaceSize = minOf(imageWidth, imageHeight) * 0.2f&#10;        val maxFaceSize = minOf(imageWidth, imageHeight) * 0.8f&#10;        val faceSize = minOf(faceWidth, faceHeight)&#10;&#10;        if (faceSize &lt; minFaceSize || faceSize &gt; maxFaceSize) {&#10;            return false&#10;        }&#10;&#10;        // Check if face is roughly centered&#10;        val faceCenterX = boundingBox.centerX()&#10;        val faceCenterY = boundingBox.centerY()&#10;        val imageCenterX = imageWidth / 2f&#10;        val imageCenterY = imageHeight / 2f&#10;&#10;        val maxOffsetX = imageWidth * 0.25f&#10;        val maxOffsetY = imageHeight * 0.25f&#10;&#10;        return kotlin.math.abs(faceCenterX - imageCenterX) &lt; maxOffsetX &amp;&amp;&#10;                kotlin.math.abs(faceCenterY - imageCenterY) &lt; maxOffsetY&#10;    }&#10;&#10;    /**&#10;     * Clean up resources when done&#10;     * PERBAIKAN: Tambahkan null check&#10;     */&#10;    fun release() {&#10;        println(&quot;FaceDetectorHelper: Releasing detector resources&quot;)&#10;        try {&#10;            _faceDetector?.close()&#10;            _faceDetector = null&#10;            println(&quot;FaceDetectorHelper: Detector resources released successfully&quot;)&#10;        } catch (e: Exception) {&#10;            println(&quot;FaceDetectorHelper: Error during release: ${e.message}&quot;)&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.infinite_track.data.face&#10;&#10;import android.graphics.Bitmap&#10;import androidx.annotation.OptIn&#10;import androidx.camera.core.ExperimentalGetImage&#10;import androidx.camera.core.ImageProxy&#10;import com.google.mlkit.vision.common.InputImage&#10;import com.google.mlkit.vision.face.Face&#10;import com.google.mlkit.vision.face.FaceDetection&#10;import com.google.mlkit.vision.face.FaceDetector&#10;import com.google.mlkit.vision.face.FaceDetectorOptions&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;/**&#10; * Enum for liveness detection results&#10; * Provides progressive feedback for user guidance&#10; */&#10;enum class LivenessResult {&#10;    SUCCESS,    // Liveness detected successfully&#10;    IN_PROGRESS, // User is on the right track, needs slight adjustment&#10;    FAILURE     // Liveness not detected&#10;}&#10;&#10;/**&#10; * Helper class for ML Kit Face Detection operations&#10; * Handles face detection, liveness verification (blink/smile), and face extraction&#10; * FIXED: Added proper reinitialization support&#10; */&#10;@Singleton&#10;class FaceDetectorHelper @Inject constructor() {&#10;&#10;    companion object {&#10;        // More flexible thresholds for progressive feedback&#10;        private const val BLINK_HIGH_THRESHOLD = 0.4f // Original threshold for SUCCESS&#10;        private const val BLINK_LOW_THRESHOLD = 0.6f  // Lower threshold for IN_PROGRESS&#10;&#10;        private const val SMILE_HIGH_THRESHOLD = 0.7f // Original threshold for SUCCESS&#10;        private const val SMILE_MEDIUM_THRESHOLD = 0.4f // Medium threshold for IN_PROGRESS&#10;    }&#10;&#10;    // PERBAIKAN: Buat detector nullable dan reinitializable&#10;    private var _faceDetector: FaceDetector? = null&#10;&#10;    // Property untuk mengakses detector yang selalu valid&#10;    private val faceDetector: FaceDetector&#10;        get() {&#10;            // Jika detector null atau sudah closed, buat yang baru&#10;            if (_faceDetector == null) {&#10;                _faceDetector = createNewDetector()&#10;            }&#10;            return _faceDetector!!&#10;        }&#10;&#10;    /**&#10;     * Create new ML Kit Face Detector instance&#10;     */&#10;    private fun createNewDetector(): FaceDetector {&#10;        val options = FaceDetectorOptions.Builder()&#10;            .setPerformanceMode(FaceDetectorOptions.PERFORMANCE_MODE_FAST)&#10;            .setLandmarkMode(FaceDetectorOptions.LANDMARK_MODE_ALL)&#10;            .setClassificationMode(FaceDetectorOptions.CLASSIFICATION_MODE_ALL)&#10;            .setMinFaceSize(0.15f) // Minimum face size relative to image&#10;            .enableTracking() // Enable face tracking for better performance&#10;            .build()&#10;&#10;        return FaceDetection.getClient(options)&#10;    }&#10;&#10;    /**&#10;     * Force reinitialize detector - call this when reset is needed&#10;     */&#10;    fun reinitialize() {&#10;        try {&#10;            _faceDetector?.close()&#10;        } catch (e: Exception) {&#10;            // Silently handle close errors&#10;        }&#10;        _faceDetector = null&#10;        // Detector akan dibuat ulang saat pertama kali diakses&#10;    }&#10;&#10;    /**&#10;     * Detects faces in the given image frame&#10;     * @param imageProxy Camera image frame from CameraX&#10;     * @param onResult Callback with detection result&#10;     */&#10;    @OptIn(ExperimentalGetImage::class)&#10;    fun detect(imageProxy: ImageProxy, onResult: (Result&lt;Face&gt;) -&gt; Unit) {&#10;        val mediaImage = imageProxy.image&#10;        if (mediaImage != null) {&#10;            val image = InputImage.fromMediaImage(mediaImage, imageProxy.imageInfo.rotationDegrees)&#10;&#10;            try {&#10;                // Gunakan property yang akan otomatis reinitialize jika perlu&#10;                val detector = faceDetector&#10;&#10;                detector.process(image)&#10;                    .addOnSuccessListener { faces -&gt;&#10;                        if (faces.isNotEmpty()) {&#10;                            // Return the first (largest) detected face&#10;                            val largestFace =&#10;                                faces.maxByOrNull { it.boundingBox.width() * it.boundingBox.height() }&#10;                            if (largestFace != null) {&#10;                                onResult(Result.success(largestFace))&#10;                            } else {&#10;                                onResult(Result.failure(Exception(&quot;No valid face detected&quot;)))&#10;                            }&#10;                        } else {&#10;                            onResult(Result.failure(Exception(&quot;No faces detected&quot;)))&#10;                        }&#10;                    }&#10;                    .addOnFailureListener { exception -&gt;&#10;                        // Jika detector closed, coba reinitialize&#10;                        if (exception.message?.contains(&quot;closed&quot;) == true) {&#10;                            reinitialize()&#10;                            onResult(Result.failure(Exception(&quot;Detector was closed, please try again&quot;)))&#10;                        } else {&#10;                            onResult(Result.failure(exception))&#10;                        }&#10;                    }&#10;                    .addOnCompleteListener {&#10;                        // Clean up resources - ALWAYS close imageProxy here&#10;                        imageProxy.close()&#10;                    }&#10;            } catch (e: Exception) {&#10;                if (e.message?.contains(&quot;closed&quot;) == true) {&#10;                    reinitialize()&#10;                }&#10;                onResult(Result.failure(e))&#10;                imageProxy.close()&#10;            }&#10;        } else {&#10;            onResult(Result.failure(Exception(&quot;Image is null&quot;)))&#10;            imageProxy.close()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Verifies if the person is blinking (liveness detection) with progressive feedback&#10;     * @param face Detected face from ML Kit&#10;     * @return LivenessResult indicating blink detection status&#10;     */&#10;    fun verifyBlink(face: Face): LivenessResult {&#10;        val leftEyeOpenProbability = face.leftEyeOpenProbability&#10;        val rightEyeOpenProbability = face.rightEyeOpenProbability&#10;&#10;        return if (leftEyeOpenProbability != null &amp;&amp; rightEyeOpenProbability != null) {&#10;            val avgEyeOpenProbability = (leftEyeOpenProbability + rightEyeOpenProbability) / 2f&#10;&#10;            when {&#10;                // SUCCESS: Both eyes clearly closed (blinking)&#10;                leftEyeOpenProbability &lt; BLINK_HIGH_THRESHOLD &amp;&amp; rightEyeOpenProbability &lt; BLINK_HIGH_THRESHOLD -&gt; {&#10;                    LivenessResult.SUCCESS&#10;                }&#10;                // IN_PROGRESS: One eye closed or both eyes partially closed&#10;                avgEyeOpenProbability &lt; BLINK_LOW_THRESHOLD -&gt; {&#10;                    LivenessResult.IN_PROGRESS&#10;                }&#10;                // FAILURE: Eyes too open&#10;                else -&gt; {&#10;                    LivenessResult.FAILURE&#10;                }&#10;            }&#10;        } else {&#10;            LivenessResult.FAILURE // Cannot determine blink if probabilities are not available&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Verifies if the person is smiling (liveness detection) with progressive feedback&#10;     * @param face Detected face from ML Kit&#10;     * @return LivenessResult indicating smile detection status&#10;     */&#10;    fun verifySmile(face: Face): LivenessResult {&#10;        val smilingProbability = face.smilingProbability&#10;&#10;        return if (smilingProbability != null) {&#10;            when {&#10;                // SUCCESS: Strong smile detected&#10;                smilingProbability &gt; SMILE_HIGH_THRESHOLD -&gt; {&#10;                    LivenessResult.SUCCESS&#10;                }&#10;                // IN_PROGRESS: Moderate smile, encourage user to smile more&#10;                smilingProbability &gt; SMILE_MEDIUM_THRESHOLD -&gt; {&#10;                    LivenessResult.IN_PROGRESS&#10;                }&#10;                // FAILURE: Little to no smile&#10;                else -&gt; {&#10;                    LivenessResult.FAILURE&#10;                }&#10;            }&#10;        } else {&#10;            LivenessResult.FAILURE // Cannot determine smile if probability is not available&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Extracts and preprocesses face bitmap for consistent embedding generation&#10;     * @param face Detected face from ML Kit&#10;     * @param image Source bitmap from camera&#10;     * @return Preprocessed face bitmap or null if extraction fails&#10;     */&#10;    fun extractFaceBitmap(face: Face, image: Bitmap): Bitmap? {&#10;        return try {&#10;            val boundingBox = face.boundingBox&#10;&#10;            // Add padding around the face for better context (10% on each side)&#10;            val padding = (boundingBox.width() * 0.1f).toInt()&#10;&#10;            // Calculate expanded bounding box with padding&#10;            val left = maxOf(0, boundingBox.left - padding)&#10;            val top = maxOf(0, boundingBox.top - padding)&#10;            val right = minOf(image.width, boundingBox.right + padding)&#10;            val bottom = minOf(image.height, boundingBox.bottom + padding)&#10;&#10;            // Validate that we have a valid crop area&#10;            if (left &lt; right &amp;&amp; top &lt; bottom) {&#10;                // Extract face with padding&#10;                val croppedBitmap =&#10;                    Bitmap.createBitmap(image, left, top, right - left, bottom - top)&#10;&#10;                // Standardisasi ukuran dan format&#10;                val standardizedBitmap = standardizeFaceBitmap(croppedBitmap)&#10;&#10;                // Clean up intermediate bitmap&#10;                if (croppedBitmap != standardizedBitmap) {&#10;                    croppedBitmap.recycle()&#10;                }&#10;&#10;                standardizedBitmap&#10;            } else {&#10;                null&#10;            }&#10;        } catch (e: Exception) {&#10;            null&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Standardizes face bitmap to consistent size and format&#10;     * This ensures consistent preprocessing for both profile and camera images&#10;     */&#10;    private fun standardizeFaceBitmap(faceBitmap: Bitmap): Bitmap {&#10;        // PERBAIKAN: Gunakan ukuran yang sama dengan FaceProcessor (112x112)&#10;        val standardWidth = 112  // Sama dengan IMAGE_SIZE di FaceProcessor&#10;        val standardHeight = 112  // Sama dengan IMAGE_SIZE di FaceProcessor&#10;&#10;        return try {&#10;            // Resize to standard dimensions with high quality&#10;            Bitmap.createScaledBitmap(faceBitmap, standardWidth, standardHeight, true)&#10;        } catch (e: Exception) {&#10;            faceBitmap // Return original if standardization fails&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Checks if a face is well-positioned for verification&#10;     * @param face Detected face&#10;     * @param imageWidth Width of the camera frame&#10;     * @param imageHeight Height of the camera frame&#10;     * @return true if face is properly positioned&#10;     */&#10;    fun isFaceWellPositioned(face: Face, imageWidth: Int, imageHeight: Int): Boolean {&#10;        val boundingBox = face.boundingBox&#10;        val faceWidth = boundingBox.width()&#10;        val faceHeight = boundingBox.height()&#10;&#10;        // Check if face is not too small or too large&#10;        val minFaceSize = minOf(imageWidth, imageHeight) * 0.2f&#10;        val maxFaceSize = minOf(imageWidth, imageHeight) * 0.8f&#10;        val faceSize = minOf(faceWidth, faceHeight)&#10;&#10;        if (faceSize &lt; minFaceSize || faceSize &gt; maxFaceSize) {&#10;            return false&#10;        }&#10;&#10;        // Check if face is roughly centered&#10;        val faceCenterX = boundingBox.centerX()&#10;        val faceCenterY = boundingBox.centerY()&#10;        val imageCenterX = imageWidth / 2f&#10;        val imageCenterY = imageHeight / 2f&#10;&#10;        val maxOffsetX = imageWidth * 0.25f&#10;        val maxOffsetY = imageHeight * 0.25f&#10;&#10;        return kotlin.math.abs(faceCenterX - imageCenterX) &lt; maxOffsetX &amp;&amp;&#10;                kotlin.math.abs(faceCenterY - imageCenterY) &lt; maxOffsetY&#10;    }&#10;&#10;    /**&#10;     * Clean up resources when done&#10;     * PERBAIKAN: Tambahkan null check&#10;     */&#10;    fun release() {&#10;        try {&#10;            _faceDetector?.close()&#10;            _faceDetector = null&#10;        } catch (e: Exception) {&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/data/repository/attendance/AttendanceRepositoryImpl.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/data/repository/attendance/AttendanceRepositoryImpl.kt" />
              <option name="originalContent" value="package com.example.infinite_track.data.repository.attendance&#10;&#10;import android.util.Log&#10;import com.example.infinite_track.data.mapper.attendance.toActiveSession&#10;import com.example.infinite_track.data.mapper.attendance.toDomain&#10;import com.example.infinite_track.data.mapper.attendance.toDto&#10;import com.example.infinite_track.data.soucre.local.preferences.AttendancePreference&#10;import com.example.infinite_track.data.soucre.network.request.CheckOutRequestDto&#10;import com.example.infinite_track.data.soucre.network.request.LocationEventRequest&#10;import com.example.infinite_track.data.soucre.network.retrofit.ApiService&#10;import com.example.infinite_track.domain.model.attendance.ActiveAttendanceSession&#10;import com.example.infinite_track.domain.model.attendance.AttendanceRequestModel&#10;import com.example.infinite_track.domain.model.attendance.TodayStatus&#10;import com.example.infinite_track.domain.repository.AttendanceRepository&#10;import kotlinx.coroutines.flow.first&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class AttendanceRepositoryImpl @Inject constructor(&#10;    private val apiService: ApiService,&#10;    private val attendancePreference: AttendancePreference&#10;) : AttendanceRepository {&#10;&#10;    companion object {&#10;        private const val TAG = &quot;AttendanceRepository&quot;&#10;    }&#10;&#10;    /**&#10;     * Gets the current day's attendance status&#10;     */&#10;    override suspend fun getTodayStatus(): Result&lt;TodayStatus&gt; {&#10;        return try {&#10;            val response = apiService.getTodayStatus()&#10;            if (response.success) {&#10;                // Convert DTO to domain model using mapper&#10;                Result.success(response.data.toDomain())&#10;            } else {&#10;                Result.failure(Exception(response.message ?: &quot;Unknown error&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error getting today's status&quot;, e)&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Performs check-in operation - simplified without client-side location validation&#10;     * Backend will handle all location validation&#10;     */&#10;    override suspend fun checkIn(request: AttendanceRequestModel): Result&lt;ActiveAttendanceSession&gt; {&#10;        return try {&#10;            // Convert domain model to DTO using mapper&#10;            val requestDto = request.toDto()&#10;&#10;            // Call API for check-in - backend handles location validation&#10;            val response = apiService.checkIn(requestDto)&#10;&#10;            if (response.success) {&#10;                // Save the attendance ID for later checkout&#10;                attendancePreference.saveActiveAttendanceId(response.data.idAttendance)&#10;                Log.d(&#10;                    TAG,&#10;                    &quot;Check-in successful, saved attendance ID: ${response.data.idAttendance}&quot;&#10;                )&#10;&#10;                // Convert DTO to ActiveAttendanceSession domain model using mapper&#10;                Result.success(response.data.toActiveSession())&#10;            } else {&#10;                Result.failure(Exception(response.message))&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error during check-in&quot;, e)&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Performs check-out operation with attendanceId and coordinates&#10;     * Backend will handle location validation for checkout&#10;     */&#10;    override suspend fun checkOut(&#10;        attendanceId: Int,&#10;        latitude: Double,&#10;        longitude: Double&#10;    ): Result&lt;ActiveAttendanceSession&gt; {&#10;        return try {&#10;            // Create checkout request DTO with coordinates&#10;            val checkOutRequestDto = CheckOutRequestDto(&#10;                latitude = latitude,&#10;                longitude = longitude&#10;            )&#10;&#10;            // Call API for check-out with attendanceId in URL and coordinates in body&#10;            val response = apiService.checkOut(attendanceId, checkOutRequestDto)&#10;&#10;            if (response.success) {&#10;                // Clear the active attendance ID&#10;                attendancePreference.clearActiveAttendanceId()&#10;                Log.d(TAG, &quot;Check-out successful, cleared attendance ID&quot;)&#10;&#10;                // Convert DTO to ActiveAttendanceSession domain model using mapper&#10;                Result.success(response.data.toActiveSession())&#10;            } else {&#10;                Result.failure(Exception(response.message))&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error during check-out&quot;, e)&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Retrieves the active attendance ID from preferences&#10;     */&#10;    override suspend fun getActiveAttendanceId(): Int? {&#10;        return try {&#10;            attendancePreference.getActiveAttendanceId().first()&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error getting active attendance ID&quot;, e)&#10;            null&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Sends location event (ENTER/EXIT) to backend&#10;     */&#10;    override suspend fun sendLocationEvent(request: LocationEventRequest): Result&lt;Unit&gt; {&#10;        return try {&#10;            val response = apiService.sendLocationEvent(request)&#10;            if (response.isSuccessful) {&#10;                Log.d(TAG, &quot;Location event sent successfully: ${request.eventType}&quot;)&#10;                Result.success(Unit)&#10;            } else {&#10;                Result.failure(Exception(&quot;Failed to send location event: ${response.code()} ${response.message()}&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error sending location event&quot;, e)&#10;            Result.failure(e)&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.infinite_track.data.repository.attendance&#10;&#10;import android.util.Log&#10;import com.example.infinite_track.data.mapper.attendance.toActiveSession&#10;import com.example.infinite_track.data.mapper.attendance.toDomain&#10;import com.example.infinite_track.data.mapper.attendance.toDto&#10;import com.example.infinite_track.data.soucre.local.preferences.AttendancePreference&#10;import com.example.infinite_track.data.soucre.network.request.CheckOutRequestDto&#10;import com.example.infinite_track.data.soucre.network.request.LocationEventRequest&#10;import com.example.infinite_track.data.soucre.network.retrofit.ApiService&#10;import com.example.infinite_track.domain.model.attendance.ActiveAttendanceSession&#10;import com.example.infinite_track.domain.model.attendance.AttendanceRequestModel&#10;import com.example.infinite_track.domain.model.attendance.TodayStatus&#10;import com.example.infinite_track.domain.repository.AttendanceRepository&#10;import kotlinx.coroutines.flow.first&#10;import org.json.JSONObject&#10;import retrofit2.HttpException&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class AttendanceRepositoryImpl @Inject constructor(&#10;    private val apiService: ApiService,&#10;    private val attendancePreference: AttendancePreference&#10;) : AttendanceRepository {&#10;&#10;    companion object {&#10;        private const val TAG = &quot;AttendanceRepository&quot;&#10;    }&#10;&#10;    /**&#10;     * Extract error message from HTTP response body&#10;     */&#10;    private fun extractErrorMessage(exception: HttpException): String {&#10;        return try {&#10;            val errorBody = exception.response()?.errorBody()?.string()&#10;            if (!errorBody.isNullOrEmpty()) {&#10;                val jsonObject = JSONObject(errorBody)&#10;                val message = jsonObject.optString(&quot;message&quot;, &quot;&quot;)&#10;                if (message.isNotEmpty()) {&#10;                    Log.d(TAG, &quot;Extracted error message: $message&quot;)&#10;                    return message&#10;                }&#10;            }&#10;            // Fallback to HTTP status message&#10;            &quot;HTTP ${exception.code()} ${exception.message()}&quot;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Failed to extract error message&quot;, e)&#10;            &quot;HTTP ${exception.code()} ${exception.message()}&quot;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Gets the current day's attendance status&#10;     */&#10;    override suspend fun getTodayStatus(): Result&lt;TodayStatus&gt; {&#10;        return try {&#10;            val response = apiService.getTodayStatus()&#10;            if (response.success) {&#10;                // Convert DTO to domain model using mapper&#10;                Result.success(response.data.toDomain())&#10;            } else {&#10;                Result.failure(Exception(response.message ?: &quot;Unknown error&quot;))&#10;            }&#10;        } catch (e: HttpException) {&#10;            Log.e(TAG, &quot;HTTP Error getting today's status&quot;, e)&#10;            val errorMessage = extractErrorMessage(e)&#10;            Result.failure(Exception(errorMessage))&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error getting today's status&quot;, e)&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Performs check-in operation - simplified without client-side location validation&#10;     * Backend will handle all location validation&#10;     */&#10;    override suspend fun checkIn(request: AttendanceRequestModel): Result&lt;ActiveAttendanceSession&gt; {&#10;        return try {&#10;            // Convert domain model to DTO using mapper&#10;            val requestDto = request.toDto()&#10;&#10;            // Call API for check-in - backend handles location validation&#10;            val response = apiService.checkIn(requestDto)&#10;&#10;            if (response.success) {&#10;                // Save the attendance ID for later checkout&#10;                attendancePreference.saveActiveAttendanceId(response.data.idAttendance)&#10;                Log.d(&#10;                    TAG,&#10;                    &quot;Check-in successful, saved attendance ID: ${response.data.idAttendance}&quot;&#10;                )&#10;&#10;                // Convert DTO to ActiveAttendanceSession domain model using mapper&#10;                Result.success(response.data.toActiveSession())&#10;            } else {&#10;                Result.failure(Exception(response.message))&#10;            }&#10;        } catch (e: HttpException) {&#10;            Log.e(TAG, &quot;HTTP Error during check-in&quot;, e)&#10;            val errorMessage = extractErrorMessage(e)&#10;            Result.failure(Exception(errorMessage))&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error during check-in&quot;, e)&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Performs check-out operation with attendanceId and coordinates&#10;     * Backend will handle location validation for checkout&#10;     */&#10;    override suspend fun checkOut(&#10;        attendanceId: Int,&#10;        latitude: Double,&#10;        longitude: Double&#10;    ): Result&lt;ActiveAttendanceSession&gt; {&#10;        return try {&#10;            // Create checkout request DTO with coordinates&#10;            val checkOutRequestDto = CheckOutRequestDto(&#10;                latitude = latitude,&#10;                longitude = longitude&#10;            )&#10;&#10;            // Call API for check-out with attendanceId in URL and coordinates in body&#10;            val response = apiService.checkOut(attendanceId, checkOutRequestDto)&#10;&#10;            if (response.success) {&#10;                // Clear the active attendance ID&#10;                attendancePreference.clearActiveAttendanceId()&#10;                Log.d(TAG, &quot;Check-out successful, cleared attendance ID&quot;)&#10;&#10;                // Convert DTO to ActiveAttendanceSession domain model using mapper&#10;                Result.success(response.data.toActiveSession())&#10;            } else {&#10;                Result.failure(Exception(response.message))&#10;            }&#10;        } catch (e: HttpException) {&#10;            Log.e(TAG, &quot;HTTP Error during check-out&quot;, e)&#10;            val errorMessage = extractErrorMessage(e)&#10;            Result.failure(Exception(errorMessage))&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error during check-out&quot;, e)&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Retrieves the active attendance ID from preferences&#10;     */&#10;    override suspend fun getActiveAttendanceId(): Int? {&#10;        return try {&#10;            attendancePreference.getActiveAttendanceId().first()&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error getting active attendance ID&quot;, e)&#10;            null&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Sends location event (ENTER/EXIT) to backend&#10;     */&#10;    override suspend fun sendLocationEvent(request: LocationEventRequest): Result&lt;Unit&gt; {&#10;        return try {&#10;            val response = apiService.sendLocationEvent(request)&#10;            if (response.isSuccessful) {&#10;                Log.d(TAG, &quot;Location event sent successfully: ${request.eventType}&quot;)&#10;                Result.success(Unit)&#10;            } else {&#10;                Result.failure(Exception(&quot;Failed to send location event: ${response.code()} ${response.message()}&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error sending location event&quot;, e)&#10;            Result.failure(e)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/presentation/screen/attendance/AttendanceScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/presentation/screen/attendance/AttendanceScreen.kt" />
              <option name="originalContent" value="package com.example.infinite_track.presentation.screen.attendance&#10;&#10;import androidx.compose.animation.AnimatedVisibility&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.statusBarsPadding&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.LocationOn&#10;import androidx.compose.material3.BottomSheetScaffold&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.rememberBottomSheetScaffoldState&#10;import androidx.compose.material3.rememberStandardBottomSheetState&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.blur&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import androidx.navigation.NavController&#10;import com.example.infinite_track.R&#10;import com.example.infinite_track.domain.model.attendance.TargetLocationInfo&#10;import com.example.infinite_track.domain.model.location.LocationResult&#10;import com.example.infinite_track.domain.model.wfa.WfaRecommendation&#10;import com.example.infinite_track.presentation.components.button.attendance.AttendanceBottomSheetContent&#10;import com.example.infinite_track.presentation.components.empty.ErrorAnimation&#10;import com.example.infinite_track.presentation.components.loading.LoadingAnimation&#10;import com.example.infinite_track.presentation.components.maps.AttendanceMap&#10;import com.example.infinite_track.presentation.components.maps.MarkerView&#10;import com.example.infinite_track.presentation.components.maps.MarkerViewWfa&#10;import com.example.infinite_track.presentation.navigation.Screen&#10;import com.example.infinite_track.presentation.screen.attendance.components.AttendanceTopBar&#10;import com.example.infinite_track.presentation.theme.Infinite_TrackTheme&#10;import com.example.infinite_track.utils.DialogHelper&#10;import com.example.infinite_track.utils.UiState&#10;import com.mapbox.geojson.Point&#10;import com.mapbox.maps.CameraOptions&#10;import com.mapbox.maps.MapView&#10;import com.mapbox.maps.MapboxDelicateApi&#10;import com.mapbox.maps.plugin.animation.MapAnimationOptions&#10;import com.mapbox.maps.plugin.animation.flyTo&#10;&#10;@OptIn(ExperimentalMaterial3Api::class, MapboxDelicateApi::class)&#10;@Composable&#10;fun AttendanceScreen(&#10;    navController: NavController,&#10;    viewModel: AttendanceViewModel = hiltViewModel()&#10;) {&#10;    var mapViewInstance by remember { mutableStateOf&lt;MapView?&gt;(null) }&#10;&#10;    // Observasi state dari ViewModel yang sudah disederhanakan&#10;    val uiState by viewModel.uiState.collectAsStateWithLifecycle()&#10;&#10;    // Handle hasil pencarian lokasi dari LocationSearchScreen&#10;    val selectedLocation = navController.currentBackStackEntry&#10;        ?.savedStateHandle&#10;        ?.get&lt;LocationResult&gt;(&quot;selected_location&quot;)&#10;&#10;    // Process hasil pencarian lokasi&#10;    LaunchedEffect(selectedLocation) {&#10;        selectedLocation?.let { location -&gt;&#10;            // Kirim lokasi terpilih ke ViewModel untuk diproses&#10;            viewModel.onLocationSelected(location)&#10;            // Hapus state agar tidak diproses lagi saat re-komposisi&#10;            navController.currentBackStackEntry&#10;                ?.savedStateHandle&#10;                ?.remove&lt;LocationResult&gt;(&quot;selected_location&quot;)&#10;        }&#10;    }&#10;&#10;    // BottomSheet state&#10;    val bottomSheetState = rememberStandardBottomSheetState(&#10;        skipHiddenState = false&#10;    )&#10;    val scaffoldState = rememberBottomSheetScaffoldState(&#10;        bottomSheetState = bottomSheetState&#10;    )&#10;&#10;    // =======================================================&#10;    // NEW: State-driven LaunchedEffect for Navigation&#10;    // =======================================================&#10;    LaunchedEffect(uiState.navigationTarget) {&#10;        uiState.navigationTarget?.let { target -&gt;&#10;            when (target) {&#10;                is NavigationTarget.FaceScanner -&gt; {&#10;                    val action = if (target.isCheckIn) &quot;checkin&quot; else &quot;checkout&quot;&#10;                    val route = Screen.FaceScanner.createRoute(action)&#10;                    navController.navigate(route)&#10;                    android.util.Log.d(&#10;                        &quot;AttendanceScreen&quot;,&#10;                        &quot;Navigating to face scanner for $action&quot;&#10;                    )&#10;                }&#10;                is NavigationTarget.WfaBooking -&gt; {&#10;                    navController.navigate(target.route)&#10;                    android.util.Log.d(&#10;                        &quot;AttendanceScreen&quot;,&#10;                        &quot;Navigating to WFA booking screen with route: ${target.route}&quot;&#10;                    )&#10;                }&#10;                is NavigationTarget.LocationSearch -&gt; {&#10;                    navController.navigate(target.params)&#10;                    android.util.Log.d(&#10;                        &quot;AttendanceScreen&quot;,&#10;                        &quot;Navigating to location search with params: ${target.params}&quot;&#10;                    )&#10;                }&#10;            }&#10;            // Notify ViewModel that navigation has been handled&#10;            viewModel.onNavigationHandled()&#10;        }&#10;    }&#10;&#10;    // =======================================================&#10;    // NEW: State-driven LaunchedEffect for Map Animation&#10;    // =======================================================&#10;    LaunchedEffect(uiState.mapAnimationTarget) {&#10;        uiState.mapAnimationTarget?.let { animationTarget -&gt;&#10;            when (animationTarget) {&#10;                is MapAnimationTarget.AnimateToLocation -&gt; {&#10;                    mapViewInstance?.let { mapView -&gt;&#10;                        val cameraOptions = CameraOptions.Builder()&#10;                            .center(animationTarget.point)&#10;                            .zoom(animationTarget.zoomLevel)&#10;                            .pitch(0.0)&#10;                            .bearing(0.0)&#10;                            .build()&#10;&#10;                        mapView.mapboxMap.flyTo(&#10;                            cameraOptions,&#10;                            MapAnimationOptions.Builder()&#10;                                .duration(1200L)&#10;                                .build()&#10;                        )&#10;&#10;                        android.util.Log.d(&#10;                            &quot;AttendanceScreen&quot;,&#10;                            &quot;Camera animated to ${animationTarget.point.latitude()}, ${animationTarget.point.longitude()} with zoom ${animationTarget.zoomLevel}&quot;&#10;                        )&#10;                    }&#10;                }&#10;&#10;                is MapAnimationTarget.AnimateToFitBounds -&gt; {&#10;                    mapViewInstance?.let { mapView -&gt;&#10;                        if (animationTarget.points.isNotEmpty()) {&#10;                            val cameraOptions = mapView.mapboxMap.cameraForCoordinates(&#10;                                coordinates = animationTarget.points,&#10;                                camera = CameraOptions.Builder().build(),&#10;                                coordinatesPadding = com.mapbox.maps.EdgeInsets(&#10;                                    50.0,&#10;                                    50.0,&#10;                                    50.0,&#10;                                    50.0&#10;                                ),&#10;                                maxZoom = null,&#10;                                offset = null&#10;                            )&#10;&#10;                            mapView.mapboxMap.flyTo(&#10;                                cameraOptions,&#10;                                MapAnimationOptions.Builder()&#10;                                    .duration(1500L)&#10;                                    .build()&#10;                            )&#10;&#10;                            android.util.Log.d(&#10;                                &quot;AttendanceScreen&quot;,&#10;                                &quot;Camera animated to fit ${animationTarget.points.size} WFA locations&quot;&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;&#10;                is MapAnimationTarget.ShowLocationError -&gt; {&#10;                    android.util.Log.e(&#10;                        &quot;AttendanceScreen&quot;,&#10;                        &quot;Failed to get current location for focus&quot;&#10;                    )&#10;                    // Could show a Toast or Snackbar here&#10;                }&#10;            }&#10;            // Notify ViewModel that map animation has been handled&#10;            viewModel.onMapAnimationHandled()&#10;        }&#10;    }&#10;&#10;    // Start location updates when UI is ready and data is loaded successfully&#10;    LaunchedEffect(uiState.uiState) {&#10;        if (uiState.uiState is UiState.Success) {&#10;            // Only start location updates after data is loaded and UI is ready&#10;            viewModel.startLocationUpdates()&#10;            android.util.Log.d(&quot;AttendanceScreen&quot;, &quot;Location updates started after UI ready&quot;)&#10;        }&#10;    }&#10;&#10;    // Penanganan state utama berdasarkan UiState dengan smart cast fix&#10;    when (val currentUiState = uiState.uiState) {&#10;        is UiState.Idle -&gt; {&#10;            // Initial idle state - could show a splash or continue to loading&#10;            Box(&#10;                modifier = Modifier.fillMaxSize(),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                LoadingAnimation()&#10;            }&#10;        }&#10;&#10;        is UiState.Loading -&gt; {&#10;            // Tampilkan loading animation&#10;            Box(&#10;                modifier = Modifier.fillMaxSize(),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                LoadingAnimation()&#10;            }&#10;        }&#10;&#10;        is UiState.Error -&gt; {&#10;            Box(&#10;                modifier = Modifier.fillMaxSize(),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Column(&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    ErrorAnimation()&#10;                    Text(&#10;                        text = currentUiState.errorMessage,&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        color = MaterialTheme.colorScheme.error,&#10;                        textAlign = TextAlign.Center,&#10;                        modifier = Modifier.padding(16.dp)&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        is UiState.Success -&gt; {&#10;            // Tampilkan konten utama dengan BottomSheet&#10;            BottomSheetScaffold(&#10;                scaffoldState = scaffoldState,&#10;                containerColor = Color.Black.copy(alpha = 0.1f),&#10;                contentColor = Color.Transparent,&#10;                sheetContainerColor = Color.Transparent,&#10;                sheetContentColor = Color.Unspecified,&#10;                sheetShape = RoundedCornerShape(topStart = 24.dp, topEnd = 24.dp),&#10;                sheetPeekHeight = 120.dp,&#10;                sheetDragHandle = null,&#10;                sheetContent = {&#10;                    // Enhanced Liquid Glass Background Container&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .clip(RoundedCornerShape(topStart = 24.dp, topEnd = 24.dp))&#10;                            .background(&#10;                                brush = Brush.linearGradient(&#10;                                    colors = listOf(&#10;                                        Color.White.copy(alpha = 0.98f),&#10;                                        Color.White.copy(alpha = 0.95f),&#10;                                        Color(0xFFE3F2FD).copy(alpha = 0.92f),&#10;                                        Color(0xFFBBDEFB).copy(alpha = 0.88f)&#10;                                    )&#10;                                )&#10;                            )&#10;                    ) {&#10;                        // Glass effect overlays&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .matchParentSize()&#10;                                .background(&#10;                                    brush = Brush.radialGradient(&#10;                                        colors = listOf(&#10;                                            Color.White.copy(alpha = 0.6f),&#10;                                            Color.Transparent,&#10;                                            Color(0xFF81D4FA).copy(alpha = 0.3f)&#10;                                        ),&#10;                                        radius = 1000f&#10;                                    )&#10;                                )&#10;                                .blur(2.dp)&#10;                        )&#10;&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .matchParentSize()&#10;                                .background(&#10;                                    brush = Brush.linearGradient(&#10;                                        colors = listOf(&#10;                                            Color.Transparent,&#10;                                            Color.White.copy(alpha = 0.4f),&#10;                                            Color.Transparent&#10;                                        )&#10;                                    )&#10;                                )&#10;                        )&#10;&#10;                        // Content with drag handle&#10;                        Column(modifier = Modifier.fillMaxWidth()) {&#10;                            // Custom drag handle&#10;                            Box(&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .padding(top = 12.dp, bottom = 8.dp),&#10;                                contentAlignment = Alignment.Center&#10;                            ) {&#10;                                Box(&#10;                                    modifier = Modifier&#10;                                        .width(40.dp)&#10;                                        .height(4.dp)&#10;                                        .clip(RoundedCornerShape(2.dp))&#10;                                        .background(Color.Gray.copy(alpha = 0.3f))&#10;                                )&#10;                            }&#10;&#10;                            AttendanceBottomSheetContent(&#10;                                modifier = Modifier.padding(top = 0.dp),&#10;                                targetLocationInfo = uiState.targetLocation?.let { target -&gt;&#10;                                    TargetLocationInfo(&#10;                                        description = target.description,&#10;                                        locationName = target.category&#10;                                    )&#10;                                },&#10;                                currentLocationAddress = uiState.currentUserAddress.ifEmpty { &quot;Mengambil lokasi saat ini...&quot; },&#10;                                selectedWorkMode = uiState.selectedWorkMode,&#10;                                isBookingEnabled = uiState.isBookingEnabled,&#10;                                isCheckInEnabled = uiState.isButtonEnabled, // Use isButtonEnabled from uiState&#10;                                checkInButtonText = uiState.buttonText,&#10;                                onSearchLocationClick = {&#10;                                    navController.navigate(&quot;location_search&quot;)&#10;                                },&#10;                                onModeSelected = { mode -&gt; viewModel.onWorkModeSelected(mode) },&#10;                                onBookingClick = { viewModel.onBookingClicked() },&#10;                                onCheckInClick = { viewModel.onAttendanceButtonClicked() }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            ) { _ -&gt; // Renamed paddingValues to _ to indicate it's intentionally unused&#10;                Box(modifier = Modifier.fillMaxSize()) {&#10;                    // Fullscreen Map dengan data dari ViewModel - Updated with WFO, WFH, and WFA locations&#10;                    AttendanceMap(&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        wfoLocation = if (uiState.isWfaModeActive) null else uiState.wfoLocation, // Hide WFO when WFA active&#10;                        wfhLocation = if (uiState.isWfaModeActive) null else uiState.wfhLocation, // Hide WFH when WFA active&#10;                        wfaRecommendations = uiState.wfaRecommendations, // WFA recommendations&#10;                        selectedWfaLocation = uiState.selectedWfaLocation, // Selected WFA location&#10;                        targetLocation = uiState.targetLocationMarker, // Keep for backward compatibility&#10;                        currentUserLocation = uiState.currentUserLatitude?.let { lat -&gt;&#10;                            uiState.currentUserLongitude?.let { lng -&gt;&#10;                                Point.fromLngLat(lng, lat)&#10;                            }&#10;                        },&#10;                        onMarkerClick = { location -&gt; viewModel.onMarkerClicked(location) },&#10;                        onWfaMarkerClick = { recommendation: WfaRecommendation -&gt;&#10;                            viewModel.onWfaMarkerClicked(&#10;                                recommendation&#10;                            )&#10;                        }, // Handle WFA marker clicks&#10;                        onMapReady = { mapView -&gt;&#10;                            mapViewInstance = mapView&#10;                            // Notify ViewModel that map is ready for initial focus&#10;                            viewModel.onMapReady()&#10;                        },&#10;                        onCameraIdle = { point -&gt;&#10;                            viewModel.onMapIdle(point)&#10;                        } // Handle Pick on Map functionality&#10;                    )&#10;&#10;                    // Top bar with location focus button - fixed parameters&#10;                    AttendanceTopBar(&#10;                        modifier = Modifier&#10;                            .statusBarsPadding()&#10;                            .padding(16.dp),&#10;                        onBackClicked = { navController.navigateUp() },&#10;                        onFocusLocationClicked = { viewModel.onFocusLocationClicked() }&#10;                    )&#10;&#10;                    // Pick on Map Crosshair - shows static pin in center when Pick on Map mode is active&#10;                    AnimatedVisibility(&#10;                        visible = uiState.isPickOnMapModeActive,&#10;                        modifier = Modifier.align(Alignment.Center)&#10;                    ) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.LocationOn,&#10;                            contentDescription = &quot;Pick Location&quot;,&#10;                            tint = Color.Red,&#10;                            modifier = Modifier.size(32.dp)&#10;                        )&#10;                    }&#10;&#10;                    uiState.selectedMarkerInfo?.let { selectedMarker -&gt;&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .fillMaxSize()&#10;                                .padding(top = 80.dp),&#10;                            contentAlignment = Alignment.TopCenter&#10;                        ) {&#10;                            MarkerView(&#10;                                title = selectedMarker.description,&#10;                                description = &quot;Kategori: ${selectedMarker.category}&quot;,&#10;                                radius = &quot;${selectedMarker.radius} meter&quot;,&#10;                                coordinates = &quot;${selectedMarker.latitude}, ${selectedMarker.longitude}&quot;,&#10;                                onClose = { viewModel.onDismissMarkerInfo() }&#10;                            )&#10;                        }&#10;                    }&#10;&#10;                    // Display WFA marker details when clicked&#10;                    uiState.selectedWfaMarkerInfo?.let { selectedWfaMarker -&gt;&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .fillMaxSize()&#10;                                .padding(top = 80.dp, start = 16.dp, end = 16.dp),&#10;                            contentAlignment = Alignment.TopCenter&#10;                        ) {&#10;                            MarkerViewWfa(&#10;                                recommendation = selectedWfaMarker,&#10;                                onClick = { viewModel.onDismissWfaMarkerInfo() }&#10;                            )&#10;                        }&#10;                    }&#10;&#10;                    // Loading overlay for WFA recommendations&#10;                    if (uiState.isLoadingWfaRecommendations) {&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .fillMaxSize()&#10;                                .background(Color.Black.copy(alpha = 0.3f)),&#10;                            contentAlignment = Alignment.Center&#10;                        ) {&#10;                            LoadingAnimation()&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // =======================================================&#10;    // NEW: State-driven LaunchedEffect for Dialog Handling&#10;    // =======================================================&#10;    LaunchedEffect(uiState.activeDialog) {&#10;        uiState.activeDialog?.let { dialog -&gt;&#10;            when (dialog) {&#10;                is DialogState.Success -&gt; {&#10;                    // Show success dialog with dynamic message from server&#10;                    DialogHelper.showDialogSuccess(&#10;                        context = navController.context,&#10;                        title = &quot;Absensi Berhasil&quot;,&#10;                        textContent = dialog.message,&#10;                        imageRes = R.drawable.icon_success,&#10;                        onConfirm = {&#10;                            // Navigate to HomeScreen after success&#10;                            navController.navigate(Screen.Home.route) {&#10;                                // Clear backstack to prevent going back to attendance&#10;                                popUpTo(Screen.Home.route) {&#10;                                    inclusive = false&#10;                                }&#10;                            }&#10;                            // Notify ViewModel that dialog has been handled&#10;                            viewModel.onDialogDismissed()&#10;                        }&#10;                    )&#10;                }&#10;&#10;                is DialogState.Error -&gt; {&#10;                    // Show error dialog with dynamic message from server&#10;                    DialogHelper.showDialogError(&#10;                        context = navController.context,&#10;                        title = &quot;Absensi Gagal&quot;,&#10;                        textContent = dialog.message,&#10;                        onConfirm = {&#10;                            // Stay on AttendanceScreen - no navigation needed&#10;                            // User can try again&#10;                            viewModel.onDialogDismissed()&#10;                        }&#10;                    )&#10;                }&#10;&#10;                is DialogState.LocationError -&gt; {&#10;                    // Show location error dialog&#10;                    DialogHelper.showDialogError(&#10;                        context = navController.context,&#10;                        title = &quot;Error Lokasi&quot;,&#10;                        textContent = dialog.message,&#10;                        onConfirm = {&#10;                            viewModel.onDialogDismissed()&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Handle face verification result from FaceScannerScreen&#10;    LaunchedEffect(Unit) {&#10;        // Get face verification result from savedStateHandle&#10;        val faceVerificationResult = navController.currentBackStackEntry&#10;            ?.savedStateHandle&#10;            ?.getLiveData&lt;Boolean&gt;(&quot;face_verification_result&quot;)&#10;&#10;        faceVerificationResult?.observeForever { isSuccess -&gt;&#10;            if (isSuccess != null) {&#10;                // FIXED: Only process if verification was successful&#10;                // If failed, user should stay on FaceScannerScreen for retry&#10;                if (isSuccess) {&#10;                    // Call ViewModel to handle the successful result&#10;                    viewModel.onFaceVerificationResult(isSuccess)&#10;                } else {&#10;                    // Face verification failed - don't process, let user retry on scanner screen&#10;                    android.util.Log.d(&#10;                        &quot;AttendanceScreen&quot;,&#10;                        &quot;Face verification failed - user should retry on scanner screen&quot;&#10;                    )&#10;                }&#10;&#10;                // Clear the result to prevent re-processing&#10;                navController.currentBackStackEntry&#10;                    ?.savedStateHandle&#10;                    ?.remove&lt;Boolean&gt;(&quot;face_verification_result&quot;)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun AttendanceScreenPreview() {&#10;    Infinite_TrackTheme {&#10;        Box(modifier = Modifier.fillMaxSize()) {&#10;            AttendanceMap(&#10;                modifier = Modifier.fillMaxSize(),&#10;                onMapReady = { }&#10;            )&#10;            AttendanceTopBar(&#10;                modifier = Modifier&#10;                    .align(Alignment.TopCenter)&#10;                    .statusBarsPadding()&#10;                    .padding(horizontal = 20.dp),&#10;                onBackClicked = { },&#10;                onFocusLocationClicked = { }&#10;            )&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.infinite_track.presentation.screen.attendance&#10;&#10;import androidx.compose.animation.AnimatedVisibility&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.statusBarsPadding&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.LocationOn&#10;import androidx.compose.material3.BottomSheetScaffold&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.rememberBottomSheetScaffoldState&#10;import androidx.compose.material3.rememberStandardBottomSheetState&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.blur&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import androidx.navigation.NavController&#10;import com.example.infinite_track.R&#10;import com.example.infinite_track.domain.model.attendance.TargetLocationInfo&#10;import com.example.infinite_track.domain.model.location.LocationResult&#10;import com.example.infinite_track.domain.model.wfa.WfaRecommendation&#10;import com.example.infinite_track.presentation.components.button.attendance.AttendanceBottomSheetContent&#10;import com.example.infinite_track.presentation.components.empty.ErrorAnimation&#10;import com.example.infinite_track.presentation.components.loading.LoadingAnimation&#10;import com.example.infinite_track.presentation.components.maps.AttendanceMap&#10;import com.example.infinite_track.presentation.components.maps.MarkerView&#10;import com.example.infinite_track.presentation.components.maps.MarkerViewWfa&#10;import com.example.infinite_track.presentation.navigation.Screen&#10;import com.example.infinite_track.presentation.screen.attendance.components.AttendanceTopBar&#10;import com.example.infinite_track.presentation.theme.Infinite_TrackTheme&#10;import com.example.infinite_track.utils.DialogHelper&#10;import com.example.infinite_track.utils.UiState&#10;import com.mapbox.geojson.Point&#10;import com.mapbox.maps.CameraOptions&#10;import com.mapbox.maps.MapView&#10;import com.mapbox.maps.MapboxDelicateApi&#10;import com.mapbox.maps.plugin.animation.MapAnimationOptions&#10;import com.mapbox.maps.plugin.animation.flyTo&#10;&#10;@OptIn(ExperimentalMaterial3Api::class, MapboxDelicateApi::class)&#10;@Composable&#10;fun AttendanceScreen(&#10;    navController: NavController,&#10;    viewModel: AttendanceViewModel = hiltViewModel()&#10;) {&#10;    var mapViewInstance by remember { mutableStateOf&lt;MapView?&gt;(null) }&#10;&#10;    // Observasi state dari ViewModel yang sudah disederhanakan&#10;    val uiState by viewModel.uiState.collectAsStateWithLifecycle()&#10;&#10;    // Handle hasil pencarian lokasi dari LocationSearchScreen&#10;    val selectedLocation = navController.currentBackStackEntry&#10;        ?.savedStateHandle&#10;        ?.get&lt;LocationResult&gt;(&quot;selected_location&quot;)&#10;&#10;    // Process hasil pencarian lokasi&#10;    LaunchedEffect(selectedLocation) {&#10;        selectedLocation?.let { location -&gt;&#10;            // Kirim lokasi terpilih ke ViewModel untuk diproses&#10;            viewModel.onLocationSelected(location)&#10;            // Hapus state agar tidak diproses lagi saat re-komposisi&#10;            navController.currentBackStackEntry&#10;                ?.savedStateHandle&#10;                ?.remove&lt;LocationResult&gt;(&quot;selected_location&quot;)&#10;        }&#10;    }&#10;&#10;    // BottomSheet state&#10;    val bottomSheetState = rememberStandardBottomSheetState(&#10;        skipHiddenState = false&#10;    )&#10;    val scaffoldState = rememberBottomSheetScaffoldState(&#10;        bottomSheetState = bottomSheetState&#10;    )&#10;&#10;    // =======================================================&#10;    // NEW: State-driven LaunchedEffect for Navigation&#10;    // =======================================================&#10;    LaunchedEffect(uiState.navigationTarget) {&#10;        uiState.navigationTarget?.let { target -&gt;&#10;            when (target) {&#10;                is NavigationTarget.FaceScanner -&gt; {&#10;                    val action = if (target.isCheckIn) &quot;checkin&quot; else &quot;checkout&quot;&#10;                    val route = Screen.FaceScanner.createRoute(action)&#10;                    navController.navigate(route)&#10;                    android.util.Log.d(&#10;                        &quot;AttendanceScreen&quot;,&#10;                        &quot;Navigating to face scanner for $action&quot;&#10;                    )&#10;                }&#10;                is NavigationTarget.WfaBooking -&gt; {&#10;                    navController.navigate(target.route)&#10;                    android.util.Log.d(&#10;                        &quot;AttendanceScreen&quot;,&#10;                        &quot;Navigating to WFA booking screen with route: ${target.route}&quot;&#10;                    )&#10;                }&#10;                is NavigationTarget.LocationSearch -&gt; {&#10;                    navController.navigate(target.params)&#10;                    android.util.Log.d(&#10;                        &quot;AttendanceScreen&quot;,&#10;                        &quot;Navigating to location search with params: ${target.params}&quot;&#10;                    )&#10;                }&#10;            }&#10;            // Notify ViewModel that navigation has been handled&#10;            viewModel.onNavigationHandled()&#10;        }&#10;    }&#10;&#10;    // =======================================================&#10;    // NEW: State-driven LaunchedEffect for Map Animation&#10;    // =======================================================&#10;    LaunchedEffect(uiState.mapAnimationTarget) {&#10;        uiState.mapAnimationTarget?.let { animationTarget -&gt;&#10;            when (animationTarget) {&#10;                is MapAnimationTarget.AnimateToLocation -&gt; {&#10;                    mapViewInstance?.let { mapView -&gt;&#10;                        val cameraOptions = CameraOptions.Builder()&#10;                            .center(animationTarget.point)&#10;                            .zoom(animationTarget.zoomLevel)&#10;                            .pitch(0.0)&#10;                            .bearing(0.0)&#10;                            .build()&#10;&#10;                        mapView.mapboxMap.flyTo(&#10;                            cameraOptions,&#10;                            MapAnimationOptions.Builder()&#10;                                .duration(1200L)&#10;                                .build()&#10;                        )&#10;&#10;                        android.util.Log.d(&#10;                            &quot;AttendanceScreen&quot;,&#10;                            &quot;Camera animated to ${animationTarget.point.latitude()}, ${animationTarget.point.longitude()} with zoom ${animationTarget.zoomLevel}&quot;&#10;                        )&#10;                    }&#10;                }&#10;&#10;                is MapAnimationTarget.AnimateToFitBounds -&gt; {&#10;                    mapViewInstance?.let { mapView -&gt;&#10;                        if (animationTarget.points.isNotEmpty()) {&#10;                            val cameraOptions = mapView.mapboxMap.cameraForCoordinates(&#10;                                coordinates = animationTarget.points,&#10;                                camera = CameraOptions.Builder().build(),&#10;                                coordinatesPadding = com.mapbox.maps.EdgeInsets(&#10;                                    50.0,&#10;                                    50.0,&#10;                                    50.0,&#10;                                    50.0&#10;                                ),&#10;                                maxZoom = null,&#10;                                offset = null&#10;                            )&#10;&#10;                            mapView.mapboxMap.flyTo(&#10;                                cameraOptions,&#10;                                MapAnimationOptions.Builder()&#10;                                    .duration(1500L)&#10;                                    .build()&#10;                            )&#10;&#10;                            android.util.Log.d(&#10;                                &quot;AttendanceScreen&quot;,&#10;                                &quot;Camera animated to fit ${animationTarget.points.size} WFA locations&quot;&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;&#10;                is MapAnimationTarget.ShowLocationError -&gt; {&#10;                    android.util.Log.e(&#10;                        &quot;AttendanceScreen&quot;,&#10;                        &quot;Failed to get current location for focus&quot;&#10;                    )&#10;                    // Could show a Toast or Snackbar here&#10;                }&#10;            }&#10;            // Notify ViewModel that map animation has been handled&#10;            viewModel.onMapAnimationHandled()&#10;        }&#10;    }&#10;&#10;    // Start location updates when UI is ready and data is loaded successfully&#10;    LaunchedEffect(uiState.uiState) {&#10;        if (uiState.uiState is UiState.Success) {&#10;            // Only start location updates after data is loaded and UI is ready&#10;            viewModel.startLocationUpdates()&#10;            android.util.Log.d(&quot;AttendanceScreen&quot;, &quot;Location updates started after UI ready&quot;)&#10;        }&#10;    }&#10;&#10;    // Penanganan state utama berdasarkan UiState dengan smart cast fix&#10;    when (val currentUiState = uiState.uiState) {&#10;        is UiState.Idle -&gt; {&#10;            // Initial idle state - could show a splash or continue to loading&#10;            Box(&#10;                modifier = Modifier.fillMaxSize(),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                LoadingAnimation()&#10;            }&#10;        }&#10;&#10;        is UiState.Loading -&gt; {&#10;            // Tampilkan loading animation&#10;            Box(&#10;                modifier = Modifier.fillMaxSize(),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                LoadingAnimation()&#10;            }&#10;        }&#10;&#10;        is UiState.Error -&gt; {&#10;            Box(&#10;                modifier = Modifier.fillMaxSize(),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Column(&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    ErrorAnimation()&#10;                    Text(&#10;                        text = currentUiState.errorMessage,&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        color = MaterialTheme.colorScheme.error,&#10;                        textAlign = TextAlign.Center,&#10;                        modifier = Modifier.padding(16.dp)&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        is UiState.Success -&gt; {&#10;            // Tampilkan konten utama dengan BottomSheet&#10;            BottomSheetScaffold(&#10;                scaffoldState = scaffoldState,&#10;                containerColor = Color.Black.copy(alpha = 0.1f),&#10;                contentColor = Color.Transparent,&#10;                sheetContainerColor = Color.Transparent,&#10;                sheetContentColor = Color.Unspecified,&#10;                sheetShape = RoundedCornerShape(topStart = 24.dp, topEnd = 24.dp),&#10;                sheetPeekHeight = 120.dp,&#10;                sheetDragHandle = null,&#10;                sheetContent = {&#10;                    // Enhanced Liquid Glass Background Container&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .clip(RoundedCornerShape(topStart = 24.dp, topEnd = 24.dp))&#10;                            .background(&#10;                                brush = Brush.linearGradient(&#10;                                    colors = listOf(&#10;                                        Color.White.copy(alpha = 0.98f),&#10;                                        Color.White.copy(alpha = 0.95f),&#10;                                        Color(0xFFE3F2FD).copy(alpha = 0.92f),&#10;                                        Color(0xFFBBDEFB).copy(alpha = 0.88f)&#10;                                    )&#10;                                )&#10;                            )&#10;                    ) {&#10;                        // Glass effect overlays&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .matchParentSize()&#10;                                .background(&#10;                                    brush = Brush.radialGradient(&#10;                                        colors = listOf(&#10;                                            Color.White.copy(alpha = 0.6f),&#10;                                            Color.Transparent,&#10;                                            Color(0xFF81D4FA).copy(alpha = 0.3f)&#10;                                        ),&#10;                                        radius = 1000f&#10;                                    )&#10;                                )&#10;                                .blur(2.dp)&#10;                        )&#10;&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .matchParentSize()&#10;                                .background(&#10;                                    brush = Brush.linearGradient(&#10;                                        colors = listOf(&#10;                                            Color.Transparent,&#10;                                            Color.White.copy(alpha = 0.4f),&#10;                                            Color.Transparent&#10;                                        )&#10;                                    )&#10;                                )&#10;                        )&#10;&#10;                        // Content with drag handle&#10;                        Column(modifier = Modifier.fillMaxWidth()) {&#10;                            // Custom drag handle&#10;                            Box(&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .padding(top = 12.dp, bottom = 8.dp),&#10;                                contentAlignment = Alignment.Center&#10;                            ) {&#10;                                Box(&#10;                                    modifier = Modifier&#10;                                        .width(40.dp)&#10;                                        .height(4.dp)&#10;                                        .clip(RoundedCornerShape(2.dp))&#10;                                        .background(Color.Gray.copy(alpha = 0.3f))&#10;                                )&#10;                            }&#10;&#10;                            AttendanceBottomSheetContent(&#10;                                modifier = Modifier.padding(top = 0.dp),&#10;                                targetLocationInfo = uiState.targetLocation?.let { target -&gt;&#10;                                    TargetLocationInfo(&#10;                                        description = target.description,&#10;                                        locationName = target.category&#10;                                    )&#10;                                },&#10;                                currentLocationAddress = uiState.currentUserAddress.ifEmpty { &quot;Mengambil lokasi saat ini...&quot; },&#10;                                selectedWorkMode = uiState.selectedWorkMode,&#10;                                isBookingEnabled = uiState.isBookingEnabled,&#10;                                isCheckInEnabled = uiState.isButtonEnabled, // Use isButtonEnabled from uiState&#10;                                checkInButtonText = uiState.buttonText,&#10;                                onSearchLocationClick = {&#10;                                    navController.navigate(&quot;location_search&quot;)&#10;                                },&#10;                                onModeSelected = { mode -&gt; viewModel.onWorkModeSelected(mode) },&#10;                                onBookingClick = { viewModel.onBookingClicked() },&#10;                                onCheckInClick = { viewModel.onAttendanceButtonClicked() }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            ) { _ -&gt; // Renamed paddingValues to _ to indicate it's intentionally unused&#10;                Box(modifier = Modifier.fillMaxSize()) {&#10;                    // Fullscreen Map dengan data dari ViewModel - Updated with WFO, WFH, and WFA locations&#10;                    AttendanceMap(&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        wfoLocation = if (uiState.isWfaModeActive) null else uiState.wfoLocation, // Hide WFO when WFA active&#10;                        wfhLocation = if (uiState.isWfaModeActive) null else uiState.wfhLocation, // Hide WFH when WFA active&#10;                        wfaRecommendations = uiState.wfaRecommendations, // WFA recommendations&#10;                        selectedWfaLocation = uiState.selectedWfaLocation, // Selected WFA location&#10;                        targetLocation = uiState.targetLocationMarker, // Keep for backward compatibility&#10;                        currentUserLocation = uiState.currentUserLatitude?.let { lat -&gt;&#10;                            uiState.currentUserLongitude?.let { lng -&gt;&#10;                                Point.fromLngLat(lng, lat)&#10;                            }&#10;                        },&#10;                        onMarkerClick = { location -&gt; viewModel.onMarkerClicked(location) },&#10;                        onWfaMarkerClick = { recommendation: WfaRecommendation -&gt;&#10;                            viewModel.onWfaMarkerClicked(&#10;                                recommendation&#10;                            )&#10;                        }, // Handle WFA marker clicks&#10;                        onMapReady = { mapView -&gt;&#10;                            mapViewInstance = mapView&#10;                            // Notify ViewModel that map is ready for initial focus&#10;                            viewModel.onMapReady()&#10;                        },&#10;                        onCameraIdle = { point -&gt;&#10;                            viewModel.onMapIdle(point)&#10;                        } // Handle Pick on Map functionality&#10;                    )&#10;&#10;                    // Top bar with location focus button - fixed parameters&#10;                    AttendanceTopBar(&#10;                        modifier = Modifier&#10;                            .statusBarsPadding()&#10;                            .padding(16.dp),&#10;                        onBackClicked = { navController.navigateUp() },&#10;                        onFocusLocationClicked = { viewModel.onFocusLocationClicked() }&#10;                    )&#10;&#10;                    // Pick on Map Crosshair - shows static pin in center when Pick on Map mode is active&#10;                    AnimatedVisibility(&#10;                        visible = uiState.isPickOnMapModeActive,&#10;                        modifier = Modifier.align(Alignment.Center)&#10;                    ) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.LocationOn,&#10;                            contentDescription = &quot;Pick Location&quot;,&#10;                            tint = Color.Red,&#10;                            modifier = Modifier.size(32.dp)&#10;                        )&#10;                    }&#10;&#10;                    uiState.selectedMarkerInfo?.let { selectedMarker -&gt;&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .fillMaxSize()&#10;                                .padding(top = 80.dp),&#10;                            contentAlignment = Alignment.TopCenter&#10;                        ) {&#10;                            MarkerView(&#10;                                title = selectedMarker.description,&#10;                                description = &quot;Kategori: ${selectedMarker.category}&quot;,&#10;                                radius = &quot;${selectedMarker.radius} meter&quot;,&#10;                                coordinates = &quot;${selectedMarker.latitude}, ${selectedMarker.longitude}&quot;,&#10;                                onClose = { viewModel.onDismissMarkerInfo() }&#10;                            )&#10;                        }&#10;                    }&#10;&#10;                    // Display WFA marker details when clicked&#10;                    uiState.selectedWfaMarkerInfo?.let { selectedWfaMarker -&gt;&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .fillMaxSize()&#10;                                .padding(top = 80.dp, start = 16.dp, end = 16.dp),&#10;                            contentAlignment = Alignment.TopCenter&#10;                        ) {&#10;                            MarkerViewWfa(&#10;                                recommendation = selectedWfaMarker,&#10;                                onClick = { viewModel.onDismissWfaMarkerInfo() }&#10;                            )&#10;                        }&#10;                    }&#10;&#10;                    // Loading overlay for WFA recommendations&#10;                    if (uiState.isLoadingWfaRecommendations) {&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .fillMaxSize()&#10;                                .background(Color.Black.copy(alpha = 0.3f)),&#10;                            contentAlignment = Alignment.Center&#10;                        ) {&#10;                            LoadingAnimation()&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // =======================================================&#10;    // NEW: State-driven LaunchedEffect for Dialog Handling&#10;    // =======================================================&#10;    LaunchedEffect(uiState.activeDialog) {&#10;        uiState.activeDialog?.let { dialog -&gt;&#10;            when (dialog) {&#10;                is DialogState.Success -&gt; {&#10;                    // Show success dialog with dynamic message from server&#10;                    DialogHelper.showDialogSuccess(&#10;                        context = navController.context,&#10;                        title = &quot;Absensi Berhasil&quot;,&#10;                        textContent = dialog.message,&#10;                        imageRes = R.drawable.icon_success,&#10;                        onConfirm = {&#10;                            // Navigate to HomeScreen after success&#10;                            navController.navigate(Screen.Home.route) {&#10;                                // Clear backstack to prevent going back to attendance&#10;                                popUpTo(Screen.Home.route) {&#10;                                    inclusive = false&#10;                                }&#10;                            }&#10;                            // Notify ViewModel that dialog has been handled&#10;                            viewModel.onDialogDismissed()&#10;                        }&#10;                    )&#10;                }&#10;&#10;                is DialogState.Error -&gt; {&#10;                    // Show error dialog with dynamic message from server&#10;                    DialogHelper.showDialogError(&#10;                        context = navController.context,&#10;                        title = &quot;Absensi Gagal&quot;,&#10;                        textContent = dialog.message,&#10;                        onConfirm = {&#10;                            // Stay on AttendanceScreen - no navigation needed&#10;                            // User can try again&#10;                            viewModel.onDialogDismissed()&#10;                        }&#10;                    )&#10;                }&#10;&#10;                is DialogState.LocationError -&gt; {&#10;                    // Show location error dialog&#10;                    DialogHelper.showDialogError(&#10;                        context = navController.context,&#10;                        title = &quot;Error Lokasi&quot;,&#10;                        textContent = dialog.message,&#10;                        onConfirm = {&#10;                            viewModel.onDialogDismissed()&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Handle face verification result from FaceScannerScreen&#10;    LaunchedEffect(Unit) {&#10;        // Get face verification result from savedStateHandle&#10;        val faceVerificationResult = navController.currentBackStackEntry&#10;            ?.savedStateHandle&#10;            ?.getLiveData&lt;Boolean&gt;(&quot;face_verification_result&quot;)&#10;&#10;        faceVerificationResult?.observeForever { isSuccess -&gt;&#10;            if (isSuccess != null) {&#10;                // FIXED: Only process if verification was successful&#10;                // If failed, user should stay on FaceScannerScreen for retry&#10;                if (isSuccess) {&#10;                    // Call ViewModel to handle the successful result&#10;                    viewModel.onFaceVerificationResult(isSuccess)&#10;                } else {&#10;                    // Face verification failed - don't process, let user retry on scanner screen&#10;                    android.util.Log.d(&#10;                        &quot;AttendanceScreen&quot;,&#10;                        &quot;Face verification failed - user should retry on scanner screen&quot;&#10;                    )&#10;                }&#10;&#10;                // Clear the result to prevent re-processing&#10;                navController.currentBackStackEntry&#10;                    ?.savedStateHandle&#10;                    ?.remove&lt;Boolean&gt;(&quot;face_verification_result&quot;)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun AttendanceScreenPreview() {&#10;    Infinite_TrackTheme {&#10;        Box(modifier = Modifier.fillMaxSize()) {&#10;            AttendanceMap(&#10;                modifier = Modifier.fillMaxSize(),&#10;                onMapReady = { }&#10;            )&#10;            AttendanceTopBar(&#10;                modifier = Modifier&#10;                    .align(Alignment.TopCenter)&#10;                    .statusBarsPadding()&#10;                    .padding(horizontal = 20.dp),&#10;                onBackClicked = { },&#10;                onFocusLocationClicked = { }&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/presentation/screen/attendance/AttendanceViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/presentation/screen/attendance/AttendanceViewModel.kt" />
              <option name="originalContent" value="package com.example.infinite_track.presentation.screen.attendance&#10;&#10;import android.util.Log&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.infinite_track.data.soucre.local.preferences.AttendancePreference&#10;import com.example.infinite_track.domain.model.attendance.AttendanceRequestModel&#10;import com.example.infinite_track.domain.model.attendance.Location&#10;import com.example.infinite_track.domain.model.attendance.TodayStatus&#10;import com.example.infinite_track.domain.model.location.LocationResult&#10;import com.example.infinite_track.domain.model.wfa.WfaRecommendation&#10;import com.example.infinite_track.domain.use_case.attendance.CheckInUseCase&#10;import com.example.infinite_track.domain.use_case.attendance.CheckOutUseCase&#10;import com.example.infinite_track.domain.use_case.attendance.GetTodayStatusUseCase&#10;import com.example.infinite_track.domain.use_case.auth.GetLoggedInUserUseCase&#10;import com.example.infinite_track.domain.use_case.location.GetCurrentAddressUseCase&#10;import com.example.infinite_track.domain.use_case.location.GetCurrentCoordinatesUseCase&#10;import com.example.infinite_track.domain.use_case.location.ReverseGeocodeUseCase&#10;import com.example.infinite_track.domain.use_case.wfa.GetWfaRecommendationsUseCase&#10;import com.example.infinite_track.presentation.geofencing.GeofenceManager&#10;import com.example.infinite_track.presentation.navigation.Screen&#10;import com.example.infinite_track.utils.UiState&#10;import com.mapbox.geojson.Point&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;&#10;/**&#10; * Sealed class untuk merepresentasikan target navigasi&#10; */&#10;sealed class NavigationTarget {&#10;    data class FaceScanner(val isCheckIn: Boolean) : NavigationTarget()&#10;    data class WfaBooking(val route: String) : NavigationTarget()&#10;    data class LocationSearch(val params: String) : NavigationTarget()&#10;}&#10;&#10;/**&#10; * Sealed class untuk merepresentasikan state dialog&#10; */&#10;sealed class DialogState {&#10;    data class Success(val message: String) : DialogState()&#10;    data class Error(val message: String) : DialogState()&#10;    data class LocationError(val message: String) : DialogState()&#10;}&#10;&#10;/**&#10; * Sealed class untuk map animation commands&#10; */&#10;sealed class MapAnimationTarget {&#10;    data class AnimateToLocation(val point: Point, val zoomLevel: Double) : MapAnimationTarget()&#10;    data class AnimateToFitBounds(val points: List&lt;Point&gt;) : MapAnimationTarget()&#10;    object ShowLocationError : MapAnimationTarget()&#10;}&#10;&#10;/**&#10; * Simplified state object focused on reactive geofence integration&#10; * Now supports WFO, WFH, and WFA location markers with Pick on Map functionality&#10; * Updated for state-driven architecture&#10; */&#10;data class AttendanceScreenState(&#10;    val uiState: UiState&lt;Unit&gt; = UiState.Loading,&#10;    val todayStatus: TodayStatus? = null,&#10;    val targetLocation: Location? = null, // Keep for backward compatibility&#10;    val wfoLocation: Location? = null,    // Work From Office location&#10;    val wfhLocation: Location? = null,    // Work From Home location&#10;    val wfaRecommendations: List&lt;WfaRecommendation&gt; = emptyList(), // WFA recommendations&#10;    val selectedWfaLocation: WfaRecommendation? = null, // Selected WFA location&#10;    val selectedWfaMarkerInfo: WfaRecommendation? = null, // For showing WFA marker details&#10;    val isWfaModeActive: Boolean = false, // Flag for WFA mode&#10;    val isLoadingWfaRecommendations: Boolean = false, // Loading state for WFA recommendations&#10;    val currentUserAddress: String = &quot;&quot;,&#10;    val currentUserLatitude: Double? = null,&#10;    val currentUserLongitude: Double? = null,&#10;    val isBookingEnabled: Boolean = false,&#10;    val selectedWorkMode: String = &quot;Work From Office&quot;,&#10;    // Map-specific properties&#10;    val targetLocationMarker: Location? = null,&#10;    val selectedMarkerInfo: Location? = null,&#10;    // Pick on Map properties&#10;    val pickedLocation: LocationResult? = null, // Location picked by user on map&#10;    val isPickOnMapModeActive: Boolean = false, // Flag for Pick on Map mode&#10;    val error: String? = null, // Error message for network failures&#10;    // Attendance button state&#10;    val buttonText: String = &quot;Loading...&quot;,&#10;    val isButtonEnabled: Boolean = false,&#10;    val isCheckInMode: Boolean = true, // Track whether we're in check-in or check-out mode&#10;&#10;    // NEW: State-driven properties for navigation and dialogs&#10;    val navigationTarget: NavigationTarget? = null, // Navigation commands&#10;    val activeDialog: DialogState? = null, // Dialog state&#10;    val mapAnimationTarget: MapAnimationTarget? = null // Map animation commands&#10;)&#10;&#10;/**&#10; * Sealed class for attendance events sent to UI - DEPRECATED&#10; * Keep for backward compatibility during migration&#10; */&#10;@Suppress(&quot;DEPRECATION&quot;)&#10;@Deprecated(&quot;Use DialogState in AttendanceScreenState instead&quot;)&#10;sealed class AttendanceEvent {&#10;    data class ShowSuccessDialog(val message: String) : AttendanceEvent()&#10;    data class ShowErrorDialog(val message: String) : AttendanceEvent()&#10;}&#10;&#10;/**&#10; * Simplified ViewModel that is fully reactive to geofence state&#10; * Removed manual GPS tracking and distance calculation logic&#10; * Uses geofence as the single source of truth for validation&#10; * UPDATED: Migrated to fully state-driven architecture&#10; */&#10;@HiltViewModel&#10;class AttendanceViewModel @Inject constructor(&#10;    private val getTodayStatusUseCase: GetTodayStatusUseCase,&#10;    private val getCurrentAddressUseCase: GetCurrentAddressUseCase,&#10;    private val getCurrentCoordinatesUseCase: GetCurrentCoordinatesUseCase,&#10;    private val getWfaRecommendationsUseCase: GetWfaRecommendationsUseCase,&#10;    private val reverseGeocodeUseCase: ReverseGeocodeUseCase,&#10;    private val attendancePreference: AttendancePreference,&#10;    private val geofenceManager: GeofenceManager,&#10;    private val getLoggedInUserUseCase: GetLoggedInUserUseCase,&#10;    // Add UseCase dependencies for attendance operations&#10;    private val checkInUseCase: CheckInUseCase,&#10;    private val checkOutUseCase: CheckOutUseCase&#10;) : ViewModel() {&#10;&#10;    // Main UI state - now the SINGLE source of truth&#10;    private val _uiState = MutableStateFlow(AttendanceScreenState())&#10;    val uiState: StateFlow&lt;AttendanceScreenState&gt; = _uiState.asStateFlow()&#10;&#10;    // Job for UI-focused location updates (display purposes only)&#10;    private var displayLocationJob: Job? = null&#10;&#10;    companion object {&#10;        private const val TAG = &quot;AttendanceViewModel&quot;&#10;        private const val DISPLAY_UPDATE_INTERVAL = 10000L // 10 seconds for UI updates&#10;    }&#10;&#10;    init {&#10;        initializeData()&#10;    }&#10;&#10;    // ===========================================&#10;    // NEW: Functions for consuming state events&#10;    // ===========================================&#10;&#10;    /**&#10;     * Called by UI after navigation is handled&#10;     * Resets navigationTarget to null&#10;     */&#10;    fun onNavigationHandled() {&#10;        _uiState.value = _uiState.value.copy(navigationTarget = null)&#10;    }&#10;&#10;    /**&#10;     * Called by UI after dialog is dismissed&#10;     * Resets activeDialog to null&#10;     */&#10;    fun onDialogDismissed() {&#10;        _uiState.value = _uiState.value.copy(activeDialog = null)&#10;    }&#10;&#10;    /**&#10;     * Called by UI after map animation is completed&#10;     * Resets mapAnimationTarget to null&#10;     */&#10;    fun onMapAnimationHandled() {&#10;        _uiState.value = _uiState.value.copy(mapAnimationTarget = null)&#10;    }&#10;&#10;    /**&#10;     * Initialize data by fetching both WFO and WFH locations&#10;     */&#10;    private fun initializeData() {&#10;        viewModelScope.launch {&#10;            try {&#10;                _uiState.value = _uiState.value.copy(uiState = UiState.Loading)&#10;&#10;                // Fetch both locations concurrently&#10;                fetchTodayStatus()&#10;                fetchUserHomeLocation()&#10;&#10;                // Don't start location updates automatically - let UI control this&#10;&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error initializing data&quot;, e)&#10;                _uiState.value = _uiState.value.copy(&#10;                    uiState = UiState.Error(&quot;Failed to initialize attendance data: ${e.message}&quot;)&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Fetch today status to get WFO location&#10;     * FIXED: Now uses isButtonEnabled from calculateDynamicButtonState directly&#10;     */&#10;    private suspend fun fetchTodayStatus() {&#10;        try {&#10;            getTodayStatusUseCase().onSuccess { todayStatus -&gt;&#10;                Log.d(TAG, &quot;Today status fetched successfully: $todayStatus&quot;)&#10;&#10;                val isBookingEnabled = todayStatus.activeMode.isNotEmpty()&#10;                val selectedMode = todayStatus.activeMode.ifEmpty { &quot;Work From Office&quot; }&#10;&#10;                // Calculate button state based on today's status&#10;                val (buttonText, isButtonEnabled, isCheckInMode) = calculateDynamicButtonState(&#10;                    todayStatus&#10;                )&#10;&#10;                _uiState.value = _uiState.value.copy(&#10;                    todayStatus = todayStatus,&#10;                    targetLocation = todayStatus.activeLocation,&#10;                    wfoLocation = todayStatus.activeLocation, // WFO location from today status&#10;                    targetLocationMarker = todayStatus.activeLocation,&#10;                    isBookingEnabled = isBookingEnabled,&#10;                    selectedWorkMode = selectedMode,&#10;                    // FIXED: Now uses isButtonEnabled from calculateDynamicButtonState&#10;                    buttonText = buttonText,&#10;                    isButtonEnabled = isButtonEnabled,&#10;                    isCheckInMode = isCheckInMode,&#10;                    uiState = UiState.Success(Unit)&#10;                )&#10;&#10;                // Setup geofence for active location (validation purposes)&#10;                todayStatus.activeLocation?.let { location -&gt;&#10;                    setupGeofence(location)&#10;                }&#10;&#10;                // Send initial camera focus event to WFO location&#10;                todayStatus.activeLocation?.let { location -&gt;&#10;                    val wfoPoint = Point.fromLngLat(location.longitude, location.latitude)&#10;                    viewModelScope.launch {&#10;                        _uiState.value = _uiState.value.copy(&#10;                            mapAnimationTarget = MapAnimationTarget.AnimateToLocation(&#10;                                wfoPoint,&#10;                                15.0&#10;                            )&#10;                        )&#10;                    }&#10;                    Log.d(TAG, &quot;Initial camera focus event sent to WFO location&quot;)&#10;                }&#10;&#10;                Log.d(TAG, &quot;WFO location updated: ${todayStatus.activeLocation}&quot;)&#10;                Log.d(&#10;                    TAG,&#10;                    &quot;Button state updated: $buttonText, enabled: $isButtonEnabled, mode: $isCheckInMode&quot;&#10;                )&#10;&#10;            }.onFailure { exception -&gt;&#10;                Log.e(TAG, &quot;Failed to fetch today status&quot;, exception)&#10;                _uiState.value = _uiState.value.copy(&#10;                    uiState = UiState.Error(&quot;Failed to load attendance status: ${exception.message}&quot;),&#10;                    buttonText = &quot;Error&quot;,&#10;                    isButtonEnabled = false&#10;                )&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Unexpected error in fetchTodayStatus&quot;, e)&#10;            _uiState.value = _uiState.value.copy(&#10;                uiState = UiState.Error(&quot;Unexpected error: ${e.message}&quot;),&#10;                buttonText = &quot;Error&quot;,&#10;                isButtonEnabled = false&#10;            )&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Calculate dynamic button state based on today's status&#10;     * Returns Triple(buttonText, isEnabled, isCheckInMode)&#10;     * FIXED: Tombol selalu aktif kecuali sudah selesai absensi - validasi lokasi diserahkan ke backend&#10;     */&#10;    private fun calculateDynamicButtonState(todayStatus: TodayStatus): Triple&lt;String, Boolean, Boolean&gt; {&#10;        return when {&#10;            // PRIORITAS 1: Belum check-in sama sekali (checked_in_at == null)&#10;            // Selalu aktif - biarkan backend yang validasi lokasi&#10;            todayStatus.checkedInAt == null -&gt; {&#10;                Triple(&quot;Check-in di sini&quot;, true, true)&#10;            }&#10;&#10;            // PRIORITAS 2: Sudah check-in, bisa check-out (checked_in_at != null &amp;&amp; can_check_out == true)&#10;            // Selalu aktif - biarkan backend yang validasi lokasi&#10;            todayStatus.checkedInAt != null &amp;&amp; todayStatus.canCheckOut -&gt; {&#10;                Triple(&quot;Check-out di sini&quot;, true, false)&#10;            }&#10;&#10;            // PRIORITAS 3: Sudah selesai absensi hari ini&#10;            // Hanya kondisi ini yang tombolnya nonaktif&#10;            else -&gt; {&#10;                Triple(&quot;Anda sudah absen hari ini&quot;, false, false)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Fetch user home location from logged in user data&#10;     */&#10;    private suspend fun fetchUserHomeLocation() {&#10;        try {&#10;            getLoggedInUserUseCase().collect { user -&gt;&#10;                Log.d(TAG, &quot;User data fetched successfully&quot;)&#10;&#10;                // Extract WFH location from user profile if available&#10;                val wfhLocation = if (user?.latitude != null &amp;&amp; user.longitude != null) {&#10;                    Location(&#10;                        locationId = user.id, // Use user ID as location ID&#10;                        latitude = user.latitude,&#10;                        longitude = user.longitude,&#10;                        radius = user.radius ?: 100, // Default 100m radius if not specified&#10;                        description = user.locationDescription ?: &quot;Work From Home Location&quot;,&#10;                        category = user.locationCategoryName ?: &quot;Home&quot;&#10;                    )&#10;                } else {&#10;                    null // No home location data available&#10;                }&#10;&#10;                _uiState.value = _uiState.value.copy(&#10;                    wfhLocation = wfhLocation&#10;                )&#10;&#10;                Log.d(TAG, &quot;WFH location updated: $wfhLocation&quot;)&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.w(TAG, &quot;Unexpected error in fetchUserHomeLocation&quot;, e)&#10;            // Continue without WFH location&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Setup geofence for validation (background monitoring)&#10;     * UPDATED: Improved integration with new GeofenceManager clean slate approach&#10;     */&#10;    private fun setupGeofence(location: Location) {&#10;        try {&#10;            Log.d(TAG, &quot;Setting up geofence for location: ${location.description}&quot;)&#10;            Log.d(&#10;                TAG,&#10;                &quot;Location details - ID: ${location.locationId}, Lat: ${location.latitude}, Lng: ${location.longitude}, Radius: ${location.radius}m&quot;&#10;            )&#10;&#10;            geofenceManager.addGeofence(&#10;                id = location.locationId.toString(),&#10;                latitude = location.latitude,&#10;                longitude = location.longitude,&#10;                radius = location.radius.toFloat()&#10;            )&#10;&#10;            Log.d(TAG, &quot;Geofence setup request sent for location: ${location.description}&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Failed to setup geofence for location: ${location.description}&quot;, e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Start location updates for display purposes only (UI updates)&#10;     * This runs only while ViewModel is active for better UX&#10;     */&#10;    private fun startDisplayLocationUpdates() {&#10;        displayLocationJob?.cancel()&#10;&#10;        displayLocationJob = viewModelScope.launch {&#10;            while (true) {&#10;                try {&#10;                    updateDisplayLocation()&#10;                    delay(DISPLAY_UPDATE_INTERVAL)&#10;                } catch (e: Exception) {&#10;                    Log.e(TAG, &quot;Error in display location updates&quot;, e)&#10;                    delay(DISPLAY_UPDATE_INTERVAL)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Update location data for display purposes only&#10;     * Does not affect validation logic&#10;     */&#10;    private suspend fun updateDisplayLocation() {&#10;        try {&#10;            // Update current address for display - menggunakan Geocoding API yang sudah diperbaiki&#10;            getCurrentAddressUseCase().onSuccess { address -&gt;&#10;                _uiState.value = _uiState.value.copy(currentUserAddress = address)&#10;                Log.d(TAG, &quot;Display address updated: $address&quot;)&#10;            }.onFailure { exception -&gt;&#10;                Log.w(TAG, &quot;Failed to get display address&quot;, exception)&#10;                // Set fallback address jika gagal&#10;                _uiState.value = _uiState.value.copy(currentUserAddress = &quot;Mengambil alamat...&quot;)&#10;            }&#10;&#10;            // Update current coordinates for map display - menggunakan database fallback untuk display&#10;            getCurrentCoordinatesUseCase(useRealTimeGPS = false).onSuccess { coordinates -&gt;&#10;                val (latitude, longitude) = coordinates&#10;                _uiState.value = _uiState.value.copy(&#10;                    currentUserLatitude = latitude,&#10;                    currentUserLongitude = longitude&#10;                )&#10;                Log.d(TAG, &quot;Display coordinates updated: $latitude, $longitude&quot;)&#10;            }.onFailure { exception -&gt;&#10;                Log.w(TAG, &quot;Failed to get display coordinates&quot;, exception)&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Unexpected error in updateDisplayLocation&quot;, e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Handle work mode selection with Pick on Map integration&#10;     * UPDATED: Added geofence cleanup when switching modes&#10;     */&#10;    fun onWorkModeSelected(mode: String) {&#10;        Log.d(TAG, &quot;Work mode selected: $mode&quot;)&#10;&#10;        // Clean up any existing geofence before switching modes&#10;        Log.d(TAG, &quot;Cleaning up geofences before mode switch...&quot;)&#10;        geofenceManager.removeAllGeofences()&#10;&#10;        _uiState.value = _uiState.value.copy(&#10;            selectedWorkMode = mode,&#10;            isWfaModeActive = mode == &quot;WFA&quot; || mode == &quot;Work From Anywhere&quot;&#10;        )&#10;&#10;        viewModelScope.launch {&#10;            when (mode) {&#10;                &quot;WFA&quot;, &quot;Work From Anywhere&quot; -&gt; {&#10;                    // Reset previous WFA selection and enter Pick on Map mode&#10;                    _uiState.value = _uiState.value.copy(&#10;                        selectedWfaLocation = null,&#10;                        pickedLocation = null&#10;                    )&#10;                    onEnterPickOnMapMode()&#10;                    fetchWfaRecommendations()&#10;                }&#10;&#10;                &quot;Work From Home&quot;, &quot;WFH&quot; -&gt; {&#10;                    onExitPickOnMapMode()&#10;                    _uiState.value.wfhLocation?.let { wfhLocation -&gt;&#10;                        // Setup geofence for WFH location&#10;                        setupGeofence(wfhLocation)&#10;&#10;                        val wfhPoint = Point.fromLngLat(wfhLocation.longitude, wfhLocation.latitude)&#10;                        _uiState.value = _uiState.value.copy(&#10;                            mapAnimationTarget = MapAnimationTarget.AnimateToLocation(&#10;                                point = wfhPoint,&#10;                                zoomLevel = 15.0&#10;                            )&#10;                        )&#10;                        Log.d(TAG, &quot;Auto-focusing camera to WFH location and setting up geofence&quot;)&#10;                    }&#10;                }&#10;&#10;                &quot;Work From Office&quot;, &quot;WFO&quot; -&gt; {&#10;                    onExitPickOnMapMode()&#10;                    _uiState.value.wfoLocation?.let { wfoLocation -&gt;&#10;                        // Setup geofence for WFO location&#10;                        setupGeofence(wfoLocation)&#10;&#10;                        val wfoPoint = Point.fromLngLat(wfoLocation.longitude, wfoLocation.latitude)&#10;                        _uiState.value = _uiState.value.copy(&#10;                            mapAnimationTarget = MapAnimationTarget.AnimateToLocation(&#10;                                point = wfoPoint,&#10;                                zoomLevel = 15.0&#10;                            )&#10;                        )&#10;                        Log.d(TAG, &quot;Auto-focusing camera to WFO location and setting up geofence&quot;)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Fetch WFA recommendations based on current user location&#10;     * Menggunakan GPS real-time, bukan lokasi WFH yang tersimpan&#10;     */&#10;    private fun fetchWfaRecommendations() {&#10;        viewModelScope.launch {&#10;            try {&#10;                Log.d(TAG, &quot;Fetching WFA recommendations - getting fresh GPS location...&quot;)&#10;&#10;                // Set loading state for WFA recommendations&#10;                _uiState.value = _uiState.value.copy(isLoadingWfaRecommendations = true)&#10;&#10;                // PENTING: Gunakan GPS real-time untuk WFA recommendations&#10;                getCurrentCoordinatesUseCase(useRealTimeGPS = true).onSuccess { coordinates -&gt;&#10;                    val (lat, lng) = coordinates&#10;&#10;                    Log.d(TAG, &quot;Using GPS real-time location for WFA: $lat, $lng&quot;)&#10;&#10;                    getWfaRecommendationsUseCase(lat, lng).onSuccess { recommendations -&gt;&#10;                        _uiState.value = _uiState.value.copy(wfaRecommendations = recommendations)&#10;&#10;                        // Send event to zoom out and show all recommendations&#10;                        if (recommendations.isNotEmpty()) {&#10;                            val points =&#10;                                recommendations.map { Point.fromLngLat(it.longitude, it.latitude) }&#10;                            _uiState.value = _uiState.value.copy(&#10;                                mapAnimationTarget = MapAnimationTarget.AnimateToFitBounds(points)&#10;                            )&#10;                            Log.d(&#10;                                TAG,&#10;                                &quot;WFA recommendations fetched: ${recommendations.size} locations&quot;&#10;                            )&#10;                        } else {&#10;                            Log.w(TAG, &quot;No WFA recommendations found for GPS location: $lat, $lng&quot;)&#10;                        }&#10;                    }.onFailure { exception -&gt;&#10;                        Log.e(TAG, &quot;Failed to fetch WFA recommendations&quot;, exception)&#10;                        // Keep empty list on error&#10;                        _uiState.value = _uiState.value.copy(wfaRecommendations = emptyList())&#10;                    }&#10;&#10;                }.onFailure { exception -&gt;&#10;                    Log.e(TAG, &quot;Failed to get GPS location for WFA recommendations&quot;, exception)&#10;                    // Fallback to cached location if GPS fails&#10;                    val lat = _uiState.value.currentUserLatitude ?: return@launch&#10;                    val lng = _uiState.value.currentUserLongitude ?: return@launch&#10;&#10;                    Log.w(TAG, &quot;GPS failed, using cached location for WFA: $lat, $lng&quot;)&#10;&#10;                    getWfaRecommendationsUseCase(lat, lng).onSuccess { recommendations -&gt;&#10;                        _uiState.value = _uiState.value.copy(wfaRecommendations = recommendations)&#10;                        if (recommendations.isNotEmpty()) {&#10;                            val points =&#10;                                recommendations.map { Point.fromLngLat(it.longitude, it.latitude) }&#10;                            _uiState.value = _uiState.value.copy(&#10;                                mapAnimationTarget = MapAnimationTarget.AnimateToFitBounds(points)&#10;                            )&#10;                            Log.d(&#10;                                TAG,&#10;                                &quot;WFA recommendations fetched with cached location: ${recommendations.size} locations&quot;&#10;                            )&#10;                        }&#10;                    }.onFailure { exception -&gt;&#10;                        Log.e(&#10;                            TAG,&#10;                            &quot;Failed to fetch WFA recommendations with cached location&quot;,&#10;                            exception&#10;                        )&#10;                        _uiState.value = _uiState.value.copy(wfaRecommendations = emptyList())&#10;                    }&#10;                }&#10;&#10;                // Reset loading state&#10;                _uiState.value = _uiState.value.copy(isLoadingWfaRecommendations = false)&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Unexpected error in fetchWfaRecommendations&quot;, e)&#10;                _uiState.value = _uiState.value.copy(&#10;                    wfaRecommendations = emptyList(),&#10;                    isLoadingWfaRecommendations = false&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Handle WFA marker click - Updated to show marker details&#10;     */&#10;    fun onWfaMarkerClicked(recommendation: WfaRecommendation) {&#10;        Log.d(TAG, &quot;WFA Marker clicked: ${recommendation.name}&quot;)&#10;        _uiState.value = _uiState.value.copy(&#10;            selectedWfaLocation = recommendation,&#10;            selectedWfaMarkerInfo = recommendation // Show marker details&#10;        )&#10;&#10;        // Focus camera on selected WFA location&#10;        viewModelScope.launch {&#10;            val point = Point.fromLngLat(recommendation.longitude, recommendation.latitude)&#10;            _uiState.value = _uiState.value.copy(&#10;                mapAnimationTarget = MapAnimationTarget.AnimateToLocation(&#10;                    point,&#10;                    16.0&#10;                )&#10;            ) // Zoom closer for selected marker&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Handle WFA marker info dismissal&#10;     */&#10;    fun onDismissWfaMarkerInfo() {&#10;        Log.d(TAG, &quot;WFA marker info dialog dismissed&quot;)&#10;        _uiState.value = _uiState.value.copy(selectedWfaMarkerInfo = null)&#10;    }&#10;&#10;    /**&#10;     * Handle marker info dialog dismissal&#10;     */&#10;    fun onDismissMarkerInfo() {&#10;        Log.d(TAG, &quot;Marker info dialog dismissed&quot;)&#10;        _uiState.value = _uiState.value.copy(&#10;            selectedMarkerInfo = null,&#10;            selectedWfaMarkerInfo = null // Also dismiss WFA marker info&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Handle booking button click&#10;     */&#10;    fun onBookingClicked() {&#10;        if (_uiState.value.isWfaModeActive) {&#10;            _uiState.value.selectedWfaLocation?.let { wfaLocation -&gt;&#10;                Log.d(TAG, &quot;Booking WFA location: ${wfaLocation.name}&quot;)&#10;                // Navigate to WFA booking screen with location data (latitude and longitude only)&#10;                val route = Screen.WfaBooking.createRoute(&#10;                    latitude = wfaLocation.latitude,&#10;                    longitude = wfaLocation.longitude&#10;                    // address is no longer sent - WfaBookingViewModel will fetch it&#10;                )&#10;                viewModelScope.launch {&#10;                    _uiState.value = _uiState.value.copy(&#10;                        navigationTarget = NavigationTarget.WfaBooking(route)&#10;                    )&#10;                }&#10;            } ?: run {&#10;                Log.w(TAG, &quot;Booking clicked in WFA mode but no location selected.&quot;)&#10;            }&#10;        } else {&#10;            Log.d(TAG, &quot;Booking clicked for mode: ${_uiState.value.selectedWorkMode}&quot;)&#10;            // TODO: Implement booking logic for WFO/WFH&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Handle attendance button click - navigates to face scanner&#10;     * FIXED: Uses new Screen.FaceScanner.createRoute with action parameter&#10;     */&#10;    fun onAttendanceButtonClicked() {&#10;        // Use the reactive StateFlow value instead of recalculating&#10;        val isEnabled = _uiState.value.isButtonEnabled&#10;        val buttonText = _uiState.value.buttonText&#10;&#10;        if (!isEnabled) {&#10;            Log.d(TAG, &quot;Attendance button clicked but not enabled (geofence or server restriction)&quot;)&#10;            return&#10;        }&#10;&#10;        val isCheckIn = buttonText.contains(&quot;Check-in&quot;, ignoreCase = true)&#10;        val action = if (isCheckIn) &quot;checkin&quot; else &quot;checkout&quot;&#10;&#10;        Log.d(TAG, &quot;Attendance button clicked - $action&quot;)&#10;&#10;        // Update isCheckInMode state before navigation&#10;        _uiState.value = _uiState.value.copy(isCheckInMode = isCheckIn)&#10;&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(&#10;                navigationTarget = NavigationTarget.FaceScanner(isCheckIn)&#10;            )&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Handle face verification result - GATEWAY after face verification&#10;     * Called from FaceScannerScreen when verification is complete&#10;     */&#10;    fun onFaceVerificationResult(isSuccess: Boolean) {&#10;        Log.d(TAG, &quot;Face verification result: $isSuccess&quot;)&#10;&#10;        if (!isSuccess) {&#10;            Log.d(TAG, &quot;Face verification failed - aborting attendance process&quot;)&#10;            _uiState.value = _uiState.value.copy(&#10;                activeDialog = DialogState.Error(&quot;Verifikasi wajah gagal. Silakan coba lagi.&quot;)&#10;            )&#10;            return&#10;        }&#10;&#10;        // Check current mode and proceed accordingly&#10;        if (_uiState.value.isCheckInMode) {&#10;            proceedWithCheckIn()&#10;        } else {&#10;            proceedWithCheckOut()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Proceed with check-in after successful face verification&#10;     * FIXED: Added proper targetLocation determination logic&#10;     */&#10;    private fun proceedWithCheckIn() {&#10;        viewModelScope.launch {&#10;            try {&#10;                Log.d(TAG, &quot;Proceeding with check-in after face verification&quot;)&#10;&#10;                // Clear any previous error&#10;                _uiState.value = _uiState.value.copy(activeDialog = null)&#10;&#10;                // FIXED: Determine target location based on selected work mode&#10;                val targetLocation = when (_uiState.value.selectedWorkMode) {&#10;                    &quot;Work From Home&quot;, &quot;WFH&quot; -&gt; _uiState.value.wfhLocation&#10;                    &quot;Work From Office&quot;, &quot;WFO&quot; -&gt; _uiState.value.wfoLocation&#10;                    &quot;WFA&quot;, &quot;Work From Anywhere&quot; -&gt; {&#10;                        // For WFA, convert selectedWfaLocation to Location object&#10;                        _uiState.value.selectedWfaLocation?.let { wfaLocation -&gt;&#10;                            Location(&#10;                                locationId = 0, // WFA locations don't have fixed IDs&#10;                                latitude = wfaLocation.latitude,&#10;                                longitude = wfaLocation.longitude,&#10;                                radius = 100, // Default radius for WFA&#10;                                description = wfaLocation.name,&#10;                                category = wfaLocation.category&#10;                            )&#10;                        }&#10;                    }&#10;&#10;                    else -&gt; _uiState.value.wfoLocation // Default to WFO&#10;                }&#10;&#10;                if (targetLocation == null) {&#10;                    _uiState.value = _uiState.value.copy(&#10;                        activeDialog = DialogState.Error(&quot;Target location not available for ${_uiState.value.selectedWorkMode}. Please try again.&quot;)&#10;                    )&#10;                    return@launch&#10;                }&#10;&#10;                // Get user info for the request&#10;                getLoggedInUserUseCase().collect { user -&gt;&#10;                    if (user == null) {&#10;                        _uiState.value = _uiState.value.copy(&#10;                            activeDialog = DialogState.Error(&quot;User information not available. Please try again.&quot;)&#10;                        )&#10;                        return@collect&#10;                    }&#10;&#10;                    // FIXED: Map work mode to correct category_id&#10;                    val categoryId = when (_uiState.value.selectedWorkMode) {&#10;                        &quot;Work From Office&quot;, &quot;WFO&quot; -&gt; 1  // Work From Office&#10;                        &quot;Work From Home&quot;, &quot;WFH&quot; -&gt; 2    // Work From Home&#10;                        &quot;WFA&quot;, &quot;Work From Anywhere&quot; -&gt; 3 // Work From Anywhere&#10;                        else -&gt; 1 // Default to WFO&#10;                    }&#10;&#10;                    // Create attendance request model with proper parameters&#10;                    val attendanceRequest = AttendanceRequestModel(&#10;                        categoryId = categoryId, // Use correct category ID based on work mode&#10;                        latitude = 0.0, // Will be updated by UseCase with real-time GPS&#10;                        longitude = 0.0, // Will be updated by UseCase with real-time GPS&#10;                        notes = &quot;Check-in via mobile app&quot;,&#10;                        bookingId = null, // No booking for regular check-in&#10;                        type = &quot;checkin&quot;&#10;                    )&#10;&#10;                    // FIXED: Call CheckInUseCase with both request and target location&#10;                    checkInUseCase(attendanceRequest, targetLocation).onSuccess { activeSession -&gt;&#10;                        Log.d(TAG, &quot;Check-in successful: $activeSession&quot;)&#10;&#10;                        // Refresh today's status to get updated data&#10;                        fetchTodayStatus()&#10;&#10;                        // Send success event to UI with appropriate message&#10;                        _uiState.value = _uiState.value.copy(&#10;                            activeDialog = DialogState.Success(&quot;Check-in berhasil! Selamat bekerja hari ini.&quot;)&#10;                        )&#10;&#10;                    }.onFailure { exception -&gt;&#10;                        Log.e(TAG, &quot;Check-in failed&quot;, exception)&#10;&#10;                        // Send error event to UI with dynamic message from server&#10;                        _uiState.value = _uiState.value.copy(&#10;                            activeDialog = DialogState.Error(&#10;                                exception.message ?: &quot;Check-in gagal. Silakan coba lagi.&quot;&#10;                            )&#10;                        )&#10;                    }&#10;                }&#10;&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error in proceedWithCheckIn&quot;, e)&#10;                _uiState.value = _uiState.value.copy(&#10;                    activeDialog = DialogState.Error(&quot;Unexpected error during check-in: ${e.message}&quot;)&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Proceed with check-out after successful face verification&#10;     * PRIVATE - only called from onFaceVerificationResult&#10;     */&#10;    private fun proceedWithCheckOut() {&#10;        viewModelScope.launch {&#10;            try {&#10;                Log.d(TAG, &quot;Proceeding with check-out after face verification&quot;)&#10;&#10;                // Clear any previous error&#10;                _uiState.value = _uiState.value.copy(activeDialog = null)&#10;&#10;                // Call CheckOutUseCase - it will handle everything internally&#10;                checkOutUseCase().onSuccess { activeSession -&gt;&#10;                    Log.d(TAG, &quot;Check-out successful: $activeSession&quot;)&#10;&#10;                    // Refresh today's status to get updated data&#10;                    fetchTodayStatus()&#10;&#10;                    // Send success event to UI with appropriate message&#10;                    _uiState.value = _uiState.value.copy(&#10;                        activeDialog = DialogState.Success(&quot;Check-out berhasil! Terima kasih atas kerja keras Anda hari ini.&quot;)&#10;                    )&#10;&#10;                }.onFailure { exception -&gt;&#10;                    Log.e(TAG, &quot;Check-out failed&quot;, exception)&#10;&#10;                    // Send error event to UI with dynamic message from server&#10;                    _uiState.value = _uiState.value.copy(&#10;                        activeDialog = DialogState.Error(&#10;                            exception.message ?: &quot;Check-out gagal. Silakan coba lagi.&quot;&#10;                        )&#10;                    )&#10;                }&#10;&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error in proceedWithCheckOut&quot;, e)&#10;                _uiState.value = _uiState.value.copy(&#10;                    activeDialog = DialogState.Error(&quot;Unexpected error during check-out: ${e.message}&quot;)&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Clear error message&#10;     */&#10;    fun clearError() {&#10;        _uiState.value = _uiState.value.copy(activeDialog = null)&#10;    }&#10;&#10;    /**&#10;     * Handle map marker click&#10;     */&#10;    fun onMarkerClicked(location: Location) {&#10;        Log.d(TAG, &quot;Marker clicked for location: ${location.description}&quot;)&#10;        _uiState.value = _uiState.value.copy(selectedMarkerInfo = location)&#10;    }&#10;&#10;    /**&#10;     * Handle focus location button click&#10;     * This should ONLY focus on current user location, not work mode locations&#10;     * Always gets fresh location data when clicked&#10;     */&#10;    fun onFocusLocationClicked() {&#10;        Log.d(TAG, &quot;=== FOCUS LOCATION BUTTON CLICKED ===&quot;)&#10;        Log.d(TAG, &quot;Current work mode: ${_uiState.value.selectedWorkMode}&quot;)&#10;        Log.d(TAG, &quot;Current WFH location: ${_uiState.value.wfhLocation}&quot;)&#10;        Log.d(TAG, &quot;Getting fresh GPS coordinates...&quot;)&#10;&#10;        viewModelScope.launch {&#10;            try {&#10;                // PENTING: Gunakan GPS real-time, bukan dari database&#10;                getCurrentCoordinatesUseCase(useRealTimeGPS = true).onSuccess { coordinates -&gt;&#10;                    val (latitude, longitude) = coordinates&#10;&#10;                    Log.d(TAG, &quot;=== FRESH GPS COORDINATES RECEIVED ===&quot;)&#10;                    Log.d(TAG, &quot;GPS Real-time Latitude: $latitude&quot;)&#10;                    Log.d(TAG, &quot;GPS Real-time Longitude: $longitude&quot;)&#10;                    Log.d(TAG, &quot;WFH Latitude: ${_uiState.value.wfhLocation?.latitude}&quot;)&#10;                    Log.d(TAG, &quot;WFH Longitude: ${_uiState.value.wfhLocation?.longitude}&quot;)&#10;&#10;                    // Pastikan koordinat berbeda dari WFH&#10;                    if (latitude == _uiState.value.wfhLocation?.latitude &amp;&amp;&#10;                        longitude == _uiState.value.wfhLocation?.longitude&#10;                    ) {&#10;                        Log.w(TAG, &quot;WARNING: GPS coordinates sama dengan WFH location!&quot;)&#10;                        Log.w(TAG, &quot;Ini mungkin karena GPS masih menggunakan cached location&quot;)&#10;                    }&#10;&#10;                    // Update state untuk immediate display&#10;                    _uiState.value = _uiState.value.copy(&#10;                        currentUserLatitude = latitude,&#10;                        currentUserLongitude = longitude&#10;                    )&#10;&#10;                    // Send map animation event&#10;                    val focusPoint = Point.fromLngLat(longitude, latitude)&#10;                    _uiState.value = _uiState.value.copy(&#10;                        mapAnimationTarget = MapAnimationTarget.AnimateToLocation(&#10;                            point = focusPoint,&#10;                            zoomLevel = 15.0&#10;                        )&#10;                    )&#10;&#10;                    Log.d(TAG, &quot;=== MAP ANIMATION SENT ===&quot;)&#10;                    Log.d(TAG, &quot;Focus point: ${focusPoint.latitude()}, ${focusPoint.longitude()}&quot;)&#10;                    Log.d(TAG, &quot;This should be your CURRENT GPS location, NOT your home location!&quot;)&#10;                }.onFailure { exception -&gt;&#10;                    Log.e(TAG, &quot;=== GPS LOCATION FAILED ===&quot;)&#10;                    Log.e(TAG, &quot;Failed to get current GPS location: ${exception.message}&quot;)&#10;                    _uiState.value = _uiState.value.copy(&#10;                        mapAnimationTarget = MapAnimationTarget.ShowLocationError&#10;                    )&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;=== UNEXPECTED ERROR ===&quot;)&#10;                Log.e(TAG, &quot;Error in onFocusLocationClicked: ${e.message}&quot;)&#10;                _uiState.value = _uiState.value.copy(&#10;                    mapAnimationTarget = MapAnimationTarget.ShowLocationError&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Called when the map is ready to receive commands&#10;     * This will trigger initial camera focus to WFO location&#10;     */&#10;    fun onMapReady() {&#10;        Log.d(TAG, &quot;Map is ready, focusing to WFO location&quot;)&#10;        viewModelScope.launch {&#10;            _uiState.value.wfoLocation?.let { wfoLocation -&gt;&#10;                val wfoPoint = Point.fromLngLat(wfoLocation.longitude, wfoLocation.latitude)&#10;                _uiState.value = _uiState.value.copy(&#10;                    mapAnimationTarget = MapAnimationTarget.AnimateToLocation(&#10;                        point = wfoPoint,&#10;                        zoomLevel = 15.0&#10;                    )&#10;                )&#10;                Log.d(TAG, &quot;Initial camera focus sent to WFO location&quot;)&#10;            } ?: run {&#10;                Log.w(TAG, &quot;WFO location not available for initial focus&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Start location updates for display purposes&#10;     * This should be called by UI when location permissions are granted&#10;     */&#10;    fun startLocationUpdates() {&#10;        Log.d(TAG, &quot;Starting location updates for display&quot;)&#10;        startDisplayLocationUpdates()&#10;    }&#10;&#10;    /**&#10;     * Handle selected location from LocationSearchScreen&#10;     */&#10;    fun onLocationSelected(location: LocationResult) {&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(&#10;                selectedWfaLocation = WfaRecommendation(&#10;                    name = location.placeName,&#10;                    address = location.address,&#10;                    latitude = location.latitude,&#10;                    longitude = location.longitude,&#10;                    score = 0.0, // Default score for manually selected location&#10;                    label = &quot;Manual Selection&quot;, // Default label for manually selected location&#10;                    category = &quot;Custom&quot;, // Default category for manually selected location&#10;                    distance = 0.0 // Distance will be calculated based on current location&#10;                ),&#10;                isWfaModeActive = true&#10;            )&#10;&#10;            // Animate map to the selected location&#10;            _uiState.value = _uiState.value.copy(&#10;                mapAnimationTarget = MapAnimationTarget.AnimateToLocation(&#10;                    Point.fromLngLat(location.longitude, location.latitude),&#10;                    15.0&#10;                )&#10;            )&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Enter Pick on Map mode - enables crosshair and map interaction&#10;     */&#10;    fun onEnterPickOnMapMode() {&#10;        Log.d(TAG, &quot;Entering Pick on Map mode&quot;)&#10;        _uiState.value = _uiState.value.copy(&#10;            isPickOnMapModeActive = true,&#10;            pickedLocation = null // Reset any previously picked location&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Exit Pick on Map mode - disables crosshair and map interaction&#10;     */&#10;    fun onExitPickOnMapMode() {&#10;        Log.d(TAG, &quot;Exiting Pick on Map mode&quot;)&#10;        _uiState.value = _uiState.value.copy(&#10;            isPickOnMapModeActive = false,&#10;            pickedLocation = null&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Handle map idle event - called when user stops moving the map&#10;     * Performs reverse geocoding for the center point of the map&#10;     */&#10;    fun onMapIdle(centerPoint: Point) {&#10;        // Only perform reverse geocoding if Pick on Map mode is active&#10;        if (!_uiState.value.isPickOnMapModeActive) return&#10;&#10;        viewModelScope.launch {&#10;            try {&#10;                Log.d(&#10;                    TAG,&#10;                    &quot;Map idle detected in Pick on Map mode: ${centerPoint.latitude()}, ${centerPoint.longitude()}&quot;&#10;                )&#10;&#10;                // Perform reverse geocoding for the center point&#10;                reverseGeocodeUseCase(&#10;                    latitude = centerPoint.latitude(),&#10;                    longitude = centerPoint.longitude()&#10;                ).onSuccess { locationResult -&gt;&#10;                    Log.d(TAG, &quot;Reverse geocoding successful: ${locationResult.placeName}&quot;)&#10;&#10;                    // Update the picked location&#10;                    _uiState.value = _uiState.value.copy(&#10;                        pickedLocation = locationResult,&#10;                        selectedWfaLocation = WfaRecommendation(&#10;                            name = locationResult.placeName,&#10;                            address = locationResult.address,&#10;                            latitude = locationResult.latitude,&#10;                            longitude = locationResult.longitude,&#10;                            score = 0.0,&#10;                            label = &quot;Picked on Map&quot;,&#10;                            category = &quot;Manual Selection&quot;,&#10;                            distance = 0.0&#10;                        )&#10;                    )&#10;                }.onFailure { exception -&gt;&#10;                    Log.e(TAG, &quot;Reverse geocoding failed&quot;, exception)&#10;&#10;                    // Don't create fallback location, instead show error and keep picked location null&#10;                    _uiState.value = _uiState.value.copy(&#10;                        pickedLocation = null, // Ensure picked location is null&#10;                        selectedWfaLocation = null, // Clear any selected WFA location&#10;                        // Show error message in BottomSheet&#10;                        error = &quot;Gagal mendapatkan detail lokasi. Periksa koneksi Anda.&quot;&#10;                    )&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Unexpected error in onMapIdle&quot;, e)&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        displayLocationJob?.cancel()&#10;&#10;        // Clean up geofence when ViewModel is cleared&#10;        _uiState.value.targetLocation?.let { location -&gt;&#10;            geofenceManager.removeGeofence(location.locationId.toString())&#10;        }&#10;&#10;        Log.d(TAG, &quot;ViewModel cleared, display location tracking stopped&quot;)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.infinite_track.presentation.screen.attendance&#10;&#10;import android.util.Log&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.infinite_track.data.soucre.local.preferences.AttendancePreference&#10;import com.example.infinite_track.domain.model.attendance.AttendanceRequestModel&#10;import com.example.infinite_track.domain.model.attendance.Location&#10;import com.example.infinite_track.domain.model.attendance.TodayStatus&#10;import com.example.infinite_track.domain.model.location.LocationResult&#10;import com.example.infinite_track.domain.model.wfa.WfaRecommendation&#10;import com.example.infinite_track.domain.use_case.attendance.CheckInUseCase&#10;import com.example.infinite_track.domain.use_case.attendance.CheckOutUseCase&#10;import com.example.infinite_track.domain.use_case.attendance.GetTodayStatusUseCase&#10;import com.example.infinite_track.domain.use_case.auth.GetLoggedInUserUseCase&#10;import com.example.infinite_track.domain.use_case.location.GetCurrentAddressUseCase&#10;import com.example.infinite_track.domain.use_case.location.GetCurrentCoordinatesUseCase&#10;import com.example.infinite_track.domain.use_case.location.ReverseGeocodeUseCase&#10;import com.example.infinite_track.domain.use_case.wfa.GetWfaRecommendationsUseCase&#10;import com.example.infinite_track.presentation.geofencing.GeofenceManager&#10;import com.example.infinite_track.presentation.navigation.Screen&#10;import com.example.infinite_track.utils.UiState&#10;import com.mapbox.geojson.Point&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;&#10;/**&#10; * Sealed class untuk merepresentasikan target navigasi&#10; */&#10;sealed class NavigationTarget {&#10;    data class FaceScanner(val isCheckIn: Boolean) : NavigationTarget()&#10;    data class WfaBooking(val route: String) : NavigationTarget()&#10;    data class LocationSearch(val params: String) : NavigationTarget()&#10;}&#10;&#10;/**&#10; * Sealed class untuk merepresentasikan state dialog&#10; */&#10;sealed class DialogState {&#10;    data class Success(val message: String) : DialogState()&#10;    data class Error(val message: String) : DialogState()&#10;    data class LocationError(val message: String) : DialogState()&#10;}&#10;&#10;/**&#10; * Sealed class untuk map animation commands&#10; */&#10;sealed class MapAnimationTarget {&#10;    data class AnimateToLocation(val point: Point, val zoomLevel: Double) : MapAnimationTarget()&#10;    data class AnimateToFitBounds(val points: List&lt;Point&gt;) : MapAnimationTarget()&#10;    object ShowLocationError : MapAnimationTarget()&#10;}&#10;&#10;/**&#10; * Simplified state object focused on reactive geofence integration&#10; * Now supports WFO, WFH, and WFA location markers with Pick on Map functionality&#10; * Updated for state-driven architecture&#10; */&#10;data class AttendanceScreenState(&#10;    val uiState: UiState&lt;Unit&gt; = UiState.Loading,&#10;    val todayStatus: TodayStatus? = null,&#10;    val targetLocation: Location? = null, // Keep for backward compatibility&#10;    val wfoLocation: Location? = null,    // Work From Office location&#10;    val wfhLocation: Location? = null,    // Work From Home location&#10;    val wfaRecommendations: List&lt;WfaRecommendation&gt; = emptyList(), // WFA recommendations&#10;    val selectedWfaLocation: WfaRecommendation? = null, // Selected WFA location&#10;    val selectedWfaMarkerInfo: WfaRecommendation? = null, // For showing WFA marker details&#10;    val isWfaModeActive: Boolean = false, // Flag for WFA mode&#10;    val isLoadingWfaRecommendations: Boolean = false, // Loading state for WFA recommendations&#10;    val currentUserAddress: String = &quot;&quot;,&#10;    val currentUserLatitude: Double? = null,&#10;    val currentUserLongitude: Double? = null,&#10;    val isBookingEnabled: Boolean = false,&#10;    val selectedWorkMode: String = &quot;Work From Office&quot;,&#10;    // Map-specific properties&#10;    val targetLocationMarker: Location? = null,&#10;    val selectedMarkerInfo: Location? = null,&#10;    // Pick on Map properties&#10;    val pickedLocation: LocationResult? = null, // Location picked by user on map&#10;    val isPickOnMapModeActive: Boolean = false, // Flag for Pick on Map mode&#10;    val error: String? = null, // Error message for network failures&#10;    // Attendance button state&#10;    val buttonText: String = &quot;Loading...&quot;,&#10;    val isButtonEnabled: Boolean = false,&#10;    val isCheckInMode: Boolean = true, // Track whether we're in check-in or check-out mode&#10;&#10;    // State-driven properties for navigation and dialogs&#10;    val navigationTarget: NavigationTarget? = null, // Navigation commands&#10;    val activeDialog: DialogState? = null, // Dialog state&#10;    val mapAnimationTarget: MapAnimationTarget? = null // Map animation commands&#10;)&#10;&#10;/**&#10; * Simplified ViewModel that is fully reactive to geofence state&#10; * Removed manual GPS tracking and distance calculation logic&#10; * Uses geofence as the single source of truth for validation&#10; * UPDATED: Migrated to fully state-driven architecture&#10; */&#10;@HiltViewModel&#10;class AttendanceViewModel @Inject constructor(&#10;    private val getTodayStatusUseCase: GetTodayStatusUseCase,&#10;    private val getCurrentAddressUseCase: GetCurrentAddressUseCase,&#10;    private val getCurrentCoordinatesUseCase: GetCurrentCoordinatesUseCase,&#10;    private val getWfaRecommendationsUseCase: GetWfaRecommendationsUseCase,&#10;    private val reverseGeocodeUseCase: ReverseGeocodeUseCase,&#10;    private val attendancePreference: AttendancePreference,&#10;    private val geofenceManager: GeofenceManager,&#10;    private val getLoggedInUserUseCase: GetLoggedInUserUseCase,&#10;    // Add UseCase dependencies for attendance operations&#10;    private val checkInUseCase: CheckInUseCase,&#10;    private val checkOutUseCase: CheckOutUseCase&#10;) : ViewModel() {&#10;&#10;    // Main UI state - now the SINGLE source of truth&#10;    private val _uiState = MutableStateFlow(AttendanceScreenState())&#10;    val uiState: StateFlow&lt;AttendanceScreenState&gt; = _uiState.asStateFlow()&#10;&#10;    // Job for UI-focused location updates (display purposes only)&#10;    private var displayLocationJob: Job? = null&#10;&#10;    companion object {&#10;        private const val TAG = &quot;AttendanceViewModel&quot;&#10;        private const val DISPLAY_UPDATE_INTERVAL = 10000L // 10 seconds for UI updates&#10;    }&#10;&#10;    init {&#10;        initializeData()&#10;    }&#10;&#10;    // ===========================================&#10;    // Functions for consuming state events&#10;    // ===========================================&#10;&#10;    /**&#10;     * Called by UI after navigation is handled&#10;     * Resets navigationTarget to null&#10;     */&#10;    fun onNavigationHandled() {&#10;        _uiState.value = _uiState.value.copy(navigationTarget = null)&#10;    }&#10;&#10;    /**&#10;     * Called by UI after dialog is dismissed&#10;     * Resets activeDialog to null&#10;     */&#10;    fun onDialogDismissed() {&#10;        _uiState.value = _uiState.value.copy(activeDialog = null)&#10;    }&#10;&#10;    /**&#10;     * Called by UI after map animation is completed&#10;     * Resets mapAnimationTarget to null&#10;     */&#10;    fun onMapAnimationHandled() {&#10;        _uiState.value = _uiState.value.copy(mapAnimationTarget = null)&#10;    }&#10;&#10;    /**&#10;     * Initialize data by fetching both WFO and WFH locations&#10;     */&#10;    private fun initializeData() {&#10;        viewModelScope.launch {&#10;            try {&#10;                _uiState.value = _uiState.value.copy(uiState = UiState.Loading)&#10;&#10;                // Fetch both locations concurrently&#10;                fetchTodayStatus()&#10;                fetchUserHomeLocation()&#10;&#10;                // Don't start location updates automatically - let UI control this&#10;&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error initializing data&quot;, e)&#10;                _uiState.value = _uiState.value.copy(&#10;                    uiState = UiState.Error(&quot;Failed to initialize attendance data: ${e.message}&quot;)&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Fetch today status to get WFO location&#10;     * FIXED: Now uses isButtonEnabled from calculateDynamicButtonState directly&#10;     */&#10;    private suspend fun fetchTodayStatus() {&#10;        try {&#10;            getTodayStatusUseCase().onSuccess { todayStatus -&gt;&#10;                Log.d(TAG, &quot;Today status fetched successfully: $todayStatus&quot;)&#10;&#10;                val isBookingEnabled = todayStatus.activeMode.isNotEmpty()&#10;                val selectedMode = todayStatus.activeMode.ifEmpty { &quot;Work From Office&quot; }&#10;&#10;                // Calculate button state based on today's status&#10;                val (buttonText, isButtonEnabled, isCheckInMode) = calculateDynamicButtonState(&#10;                    todayStatus&#10;                )&#10;&#10;                _uiState.value = _uiState.value.copy(&#10;                    todayStatus = todayStatus,&#10;                    targetLocation = todayStatus.activeLocation,&#10;                    wfoLocation = todayStatus.activeLocation, // WFO location from today status&#10;                    targetLocationMarker = todayStatus.activeLocation,&#10;                    isBookingEnabled = isBookingEnabled,&#10;                    selectedWorkMode = selectedMode,&#10;                    // FIXED: Now uses isButtonEnabled from calculateDynamicButtonState&#10;                    buttonText = buttonText,&#10;                    isButtonEnabled = isButtonEnabled,&#10;                    isCheckInMode = isCheckInMode,&#10;                    uiState = UiState.Success(Unit)&#10;                )&#10;&#10;                // Setup geofence for active location (validation purposes)&#10;                todayStatus.activeLocation?.let { location -&gt;&#10;                    setupGeofence(location)&#10;                }&#10;&#10;                // Send initial camera focus event to WFO location&#10;                todayStatus.activeLocation?.let { location -&gt;&#10;                    val wfoPoint = Point.fromLngLat(location.longitude, location.latitude)&#10;                    viewModelScope.launch {&#10;                        _uiState.value = _uiState.value.copy(&#10;                            mapAnimationTarget = MapAnimationTarget.AnimateToLocation(&#10;                                wfoPoint,&#10;                                15.0&#10;                            )&#10;                        )&#10;                    }&#10;                    Log.d(TAG, &quot;Initial camera focus event sent to WFO location&quot;)&#10;                }&#10;&#10;                Log.d(TAG, &quot;WFO location updated: ${todayStatus.activeLocation}&quot;)&#10;                Log.d(&#10;                    TAG,&#10;                    &quot;Button state updated: $buttonText, enabled: $isButtonEnabled, mode: $isCheckInMode&quot;&#10;                )&#10;&#10;            }.onFailure { exception -&gt;&#10;                Log.e(TAG, &quot;Failed to fetch today status&quot;, exception)&#10;                _uiState.value = _uiState.value.copy(&#10;                    uiState = UiState.Error(&quot;Failed to load attendance status: ${exception.message}&quot;),&#10;                    buttonText = &quot;Error&quot;,&#10;                    isButtonEnabled = false&#10;                )&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Unexpected error in fetchTodayStatus&quot;, e)&#10;            _uiState.value = _uiState.value.copy(&#10;                uiState = UiState.Error(&quot;Unexpected error: ${e.message}&quot;),&#10;                buttonText = &quot;Error&quot;,&#10;                isButtonEnabled = false&#10;            )&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Calculate dynamic button state based on today's status&#10;     * Returns Triple(buttonText, isEnabled, isCheckInMode)&#10;     * FIXED: Tombol selalu aktif kecuali sudah selesai absensi - validasi lokasi diserahkan ke backend&#10;     */&#10;    private fun calculateDynamicButtonState(todayStatus: TodayStatus): Triple&lt;String, Boolean, Boolean&gt; {&#10;        return when {&#10;            // PRIORITAS 1: Belum check-in sama sekali (checked_in_at == null)&#10;            // Selalu aktif - biarkan backend yang validasi lokasi&#10;            todayStatus.checkedInAt == null -&gt; {&#10;                Triple(&quot;Check-in di sini&quot;, true, true)&#10;            }&#10;&#10;            // PRIORITAS 2: Sudah check-in, bisa check-out (checked_in_at != null &amp;&amp; can_check_out == true)&#10;            // Selalu aktif - biarkan backend yang validasi lokasi&#10;            todayStatus.checkedInAt != null &amp;&amp; todayStatus.canCheckOut -&gt; {&#10;                Triple(&quot;Check-out di sini&quot;, true, false)&#10;            }&#10;&#10;            // PRIORITAS 3: Sudah selesai absensi hari ini&#10;            // Hanya kondisi ini yang tombolnya nonaktif&#10;            else -&gt; {&#10;                Triple(&quot;Anda sudah absen hari ini&quot;, false, false)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Fetch user home location from logged in user data&#10;     */&#10;    private suspend fun fetchUserHomeLocation() {&#10;        try {&#10;            getLoggedInUserUseCase().collect { user -&gt;&#10;                Log.d(TAG, &quot;User data fetched successfully&quot;)&#10;&#10;                // Extract WFH location from user profile if available&#10;                val wfhLocation = if (user?.latitude != null &amp;&amp; user.longitude != null) {&#10;                    Location(&#10;                        locationId = user.id, // Use user ID as location ID&#10;                        latitude = user.latitude,&#10;                        longitude = user.longitude,&#10;                        radius = user.radius ?: 100, // Default 100m radius if not specified&#10;                        description = user.locationDescription ?: &quot;Work From Home Location&quot;,&#10;                        category = user.locationCategoryName ?: &quot;Home&quot;&#10;                    )&#10;                } else {&#10;                    null // No home location data available&#10;                }&#10;&#10;                _uiState.value = _uiState.value.copy(&#10;                    wfhLocation = wfhLocation&#10;                )&#10;&#10;                Log.d(TAG, &quot;WFH location updated: $wfhLocation&quot;)&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.w(TAG, &quot;Unexpected error in fetchUserHomeLocation&quot;, e)&#10;            // Continue without WFH location&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Setup geofence for validation (background monitoring)&#10;     * UPDATED: Improved integration with new GeofenceManager clean slate approach&#10;     */&#10;    private fun setupGeofence(location: Location) {&#10;        try {&#10;            Log.d(TAG, &quot;Setting up geofence for location: ${location.description}&quot;)&#10;            Log.d(&#10;                TAG,&#10;                &quot;Location details - ID: ${location.locationId}, Lat: ${location.latitude}, Lng: ${location.longitude}, Radius: ${location.radius}m&quot;&#10;            )&#10;&#10;            geofenceManager.addGeofence(&#10;                id = location.locationId.toString(),&#10;                latitude = location.latitude,&#10;                longitude = location.longitude,&#10;                radius = location.radius.toFloat()&#10;            )&#10;&#10;            Log.d(TAG, &quot;Geofence setup request sent for location: ${location.description}&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Failed to setup geofence for location: ${location.description}&quot;, e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Start location updates for display purposes only (UI updates)&#10;     * This runs only while ViewModel is active for better UX&#10;     */&#10;    private fun startDisplayLocationUpdates() {&#10;        displayLocationJob?.cancel()&#10;&#10;        displayLocationJob = viewModelScope.launch {&#10;            while (true) {&#10;                try {&#10;                    updateDisplayLocation()&#10;                    delay(DISPLAY_UPDATE_INTERVAL)&#10;                } catch (e: Exception) {&#10;                    Log.e(TAG, &quot;Error in display location updates&quot;, e)&#10;                    delay(DISPLAY_UPDATE_INTERVAL)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Update location data for display purposes only&#10;     * Does not affect validation logic&#10;     */&#10;    private suspend fun updateDisplayLocation() {&#10;        try {&#10;            // Update current address for display - menggunakan Geocoding API yang sudah diperbaiki&#10;            getCurrentAddressUseCase().onSuccess { address -&gt;&#10;                _uiState.value = _uiState.value.copy(currentUserAddress = address)&#10;                Log.d(TAG, &quot;Display address updated: $address&quot;)&#10;            }.onFailure { exception -&gt;&#10;                Log.w(TAG, &quot;Failed to get display address&quot;, exception)&#10;                // Set fallback address jika gagal&#10;                _uiState.value = _uiState.value.copy(currentUserAddress = &quot;Mengambil alamat...&quot;)&#10;            }&#10;&#10;            // Update current coordinates for map display - menggunakan database fallback untuk display&#10;            getCurrentCoordinatesUseCase(useRealTimeGPS = false).onSuccess { coordinates -&gt;&#10;                val (latitude, longitude) = coordinates&#10;                _uiState.value = _uiState.value.copy(&#10;                    currentUserLatitude = latitude,&#10;                    currentUserLongitude = longitude&#10;                )&#10;                Log.d(TAG, &quot;Display coordinates updated: $latitude, $longitude&quot;)&#10;            }.onFailure { exception -&gt;&#10;                Log.w(TAG, &quot;Failed to get display coordinates&quot;, exception)&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Unexpected error in updateDisplayLocation&quot;, e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Handle work mode selection with Pick on Map integration&#10;     * UPDATED: Added geofence cleanup when switching modes&#10;     */&#10;    fun onWorkModeSelected(mode: String) {&#10;        Log.d(TAG, &quot;Work mode selected: $mode&quot;)&#10;&#10;        // Clean up any existing geofence before switching modes&#10;        Log.d(TAG, &quot;Cleaning up geofences before mode switch...&quot;)&#10;        geofenceManager.removeAllGeofences()&#10;&#10;        _uiState.value = _uiState.value.copy(&#10;            selectedWorkMode = mode,&#10;            isWfaModeActive = mode == &quot;WFA&quot; || mode == &quot;Work From Anywhere&quot;&#10;        )&#10;&#10;        viewModelScope.launch {&#10;            when (mode) {&#10;                &quot;WFA&quot;, &quot;Work From Anywhere&quot; -&gt; {&#10;                    // Reset previous WFA selection and enter Pick on Map mode&#10;                    _uiState.value = _uiState.value.copy(&#10;                        selectedWfaLocation = null,&#10;                        pickedLocation = null&#10;                    )&#10;                    onEnterPickOnMapMode()&#10;                    fetchWfaRecommendations()&#10;                }&#10;&#10;                &quot;Work From Home&quot;, &quot;WFH&quot; -&gt; {&#10;                    onExitPickOnMapMode()&#10;                    _uiState.value.wfhLocation?.let { wfhLocation -&gt;&#10;                        // Setup geofence for WFH location&#10;                        setupGeofence(wfhLocation)&#10;&#10;                        val wfhPoint = Point.fromLngLat(wfhLocation.longitude, wfhLocation.latitude)&#10;                        _uiState.value = _uiState.value.copy(&#10;                            mapAnimationTarget = MapAnimationTarget.AnimateToLocation(&#10;                                point = wfhPoint,&#10;                                zoomLevel = 15.0&#10;                            )&#10;                        )&#10;                        Log.d(TAG, &quot;Auto-focusing camera to WFH location and setting up geofence&quot;)&#10;                    }&#10;                }&#10;&#10;                &quot;Work From Office&quot;, &quot;WFO&quot; -&gt; {&#10;                    onExitPickOnMapMode()&#10;                    _uiState.value.wfoLocation?.let { wfoLocation -&gt;&#10;                        // Setup geofence for WFO location&#10;                        setupGeofence(wfoLocation)&#10;&#10;                        val wfoPoint = Point.fromLngLat(wfoLocation.longitude, wfoLocation.latitude)&#10;                        _uiState.value = _uiState.value.copy(&#10;                            mapAnimationTarget = MapAnimationTarget.AnimateToLocation(&#10;                                point = wfoPoint,&#10;                                zoomLevel = 15.0&#10;                            )&#10;                        )&#10;                        Log.d(TAG, &quot;Auto-focusing camera to WFO location and setting up geofence&quot;)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Fetch WFA recommendations based on current user location&#10;     * Menggunakan GPS real-time, bukan lokasi WFH yang tersimpan&#10;     */&#10;    private fun fetchWfaRecommendations() {&#10;        viewModelScope.launch {&#10;            try {&#10;                Log.d(TAG, &quot;Fetching WFA recommendations - getting fresh GPS location...&quot;)&#10;&#10;                // Set loading state for WFA recommendations&#10;                _uiState.value = _uiState.value.copy(isLoadingWfaRecommendations = true)&#10;&#10;                // PENTING: Gunakan GPS real-time untuk WFA recommendations&#10;                getCurrentCoordinatesUseCase(useRealTimeGPS = true).onSuccess { coordinates -&gt;&#10;                    val (lat, lng) = coordinates&#10;&#10;                    Log.d(TAG, &quot;Using GPS real-time location for WFA: $lat, $lng&quot;)&#10;&#10;                    getWfaRecommendationsUseCase(lat, lng).onSuccess { recommendations -&gt;&#10;                        _uiState.value = _uiState.value.copy(wfaRecommendations = recommendations)&#10;&#10;                        // Send event to zoom out and show all recommendations&#10;                        if (recommendations.isNotEmpty()) {&#10;                            val points =&#10;                                recommendations.map { Point.fromLngLat(it.longitude, it.latitude) }&#10;                            _uiState.value = _uiState.value.copy(&#10;                                mapAnimationTarget = MapAnimationTarget.AnimateToFitBounds(points)&#10;                            )&#10;                            Log.d(&#10;                                TAG,&#10;                                &quot;WFA recommendations fetched: ${recommendations.size} locations&quot;&#10;                            )&#10;                        } else {&#10;                            Log.w(TAG, &quot;No WFA recommendations found for GPS location: $lat, $lng&quot;)&#10;                        }&#10;                    }.onFailure { exception -&gt;&#10;                        Log.e(TAG, &quot;Failed to fetch WFA recommendations&quot;, exception)&#10;                        // Keep empty list on error&#10;                        _uiState.value = _uiState.value.copy(wfaRecommendations = emptyList())&#10;                    }&#10;&#10;                }.onFailure { exception -&gt;&#10;                    Log.e(TAG, &quot;Failed to get GPS location for WFA recommendations&quot;, exception)&#10;                    // Fallback to cached location if GPS fails&#10;                    val lat = _uiState.value.currentUserLatitude ?: return@launch&#10;                    val lng = _uiState.value.currentUserLongitude ?: return@launch&#10;&#10;                    Log.w(TAG, &quot;GPS failed, using cached location for WFA: $lat, $lng&quot;)&#10;&#10;                    getWfaRecommendationsUseCase(lat, lng).onSuccess { recommendations -&gt;&#10;                        _uiState.value = _uiState.value.copy(wfaRecommendations = recommendations)&#10;                        if (recommendations.isNotEmpty()) {&#10;                            val points =&#10;                                recommendations.map { Point.fromLngLat(it.longitude, it.latitude) }&#10;                            _uiState.value = _uiState.value.copy(&#10;                                mapAnimationTarget = MapAnimationTarget.AnimateToFitBounds(points)&#10;                            )&#10;                            Log.d(&#10;                                TAG,&#10;                                &quot;WFA recommendations fetched with cached location: ${recommendations.size} locations&quot;&#10;                            )&#10;                        }&#10;                    }.onFailure { exception -&gt;&#10;                        Log.e(&#10;                            TAG,&#10;                            &quot;Failed to fetch WFA recommendations with cached location&quot;,&#10;                            exception&#10;                        )&#10;                        _uiState.value = _uiState.value.copy(wfaRecommendations = emptyList())&#10;                    }&#10;                }&#10;&#10;                // Reset loading state&#10;                _uiState.value = _uiState.value.copy(isLoadingWfaRecommendations = false)&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Unexpected error in fetchWfaRecommendations&quot;, e)&#10;                _uiState.value = _uiState.value.copy(&#10;                    wfaRecommendations = emptyList(),&#10;                    isLoadingWfaRecommendations = false&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Handle WFA marker click - Updated to show marker details&#10;     */&#10;    fun onWfaMarkerClicked(recommendation: WfaRecommendation) {&#10;        Log.d(TAG, &quot;WFA Marker clicked: ${recommendation.name}&quot;)&#10;        _uiState.value = _uiState.value.copy(&#10;            selectedWfaLocation = recommendation,&#10;            selectedWfaMarkerInfo = recommendation // Show marker details&#10;        )&#10;&#10;        // Focus camera on selected WFA location&#10;        viewModelScope.launch {&#10;            val point = Point.fromLngLat(recommendation.longitude, recommendation.latitude)&#10;            _uiState.value = _uiState.value.copy(&#10;                mapAnimationTarget = MapAnimationTarget.AnimateToLocation(&#10;                    point,&#10;                    16.0&#10;                )&#10;            ) // Zoom closer for selected marker&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Handle WFA marker info dismissal&#10;     */&#10;    fun onDismissWfaMarkerInfo() {&#10;        Log.d(TAG, &quot;WFA marker info dialog dismissed&quot;)&#10;        _uiState.value = _uiState.value.copy(selectedWfaMarkerInfo = null)&#10;    }&#10;&#10;    /**&#10;     * Handle marker info dialog dismissal&#10;     */&#10;    fun onDismissMarkerInfo() {&#10;        Log.d(TAG, &quot;Marker info dialog dismissed&quot;)&#10;        _uiState.value = _uiState.value.copy(&#10;            selectedMarkerInfo = null,&#10;            selectedWfaMarkerInfo = null // Also dismiss WFA marker info&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Handle booking button click&#10;     */&#10;    fun onBookingClicked() {&#10;        if (_uiState.value.isWfaModeActive) {&#10;            _uiState.value.selectedWfaLocation?.let { wfaLocation -&gt;&#10;                Log.d(TAG, &quot;Booking WFA location: ${wfaLocation.name}&quot;)&#10;                // Navigate to WFA booking screen with location data (latitude and longitude only)&#10;                val route = Screen.WfaBooking.createRoute(&#10;                    latitude = wfaLocation.latitude,&#10;                    longitude = wfaLocation.longitude&#10;                    // address is no longer sent - WfaBookingViewModel will fetch it&#10;                )&#10;                viewModelScope.launch {&#10;                    _uiState.value = _uiState.value.copy(&#10;                        navigationTarget = NavigationTarget.WfaBooking(route)&#10;                    )&#10;                }&#10;            } ?: run {&#10;                Log.w(TAG, &quot;Booking clicked in WFA mode but no location selected.&quot;)&#10;            }&#10;        } else {&#10;            Log.d(TAG, &quot;Booking clicked for mode: ${_uiState.value.selectedWorkMode}&quot;)&#10;            // TODO: Implement booking logic for WFO/WFH&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Handle attendance button click - navigates to face scanner&#10;     * FIXED: Uses new Screen.FaceScanner.createRoute with action parameter&#10;     */&#10;    fun onAttendanceButtonClicked() {&#10;        // Use the reactive StateFlow value instead of recalculating&#10;        val isEnabled = _uiState.value.isButtonEnabled&#10;        val buttonText = _uiState.value.buttonText&#10;&#10;        if (!isEnabled) {&#10;            Log.d(TAG, &quot;Attendance button clicked but not enabled (geofence or server restriction)&quot;)&#10;            return&#10;        }&#10;&#10;        val isCheckIn = buttonText.contains(&quot;Check-in&quot;, ignoreCase = true)&#10;        val action = if (isCheckIn) &quot;checkin&quot; else &quot;checkout&quot;&#10;&#10;        Log.d(TAG, &quot;Attendance button clicked - $action&quot;)&#10;&#10;        // Update isCheckInMode state before navigation&#10;        _uiState.value = _uiState.value.copy(isCheckInMode = isCheckIn)&#10;&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(&#10;                navigationTarget = NavigationTarget.FaceScanner(isCheckIn)&#10;            )&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Handle face verification result - GATEWAY after face verification&#10;     * Called from FaceScannerScreen when verification is complete&#10;     */&#10;    fun onFaceVerificationResult(isSuccess: Boolean) {&#10;        Log.d(TAG, &quot;Face verification result: $isSuccess&quot;)&#10;&#10;        if (!isSuccess) {&#10;            Log.d(TAG, &quot;Face verification failed - aborting attendance process&quot;)&#10;            _uiState.value = _uiState.value.copy(&#10;                activeDialog = DialogState.Error(&quot;Verifikasi wajah gagal. Silakan coba lagi.&quot;)&#10;            )&#10;            return&#10;        }&#10;&#10;        // Check current mode and proceed accordingly&#10;        if (_uiState.value.isCheckInMode) {&#10;            proceedWithCheckIn()&#10;        } else {&#10;            proceedWithCheckOut()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Proceed with check-in after successful face verification&#10;     * FIXED: Added proper error message extraction from server response&#10;     */&#10;    private fun proceedWithCheckIn() {&#10;        viewModelScope.launch {&#10;            try {&#10;                Log.d(TAG, &quot;Proceeding with check-in after face verification&quot;)&#10;&#10;                // Clear any previous error&#10;                _uiState.value = _uiState.value.copy(activeDialog = null)&#10;&#10;                // Determine target location based on selected work mode&#10;                val targetLocation = when (_uiState.value.selectedWorkMode) {&#10;                    &quot;Work From Home&quot;, &quot;WFH&quot; -&gt; _uiState.value.wfhLocation&#10;                    &quot;Work From Office&quot;, &quot;WFO&quot; -&gt; _uiState.value.wfoLocation&#10;                    &quot;WFA&quot;, &quot;Work From Anywhere&quot; -&gt; {&#10;                        // For WFA, convert selectedWfaLocation to Location object&#10;                        _uiState.value.selectedWfaLocation?.let { wfaLocation -&gt;&#10;                            Location(&#10;                                locationId = 0, // WFA locations don't have fixed IDs&#10;                                latitude = wfaLocation.latitude,&#10;                                longitude = wfaLocation.longitude,&#10;                                radius = 100, // Default radius for WFA&#10;                                description = wfaLocation.name,&#10;                                category = wfaLocation.category&#10;                            )&#10;                        }&#10;                    }&#10;&#10;                    else -&gt; _uiState.value.wfoLocation // Default to WFO&#10;                }&#10;&#10;                if (targetLocation == null) {&#10;                    _uiState.value = _uiState.value.copy(&#10;                        activeDialog = DialogState.Error(&quot;Target location not available for ${_uiState.value.selectedWorkMode}. Please try again.&quot;)&#10;                    )&#10;                    return@launch&#10;                }&#10;&#10;                // Get user info for the request&#10;                getLoggedInUserUseCase().collect { user -&gt;&#10;                    if (user == null) {&#10;                        _uiState.value = _uiState.value.copy(&#10;                            activeDialog = DialogState.Error(&quot;User information not available. Please try again.&quot;)&#10;                        )&#10;                        return@collect&#10;                    }&#10;&#10;                    // Map work mode to correct category_id&#10;                    val categoryId = when (_uiState.value.selectedWorkMode) {&#10;                        &quot;Work From Office&quot;, &quot;WFO&quot; -&gt; 1  // Work From Office&#10;                        &quot;Work From Home&quot;, &quot;WFH&quot; -&gt; 2    // Work From Home&#10;                        &quot;WFA&quot;, &quot;Work From Anywhere&quot; -&gt; 3 // Work From Anywhere&#10;                        else -&gt; 1 // Default to WFO&#10;                    }&#10;&#10;                    // Create attendance request model with proper parameters&#10;                    val attendanceRequest = AttendanceRequestModel(&#10;                        categoryId = categoryId, // Use correct category ID based on work mode&#10;                        latitude = 0.0, // Will be updated by UseCase with real-time GPS&#10;                        longitude = 0.0, // Will be updated by UseCase with real-time GPS&#10;                        notes = &quot;Check-in via mobile app&quot;,&#10;                        bookingId = null, // No booking for regular check-in&#10;                        type = &quot;checkin&quot;&#10;                    )&#10;&#10;                    // Call CheckInUseCase with both request and target location&#10;                    checkInUseCase(attendanceRequest, targetLocation).onSuccess { activeSession -&gt;&#10;                        Log.d(TAG, &quot;Check-in successful: $activeSession&quot;)&#10;&#10;                        // Refresh today's status to get updated data&#10;                        fetchTodayStatus()&#10;&#10;                        // Send success event to UI with appropriate message&#10;                        _uiState.value = _uiState.value.copy(&#10;                            activeDialog = DialogState.Success(&quot;Check-in berhasil! Selamat bekerja hari ini.&quot;)&#10;                        )&#10;&#10;                    }.onFailure { exception -&gt;&#10;                        Log.e(TAG, &quot;Check-in failed: ${exception.message}&quot;, exception)&#10;&#10;                        // Extract the actual error message from the exception&#10;                        val errorMessage = exception.message ?: &quot;Check-in gagal. Silakan coba lagi.&quot;&#10;                        &#10;                        // Send error event to UI with the actual server message&#10;                        _uiState.value = _uiState.value.copy(&#10;                            activeDialog = DialogState.Error(errorMessage)&#10;                        )&#10;                    }&#10;                }&#10;&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error in proceedWithCheckIn&quot;, e)&#10;                _uiState.value = _uiState.value.copy(&#10;                    activeDialog = DialogState.Error(&quot;Unexpected error during check-in: ${e.message}&quot;)&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Proceed with check-out after successful face verification&#10;     * FIXED: Added proper error message extraction from server response&#10;     */&#10;    private fun proceedWithCheckOut() {&#10;        viewModelScope.launch {&#10;            try {&#10;                Log.d(TAG, &quot;Proceeding with check-out after face verification&quot;)&#10;&#10;                // Clear any previous error&#10;                _uiState.value = _uiState.value.copy(activeDialog = null)&#10;&#10;                // Call CheckOutUseCase - it will handle everything internally&#10;                checkOutUseCase().onSuccess { activeSession -&gt;&#10;                    Log.d(TAG, &quot;Check-out successful: $activeSession&quot;)&#10;&#10;                    // Refresh today's status to get updated data&#10;                    fetchTodayStatus()&#10;&#10;                    // Send success event to UI with appropriate message&#10;                    _uiState.value = _uiState.value.copy(&#10;                        activeDialog = DialogState.Success(&quot;Check-out berhasil! Terima kasih atas kerja keras Anda hari ini.&quot;)&#10;                    )&#10;&#10;                }.onFailure { exception -&gt;&#10;                    Log.e(TAG, &quot;Check-out failed: ${exception.message}&quot;, exception)&#10;&#10;                    // Extract the actual error message from the exception&#10;                    val errorMessage = exception.message ?: &quot;Check-out gagal. Silakan coba lagi.&quot;&#10;                    &#10;                    // Send error event to UI with the actual server message&#10;                    _uiState.value = _uiState.value.copy(&#10;                        activeDialog = DialogState.Error(errorMessage)&#10;                    )&#10;                }&#10;&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error in proceedWithCheckOut&quot;, e)&#10;                _uiState.value = _uiState.value.copy(&#10;                    activeDialog = DialogState.Error(&quot;Unexpected error during check-out: ${e.message}&quot;)&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Clear error message&#10;     */&#10;    fun clearError() {&#10;        _uiState.value = _uiState.value.copy(activeDialog = null)&#10;    }&#10;&#10;    /**&#10;     * Handle map marker click&#10;     */&#10;    fun onMarkerClicked(location: Location) {&#10;        Log.d(TAG, &quot;Marker clicked for location: ${location.description}&quot;)&#10;        _uiState.value = _uiState.value.copy(selectedMarkerInfo = location)&#10;    }&#10;&#10;    /**&#10;     * Handle focus location button click&#10;     * This should ONLY focus on current user location, not work mode locations&#10;     * Always gets fresh location data when clicked&#10;     */&#10;    fun onFocusLocationClicked() {&#10;        Log.d(TAG, &quot;=== FOCUS LOCATION BUTTON CLICKED ===&quot;)&#10;        Log.d(TAG, &quot;Current work mode: ${_uiState.value.selectedWorkMode}&quot;)&#10;        Log.d(TAG, &quot;Current WFH location: ${_uiState.value.wfhLocation}&quot;)&#10;        Log.d(TAG, &quot;Getting fresh GPS coordinates...&quot;)&#10;&#10;        viewModelScope.launch {&#10;            try {&#10;                // PENTING: Gunakan GPS real-time, bukan dari database&#10;                getCurrentCoordinatesUseCase(useRealTimeGPS = true).onSuccess { coordinates -&gt;&#10;                    val (latitude, longitude) = coordinates&#10;&#10;                    Log.d(TAG, &quot;=== FRESH GPS COORDINATES RECEIVED ===&quot;)&#10;                    Log.d(TAG, &quot;GPS Real-time Latitude: $latitude&quot;)&#10;                    Log.d(TAG, &quot;GPS Real-time Longitude: $longitude&quot;)&#10;                    Log.d(TAG, &quot;WFH Latitude: ${_uiState.value.wfhLocation?.latitude}&quot;)&#10;                    Log.d(TAG, &quot;WFH Longitude: ${_uiState.value.wfhLocation?.longitude}&quot;)&#10;&#10;                    // Pastikan koordinat berbeda dari WFH&#10;                    if (latitude == _uiState.value.wfhLocation?.latitude &amp;&amp;&#10;                        longitude == _uiState.value.wfhLocation?.longitude&#10;                    ) {&#10;                        Log.w(TAG, &quot;WARNING: GPS coordinates sama dengan WFH location!&quot;)&#10;                        Log.w(TAG, &quot;Ini mungkin karena GPS masih menggunakan cached location&quot;)&#10;                    }&#10;&#10;                    // Update state untuk immediate display&#10;                    _uiState.value = _uiState.value.copy(&#10;                        currentUserLatitude = latitude,&#10;                        currentUserLongitude = longitude&#10;                    )&#10;&#10;                    // Send map animation event&#10;                    val focusPoint = Point.fromLngLat(longitude, latitude)&#10;                    _uiState.value = _uiState.value.copy(&#10;                        mapAnimationTarget = MapAnimationTarget.AnimateToLocation(&#10;                            point = focusPoint,&#10;                            zoomLevel = 15.0&#10;                        )&#10;                    )&#10;&#10;                    Log.d(TAG, &quot;=== MAP ANIMATION SENT ===&quot;)&#10;                    Log.d(TAG, &quot;Focus point: ${focusPoint.latitude()}, ${focusPoint.longitude()}&quot;)&#10;                    Log.d(TAG, &quot;This should be your CURRENT GPS location, NOT your home location!&quot;)&#10;                }.onFailure { exception -&gt;&#10;                    Log.e(TAG, &quot;=== GPS LOCATION FAILED ===&quot;)&#10;                    Log.e(TAG, &quot;Failed to get current GPS location: ${exception.message}&quot;)&#10;                    _uiState.value = _uiState.value.copy(&#10;                        mapAnimationTarget = MapAnimationTarget.ShowLocationError&#10;                    )&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;=== UNEXPECTED ERROR ===&quot;)&#10;                Log.e(TAG, &quot;Error in onFocusLocationClicked: ${e.message}&quot;)&#10;                _uiState.value = _uiState.value.copy(&#10;                    mapAnimationTarget = MapAnimationTarget.ShowLocationError&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Called when the map is ready to receive commands&#10;     * This will trigger initial camera focus to WFO location&#10;     */&#10;    fun onMapReady() {&#10;        Log.d(TAG, &quot;Map is ready, focusing to WFO location&quot;)&#10;        viewModelScope.launch {&#10;            _uiState.value.wfoLocation?.let { wfoLocation -&gt;&#10;                val wfoPoint = Point.fromLngLat(wfoLocation.longitude, wfoLocation.latitude)&#10;                _uiState.value = _uiState.value.copy(&#10;                    mapAnimationTarget = MapAnimationTarget.AnimateToLocation(&#10;                        point = wfoPoint,&#10;                        zoomLevel = 15.0&#10;                    )&#10;                )&#10;                Log.d(TAG, &quot;Initial camera focus sent to WFO location&quot;)&#10;            } ?: run {&#10;                Log.w(TAG, &quot;WFO location not available for initial focus&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Start location updates for display purposes&#10;     * This should be called by UI when location permissions are granted&#10;     */&#10;    fun startLocationUpdates() {&#10;        Log.d(TAG, &quot;Starting location updates for display&quot;)&#10;        startDisplayLocationUpdates()&#10;    }&#10;&#10;    /**&#10;     * Handle selected location from LocationSearchScreen&#10;     */&#10;    fun onLocationSelected(location: LocationResult) {&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(&#10;                selectedWfaLocation = WfaRecommendation(&#10;                    name = location.placeName,&#10;                    address = location.address,&#10;                    latitude = location.latitude,&#10;                    longitude = location.longitude,&#10;                    score = 0.0, // Default score for manually selected location&#10;                    label = &quot;Manual Selection&quot;, // Default label for manually selected location&#10;                    category = &quot;Custom&quot;, // Default category for manually selected location&#10;                    distance = 0.0 // Distance will be calculated based on current location&#10;                ),&#10;                isWfaModeActive = true&#10;            )&#10;&#10;            // Animate map to the selected location&#10;            _uiState.value = _uiState.value.copy(&#10;                mapAnimationTarget = MapAnimationTarget.AnimateToLocation(&#10;                    Point.fromLngLat(location.longitude, location.latitude),&#10;                    15.0&#10;                )&#10;            )&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Enter Pick on Map mode - enables crosshair and map interaction&#10;     */&#10;    fun onEnterPickOnMapMode() {&#10;        Log.d(TAG, &quot;Entering Pick on Map mode&quot;)&#10;        _uiState.value = _uiState.value.copy(&#10;            isPickOnMapModeActive = true,&#10;            pickedLocation = null // Reset any previously picked location&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Exit Pick on Map mode - disables crosshair and map interaction&#10;     */&#10;    fun onExitPickOnMapMode() {&#10;        Log.d(TAG, &quot;Exiting Pick on Map mode&quot;)&#10;        _uiState.value = _uiState.value.copy(&#10;            isPickOnMapModeActive = false,&#10;            pickedLocation = null&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Handle map idle event - called when user stops moving the map&#10;     * Performs reverse geocoding for the center point of the map&#10;     */&#10;    fun onMapIdle(centerPoint: Point) {&#10;        // Only perform reverse geocoding if Pick on Map mode is active&#10;        if (!_uiState.value.isPickOnMapModeActive) return&#10;&#10;        viewModelScope.launch {&#10;            try {&#10;                Log.d(&#10;                    TAG,&#10;                    &quot;Map idle detected in Pick on Map mode: ${centerPoint.latitude()}, ${centerPoint.longitude()}&quot;&#10;                )&#10;&#10;                // Perform reverse geocoding for the center point&#10;                reverseGeocodeUseCase(&#10;                    latitude = centerPoint.latitude(),&#10;                    longitude = centerPoint.longitude()&#10;                ).onSuccess { locationResult -&gt;&#10;                    Log.d(TAG, &quot;Reverse geocoding successful: ${locationResult.placeName}&quot;)&#10;&#10;                    // Update the picked location&#10;                    _uiState.value = _uiState.value.copy(&#10;                        pickedLocation = locationResult,&#10;                        selectedWfaLocation = WfaRecommendation(&#10;                            name = locationResult.placeName,&#10;                            address = locationResult.address,&#10;                            latitude = locationResult.latitude,&#10;                            longitude = locationResult.longitude,&#10;                            score = 0.0,&#10;                            label = &quot;Picked on Map&quot;,&#10;                            category = &quot;Manual Selection&quot;,&#10;                            distance = 0.0&#10;                        )&#10;                    )&#10;                }.onFailure { exception -&gt;&#10;                    Log.e(TAG, &quot;Reverse geocoding failed&quot;, exception)&#10;&#10;                    // Don't create fallback location, instead show error and keep picked location null&#10;                    _uiState.value = _uiState.value.copy(&#10;                        pickedLocation = null, // Ensure picked location is null&#10;                        selectedWfaLocation = null, // Clear any selected WFA location&#10;                        // Show error message in BottomSheet&#10;                        error = &quot;Gagal mendapatkan detail lokasi. Periksa koneksi Anda.&quot;&#10;                    )&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Unexpected error in onMapIdle&quot;, e)&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        displayLocationJob?.cancel()&#10;&#10;        // Clean up geofence when ViewModel is cleared&#10;        _uiState.value.targetLocation?.let { location -&gt;&#10;            geofenceManager.removeGeofence(location.locationId.toString())&#10;        }&#10;&#10;        Log.d(TAG, &quot;ViewModel cleared, display location tracking stopped&quot;)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/presentation/screen/attendance/face/FaceScannerScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/presentation/screen/attendance/face/FaceScannerScreen.kt" />
              <option name="originalContent" value="package com.example.infinite_track.presentation.screen.attendance.face&#10;&#10;import android.graphics.Bitmap&#10;import androidx.camera.core.CameraSelector&#10;import androidx.camera.core.ImageProxy&#10;import androidx.camera.lifecycle.ProcessCameraProvider&#10;import androidx.camera.view.PreviewView&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Close&#10;import androidx.compose.material.icons.filled.SentimentSatisfied&#10;import androidx.compose.material.icons.filled.Visibility&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.CircularProgressIndicator&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.LinearProgressIndicator&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.OutlinedButton&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.DisposableEffect&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.onSizeChanged&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.viewinterop.AndroidView&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import androidx.navigation.NavController&#10;import com.example.infinite_track.presentation.components.button.ButtonStateType&#10;import com.example.infinite_track.presentation.components.button.ButtonStyle&#10;import com.example.infinite_track.presentation.components.button.StatefulButton&#10;import com.example.infinite_track.presentation.components.cameras.FaceBoundingBox&#10;import com.example.infinite_track.presentation.components.loading.LoadingAnimation&#10;import com.example.infinite_track.presentation.theme.Blue_500&#10;import com.google.accompanist.permissions.ExperimentalPermissionsApi&#10;import com.google.accompanist.permissions.isGranted&#10;import com.google.accompanist.permissions.rememberPermissionState&#10;import com.google.accompanist.permissions.shouldShowRationale&#10;import java.util.concurrent.ExecutorService&#10;import java.util.concurrent.Executors&#10;import androidx.camera.core.Preview as CameraPreview&#10;&#10;@OptIn(ExperimentalMaterial3Api::class, ExperimentalPermissionsApi::class)&#10;@Composable&#10;fun FaceScannerScreen(&#10;    action: String,&#10;    navController: NavController,&#10;    modifier: Modifier = Modifier,&#10;    viewModel: FaceScannerViewModel = hiltViewModel()&#10;) {&#10;    val uiState by viewModel.uiState.collectAsStateWithLifecycle()&#10;&#10;    // Camera permission state&#10;    val cameraPermissionState = rememberPermissionState(&#10;        android.Manifest.permission.CAMERA&#10;    )&#10;&#10;    // Camera executor&#10;    val cameraExecutor = remember { Executors.newSingleThreadExecutor() }&#10;&#10;    // KUNCI PERBAIKAN: Reset scanner setiap kali screen muncul&#10;    // Ini akan memastikan ViewModel selalu dalam state fresh&#10;    LaunchedEffect(Unit) {&#10;        println(&quot;FaceScannerScreen: Screen appeared, initializing scanner...&quot;)&#10;        // SELALU reset scanner terlebih dahulu untuk memastikan state bersih&#10;        viewModel.initializeScanner()&#10;&#10;        // Then request camera permission if not granted&#10;        if (!cameraPermissionState.status.isGranted) {&#10;            cameraPermissionState.launchPermissionRequest()&#10;        }&#10;    }&#10;&#10;    // Handle navigation based on verification result&#10;    LaunchedEffect(uiState.livenessState) {&#10;        when (uiState.livenessState) {&#10;            LivenessState.SUCCESS -&gt; {&#10;                // FIXED: Send success result and navigate back to proceed with attendance&#10;                println(&quot;FaceScannerScreen: SUCCESS detected, navigating back with success result&quot;)&#10;                navController.previousBackStackEntry?.savedStateHandle?.set(&#10;                    &quot;face_verification_result&quot;,&#10;                    true&#10;                )&#10;                navController.popBackStack()&#10;            }&#10;&#10;            LivenessState.TIMEOUT -&gt; {&#10;                // TIMEOUT means user ran out of time - send failure and go back&#10;                println(&quot;FaceScannerScreen: TIMEOUT detected, navigating back with failure result&quot;)&#10;                navController.previousBackStackEntry?.savedStateHandle?.set(&#10;                    &quot;face_verification_result&quot;,&#10;                    false&#10;                )&#10;                navController.popBackStack()&#10;            }&#10;&#10;            // FAILURE stays on screen to allow retry - no automatic navigation&#10;            LivenessState.FAILURE -&gt; {&#10;                // Stay on screen, show retry button - user can try again&#10;                println(&quot;FaceScannerScreen: FAILURE detected - staying on screen for retry&quot;)&#10;            }&#10;&#10;            else -&gt; {&#10;                // Continue with current state - don't navigate anywhere&#10;            }&#10;        }&#10;    }&#10;&#10;    // Cleanup camera executor when composable is disposed&#10;    DisposableEffect(Unit) {&#10;        onDispose {&#10;            cameraExecutor.shutdown()&#10;        }&#10;    }&#10;&#10;    Box(modifier = modifier.fillMaxSize()) {&#10;        when {&#10;            cameraPermissionState.status.isGranted -&gt; {&#10;                // Camera permission granted - show camera interface&#10;                CameraContent(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    action = action,&#10;                    uiState = uiState,&#10;                    cameraExecutor = cameraExecutor,&#10;                    onImageAnalysis = { imageProxy, bitmap -&gt;&#10;                        viewModel.processImageProxy(imageProxy, bitmap)&#10;                    },&#10;                    onRetryClick = {&#10;                        viewModel.resetScanner()&#10;                    },&#10;                    onCloseClick = {&#10;                        navController.popBackStack()&#10;                    }&#10;                )&#10;            }&#10;&#10;            cameraPermissionState.status.shouldShowRationale -&gt; {&#10;                // Show rationale for camera permission&#10;                CameraPermissionRationale(&#10;                    onRequestPermission = {&#10;                        cameraPermissionState.launchPermissionRequest()&#10;                    },&#10;                    onCloseClick = {&#10;                        navController.popBackStack()&#10;                    }&#10;                )&#10;            }&#10;&#10;            else -&gt; {&#10;                // Permission denied - show permission request UI&#10;                CameraPermissionDenied(&#10;                    onRequestPermission = {&#10;                        cameraPermissionState.launchPermissionRequest()&#10;                    },&#10;                    onCloseClick = {&#10;                        navController.popBackStack()&#10;                    }&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun CameraContent(&#10;    modifier: Modifier = Modifier,&#10;    action: String,&#10;    uiState: FaceScannerState,&#10;    cameraExecutor: ExecutorService,&#10;    onImageAnalysis: (ImageProxy, Bitmap) -&gt; Unit,&#10;    onRetryClick: () -&gt; Unit,&#10;    onCloseClick: () -&gt; Unit&#10;) {&#10;    val density = LocalDensity.current&#10;    var previewSize by remember { mutableStateOf&lt;androidx.compose.ui.geometry.Size?&gt;(null) }&#10;&#10;    // Get screen dimensions for proper scaling&#10;    val configuration = androidx.compose.ui.platform.LocalConfiguration.current&#10;    val screenWidth = configuration.screenWidthDp.dp&#10;    val screenHeight = configuration.screenHeightDp.dp&#10;&#10;    Box(&#10;        modifier = modifier&#10;            .fillMaxSize()&#10;            .onSizeChanged { size -&gt;&#10;                // Capture actual preview size for coordinate scaling&#10;                previewSize = androidx.compose.ui.geometry.Size(&#10;                    width = size.width.toFloat(),&#10;                    height = size.height.toFloat()&#10;                )&#10;                println(&quot;Preview size captured: ${size.width}x${size.height}&quot;)&#10;            }&#10;    ) {&#10;        // Layer 1: Camera Preview with proper CameraX integration&#10;        CameraPreview(&#10;            modifier = Modifier.fillMaxSize(),&#10;            cameraExecutor = cameraExecutor,&#10;            onImageAnalysis = { imageProxy, bitmap -&gt;&#10;                onImageAnalysis(imageProxy, bitmap)&#10;            }&#10;        )&#10;&#10;        // Layer 2: Face Bounding Box Overlay with proper coordinate scaling&#10;        FaceBoundingBox(&#10;            modifier = Modifier.fillMaxSize(),&#10;            boundingBox = uiState.boundingBox,&#10;            livenessState = uiState.livenessState,&#10;            previewSize = previewSize, // Pass actual preview size&#10;            imageSize = uiState.imageSize // Pass image size from ViewModel&#10;        )&#10;&#10;        // Layer 3: Top Info Section - More compact&#10;        TopInfoSection(&#10;            modifier = Modifier&#10;                .align(Alignment.TopCenter)&#10;                .padding(top = 16.dp, start = 16.dp, end = 16.dp),&#10;            action = action&#10;        )&#10;&#10;        // Layer 4: Instruction Section with dynamic content&#10;        InstructionSection(&#10;            modifier = Modifier&#10;                .align(Alignment.BottomCenter)&#10;                .padding(bottom = 16.dp, start = 16.dp, end = 16.dp),&#10;            uiState = uiState,&#10;            onRetryClick = onRetryClick,&#10;            onCloseClick = onCloseClick&#10;        )&#10;&#10;        // Layer 5: Loading Overlay for processing state&#10;        if (uiState.isProcessing) {&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .background(Color.Black.copy(alpha = 0.3f)),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Card(&#10;                    modifier = Modifier.padding(32.dp),&#10;                    colors = CardDefaults.cardColors(&#10;                        containerColor = MaterialTheme.colorScheme.surface&#10;                    )&#10;                ) {&#10;                    Column(&#10;                        modifier = Modifier.padding(24.dp),&#10;                        horizontalAlignment = Alignment.CenterHorizontally,&#10;                        verticalArrangement = Arrangement.spacedBy(16.dp)&#10;                    ) {&#10;                        LoadingAnimation()&#10;                        Text(&#10;                            text = uiState.instructionText,&#10;                            style = MaterialTheme.typography.bodyMedium,&#10;                            textAlign = TextAlign.Center&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun CameraPreview(&#10;    modifier: Modifier = Modifier,&#10;    cameraExecutor: ExecutorService,&#10;    onImageAnalysis: (ImageProxy, Bitmap) -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val lifecycleOwner = androidx.lifecycle.compose.LocalLifecycleOwner.current&#10;    val previewView = remember {&#10;        PreviewView(context).apply {&#10;            scaleType = PreviewView.ScaleType.FILL_CENTER&#10;        }&#10;    }&#10;&#10;    // PERBAIKAN: Tambahkan key untuk memaksa recomposition camera saat reset&#10;    var cameraKey by remember { mutableStateOf(0) }&#10;&#10;    // PERBAIKAN: Use LaunchedEffect dengan key yang berubah untuk force camera rebind&#10;    LaunchedEffect(cameraKey) {&#10;        println(&quot;=== CAMERA BINDING START (Key: $cameraKey) ===&quot;)&#10;        val cameraProviderFuture = ProcessCameraProvider.getInstance(context)&#10;&#10;        try {&#10;            val cameraProvider = cameraProviderFuture.get()&#10;&#10;            // IMPORTANT: Unbind all use cases before rebinding&#10;            cameraProvider.unbindAll()&#10;            println(&quot;All camera use cases unbound&quot;)&#10;&#10;            // Preview use case&#10;            val preview = CameraPreview.Builder()&#10;                .build()&#10;                .also {&#10;                    it.surfaceProvider = previewView.surfaceProvider&#10;                }&#10;&#10;            // Image analysis use case dengan FRESH analyzer&#10;            val imageAnalysis = androidx.camera.core.ImageAnalysis.Builder()&#10;                .setBackpressureStrategy(androidx.camera.core.ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST)&#10;                .build()&#10;                .also { analysis -&gt;&#10;                    analysis.setAnalyzer(cameraExecutor) { imageProxy -&gt;&#10;                        try {&#10;                            val bitmap = imageProxyToBitmap(imageProxy)&#10;                            if (bitmap != null) {&#10;                                // PERBAIKAN: Tambahkan logging untuk setiap frame&#10;                                println(&quot;CAMERA FRAME: Sending to ViewModel for analysis&quot;)&#10;                                onImageAnalysis(imageProxy, bitmap)&#10;                            } else {&#10;                                println(&quot;CAMERA FRAME: Failed to convert to bitmap&quot;)&#10;                                imageProxy.close()&#10;                            }&#10;                        } catch (e: Exception) {&#10;                            println(&quot;CAMERA FRAME: Error in image analysis: ${e.message}&quot;)&#10;                            imageProxy.close()&#10;                        }&#10;                    }&#10;                }&#10;&#10;            // Select front camera&#10;            val cameraSelector = CameraSelector.DEFAULT_FRONT_CAMERA&#10;&#10;            // Bind use cases to camera&#10;            cameraProvider.bindToLifecycle(&#10;                lifecycleOwner,&#10;                cameraSelector,&#10;                preview,&#10;                imageAnalysis&#10;            )&#10;&#10;            println(&quot;=== CAMERA BINDING SUCCESS ===&quot;)&#10;&#10;        } catch (exc: Exception) {&#10;            println(&quot;=== CAMERA BINDING FAILED: ${exc.message} ===&quot;)&#10;            exc.printStackTrace()&#10;        }&#10;    }&#10;&#10;    // PERBAIKAN: Expose function untuk force camera rebind&#10;    DisposableEffect(Unit) {&#10;        onDispose {&#10;            println(&quot;=== CAMERA PREVIEW DISPOSED ===&quot;)&#10;        }&#10;    }&#10;&#10;    // Simple AndroidView without update block&#10;    AndroidView(&#10;        factory = { previewView },&#10;        modifier = modifier&#10;    )&#10;}&#10;&#10;@Composable&#10;private fun TopInfoSection(&#10;    modifier: Modifier = Modifier,&#10;    action: String&#10;) {&#10;    Column(&#10;        modifier = modifier.fillMaxWidth(),&#10;        horizontalAlignment = Alignment.CenterHorizontally,&#10;        verticalArrangement = Arrangement.Center&#10;    ) {&#10;        Text(&#10;            text = &quot;Verifikasi Wajah&quot;,&#10;            style = MaterialTheme.typography.titleMedium,&#10;            color = Color.White,&#10;            fontWeight = FontWeight.Bold,&#10;            textAlign = TextAlign.Center,&#10;            modifier = Modifier.fillMaxWidth()&#10;        )&#10;        Spacer(modifier = Modifier.height(2.dp))&#10;        Text(&#10;            text = if (action == &quot;checkin&quot;) &quot;Check In&quot; else &quot;Check Out&quot;,&#10;            style = MaterialTheme.typography.bodyMedium,&#10;            color = Color.White.copy(alpha = 0.9f),&#10;            fontWeight = FontWeight.Medium,&#10;            textAlign = TextAlign.Center,&#10;            modifier = Modifier.fillMaxWidth()&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun InstructionSection(&#10;    modifier: Modifier = Modifier,&#10;    uiState: FaceScannerState,&#10;    onRetryClick: () -&gt; Unit,&#10;    onCloseClick: () -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = modifier.fillMaxWidth(),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.surface.copy(alpha = 0.50f)&#10;        ),&#10;        shape = RoundedCornerShape(16.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(12.dp),&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.spacedBy(8.dp)&#10;        ) {&#10;            // Status Icon&#10;            val icon = when (uiState.livenessState) {&#10;                LivenessState.WAITING_FOR_LIVENESS -&gt; {&#10;                    if (uiState.currentChallenge == LivenessChallenge.BLINK) {&#10;                        Icons.Default.Visibility&#10;                    } else {&#10;                        Icons.Default.SentimentSatisfied&#10;                    }&#10;                }&#10;&#10;                LivenessState.SUCCESS -&gt; Icons.Default.SentimentSatisfied&#10;                else -&gt; Icons.Default.Visibility&#10;            }&#10;&#10;            val iconColor = when (uiState.livenessState) {&#10;                LivenessState.SUCCESS -&gt; Color(0xFF00FFC2)&#10;                LivenessState.FAILURE, LivenessState.TIMEOUT -&gt; Color(0xFFFF3B30)&#10;                LivenessState.WAITING_FOR_LIVENESS -&gt; Color(0xFFFFD60A)&#10;                else -&gt; Color(0xFF00A3FF)&#10;            }&#10;&#10;            Icon(&#10;                imageVector = icon,&#10;                contentDescription = null,&#10;                modifier = Modifier.size(36.dp),&#10;                tint = iconColor&#10;            )&#10;&#10;            // Instruction Text&#10;            Text(&#10;                text = uiState.instructionText,&#10;                style = MaterialTheme.typography.bodyMedium,&#10;                textAlign = TextAlign.Center,&#10;                fontWeight = FontWeight.Medium&#10;            )&#10;&#10;            // Progress Indicator (for countdown)&#10;            if (uiState.showCountdown &amp;&amp; uiState.livenessState != LivenessState.SUCCESS) {&#10;                Row(&#10;                    verticalAlignment = Alignment.CenterVertically,&#10;                    horizontalArrangement = Arrangement.spacedBy(6.dp)&#10;                ) {&#10;                    LinearProgressIndicator(&#10;                        progress = uiState.progress,&#10;                        color = Blue_500,&#10;                        modifier = Modifier&#10;                            .weight(1f)&#10;                            .height(3.dp)&#10;                            .clip(RoundedCornerShape(2.dp))&#10;                    )&#10;                    Text(&#10;                        text = &quot;${uiState.timeRemaining}s&quot;,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f)&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Error Message&#10;            uiState.errorMessage?.let { errorMessage -&gt;&#10;                Text(&#10;                    text = errorMessage,&#10;                    style = MaterialTheme.typography.bodySmall,&#10;                    color = Color(0xFFFF3B30),&#10;                    textAlign = TextAlign.Center&#10;                )&#10;            }&#10;&#10;            // Action Buttons&#10;            Row(&#10;                horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;            ) {&#10;                // Close Button menggunakan StatefulButton dengan state Error&#10;                StatefulButton(&#10;                    text = &quot;Tutup&quot;,&#10;                    onClick = onCloseClick,&#10;                    modifier = Modifier.weight(1f),&#10;                    style = ButtonStyle.Outlined,&#10;                    stateType = ButtonStateType.Error,&#10;                    enabled = true&#10;                )&#10;&#10;                // Retry Button (show when failed or timeout) menggunakan StatefulButton&#10;                if (uiState.livenessState == LivenessState.FAILURE ||&#10;                    uiState.livenessState == LivenessState.TIMEOUT&#10;                ) {&#10;                    StatefulButton(&#10;                        text = &quot;Coba Lagi&quot;,&#10;                        onClick = onRetryClick,&#10;                        modifier = Modifier.weight(1f),&#10;                        style = ButtonStyle.Elevated,&#10;                        stateType = ButtonStateType.Info,&#10;                        enabled = true&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;// Helper function to convert ImageProxy to Bitmap - FIXED VERSION&#10;private fun imageProxyToBitmap(imageProxy: ImageProxy): Bitmap? {&#10;    return try {&#10;        // DON'T close imageProxy here - let FaceDetectorHelper handle it&#10;        // Get the YUV_420_888 image from camera&#10;        val image = imageProxy.image&#10;        if (image != null) {&#10;            val planes = image.planes&#10;            val yBuffer = planes[0].buffer&#10;            val uBuffer = planes[1].buffer&#10;            val vBuffer = planes[2].buffer&#10;&#10;            val ySize = yBuffer.remaining()&#10;            val uSize = uBuffer.remaining()&#10;            val vSize = vBuffer.remaining()&#10;&#10;            val nv21 = ByteArray(ySize + uSize + vSize)&#10;&#10;            // U and V are swapped&#10;            yBuffer.get(nv21, 0, ySize)&#10;            vBuffer.get(nv21, ySize, vSize)&#10;            uBuffer.get(nv21, ySize + vSize, uSize)&#10;&#10;            val yuvImage = android.graphics.YuvImage(&#10;                nv21,&#10;                android.graphics.ImageFormat.NV21,&#10;                image.width,&#10;                image.height,&#10;                null&#10;            )&#10;&#10;            val out = java.io.ByteArrayOutputStream()&#10;            yuvImage.compressToJpeg(&#10;                android.graphics.Rect(0, 0, image.width, image.height),&#10;                75,&#10;                out&#10;            )&#10;&#10;            val imageBytes = out.toByteArray()&#10;            val bitmap =&#10;                android.graphics.BitmapFactory.decodeByteArray(imageBytes, 0, imageBytes.size)&#10;&#10;            // Close the output stream&#10;            out.close()&#10;&#10;            println(&quot;Successfully converted ImageProxy to Bitmap: ${bitmap?.width}x${bitmap?.height}&quot;)&#10;            bitmap&#10;        } else {&#10;            println(&quot;ImageProxy.image is null&quot;)&#10;            null&#10;        }&#10;    } catch (e: Exception) {&#10;        println(&quot;Error converting ImageProxy to Bitmap: ${e.message}&quot;)&#10;        e.printStackTrace()&#10;        null&#10;    }&#10;    // DON'T close imageProxy here - FaceDetectorHelper will close it&#10;}&#10;&#10;// Permission UI Components&#10;@Composable&#10;private fun CameraPermissionRationale(&#10;    onRequestPermission: () -&gt; Unit,&#10;    onCloseClick: () -&gt; Unit&#10;) {&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(MaterialTheme.colorScheme.background),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(32.dp),&#10;            colors = CardDefaults.cardColors(&#10;                containerColor = MaterialTheme.colorScheme.surface&#10;            ),&#10;            shape = RoundedCornerShape(16.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(24.dp),&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#10;                verticalArrangement = Arrangement.spacedBy(16.dp)&#10;            ) {&#10;                Icon(&#10;                    imageVector = Icons.Default.Visibility,&#10;                    contentDescription = null,&#10;                    modifier = Modifier.size(64.dp),&#10;                    tint = MaterialTheme.colorScheme.primary&#10;                )&#10;&#10;                Text(&#10;                    text = &quot;Izin Kamera Diperlukan&quot;,&#10;                    style = MaterialTheme.typography.headlineSmall,&#10;                    fontWeight = FontWeight.Bold,&#10;                    textAlign = TextAlign.Center&#10;                )&#10;&#10;                Text(&#10;                    text = &quot;Aplikasi memerlukan akses kamera untuk melakukan verifikasi wajah. Fitur ini membantu memastikan keamanan absensi Anda.&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    textAlign = TextAlign.Center,&#10;                    color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.8f)&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                Row(&#10;                    horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;                    modifier = Modifier.fillMaxWidth()&#10;                ) {&#10;                    OutlinedButton(&#10;                        onClick = onCloseClick,&#10;                        modifier = Modifier.weight(1f)&#10;                    ) {&#10;                        Text(&quot;Batal&quot;)&#10;                    }&#10;&#10;                    Button(&#10;                        onClick = onRequestPermission,&#10;                        modifier = Modifier.weight(1f)&#10;                    ) {&#10;                        Text(&quot;Berikan Izin&quot;)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun CameraPermissionDenied(&#10;    onRequestPermission: () -&gt; Unit,&#10;    onCloseClick: () -&gt; Unit&#10;) {&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(MaterialTheme.colorScheme.background),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(32.dp),&#10;            colors = CardDefaults.cardColors(&#10;                containerColor = MaterialTheme.colorScheme.surface&#10;            ),&#10;            shape = RoundedCornerShape(16.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(24.dp),&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#10;                verticalArrangement = Arrangement.spacedBy(16.dp)&#10;            ) {&#10;                Icon(&#10;                    imageVector = Icons.Default.Close,&#10;                    contentDescription = null,&#10;                    modifier = Modifier.size(64.dp),&#10;                    tint = Color(0xFFFF3B30)&#10;                )&#10;&#10;                Text(&#10;                    text = &quot;Akses Kamera Dibutuhkan&quot;,&#10;                    style = MaterialTheme.typography.headlineSmall,&#10;                    fontWeight = FontWeight.Bold,&#10;                    textAlign = TextAlign.Center&#10;                )&#10;&#10;                Text(&#10;                    text = &quot;Tanpa akses kamera, fitur verifikasi wajah tidak dapat berfungsi. Silakan berikan izin kamera untuk melanjutkan proses absensi.&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    textAlign = TextAlign.Center,&#10;                    color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.8f)&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                Row(&#10;                    horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;                    modifier = Modifier.fillMaxWidth()&#10;                ) {&#10;                    OutlinedButton(&#10;                        onClick = onCloseClick,&#10;                        modifier = Modifier.weight(1f)&#10;                    ) {&#10;                        Text(&quot;Tutup&quot;)&#10;                    }&#10;&#10;                    Button(&#10;                        onClick = onRequestPermission,&#10;                        modifier = Modifier.weight(1f)&#10;                    ) {&#10;                        Text(&quot;Coba Lagi&quot;)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;// Preview Composables for different states&#10;@Preview(showBackground = true, name = &quot;Check In - Initial State&quot;)&#10;@Composable&#10;fun PreviewFaceScannerCheckIn() {&#10;    MaterialTheme {&#10;        FaceScannerScreenPreview(&#10;            action = &quot;checkin&quot;,&#10;            state = FaceScannerState(&#10;                livenessState = LivenessState.IDLE,&#10;                instructionText = &quot;Posisikan wajah Anda dalam frame&quot;,&#10;                isProcessing = false,&#10;                showCountdown = false&#10;            )&#10;        )&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true, name = &quot;Check Out - Waiting for Liveness&quot;)&#10;@Composable&#10;fun PreviewFaceScannerCheckOutWaiting() {&#10;    MaterialTheme {&#10;        FaceScannerScreenPreview(&#10;            action = &quot;checkout&quot;,&#10;            state = FaceScannerState(&#10;                livenessState = LivenessState.WAITING_FOR_LIVENESS,&#10;                currentChallenge = LivenessChallenge.BLINK,&#10;                instructionText = &quot;Silakan berkedip untuk verifikasi&quot;,&#10;                isProcessing = false,&#10;                showCountdown = true,&#10;                progress = 0.6f,&#10;                timeRemaining = 4&#10;            )&#10;        )&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true, name = &quot;Processing State&quot;)&#10;@Composable&#10;fun PreviewFaceScannerProcessing() {&#10;    MaterialTheme {&#10;        FaceScannerScreenPreview(&#10;            action = &quot;checkin&quot;,&#10;            state = FaceScannerState(&#10;                livenessState = LivenessState.VERIFYING_FACE,&#10;                instructionText = &quot;Memproses verifikasi wajah...&quot;,&#10;                isProcessing = true,&#10;                showCountdown = false&#10;            )&#10;        )&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true, name = &quot;Success State&quot;)&#10;@Composable&#10;fun PreviewFaceScannerSuccess() {&#10;    MaterialTheme {&#10;        FaceScannerScreenPreview(&#10;            action = &quot;checkin&quot;,&#10;            state = FaceScannerState(&#10;                livenessState = LivenessState.SUCCESS,&#10;                instructionText = &quot;Verifikasi berhasil!&quot;,&#10;                isProcessing = false,&#10;                showCountdown = false&#10;            )&#10;        )&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true, name = &quot;Failure State&quot;)&#10;@Composable&#10;fun PreviewFaceScannerFailure() {&#10;    MaterialTheme {&#10;        FaceScannerScreenPreview(&#10;            action = &quot;checkout&quot;,&#10;            state = FaceScannerState(&#10;                livenessState = LivenessState.FAILURE,&#10;                instructionText = &quot;Verifikasi gagal&quot;,&#10;                errorMessage = &quot;Wajah tidak terdeteksi dengan jelas. Silakan coba lagi.&quot;,&#10;                isProcessing = false,&#10;                showCountdown = false&#10;            )&#10;        )&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true, name = &quot;Timeout State&quot;)&#10;@Composable&#10;fun PreviewFaceScannerTimeout() {&#10;    MaterialTheme {&#10;        FaceScannerScreenPreview(&#10;            action = &quot;checkin&quot;,&#10;            state = FaceScannerState(&#10;                livenessState = LivenessState.TIMEOUT,&#10;                instructionText = &quot;Waktu habis&quot;,&#10;                errorMessage = &quot;Waktu verifikasi telah habis. Silakan coba lagi.&quot;,&#10;                isProcessing = false,&#10;                showCountdown = false&#10;            )&#10;        )&#10;    }&#10;}&#10;&#10;// Simplified preview composable without camera and ViewModel dependencies&#10;@Composable&#10;private fun FaceScannerScreenPreview(&#10;    action: String,&#10;    state: FaceScannerState&#10;) {&#10;    Box(modifier = Modifier.fillMaxSize()) {&#10;        // Mock camera background&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .background(Color.Black)&#10;        )&#10;&#10;        // Top Info Section&#10;        TopInfoSection(&#10;            modifier = Modifier&#10;                .align(Alignment.TopCenter)&#10;                .padding(top = 48.dp, start = 24.dp, end = 24.dp),&#10;            action = action&#10;        )&#10;&#10;        // Instruction Section&#10;        InstructionSection(&#10;            modifier = Modifier&#10;                .align(Alignment.BottomCenter)&#10;                .padding(bottom = 48.dp, start = 24.dp, end = 24.dp),&#10;            uiState = state,&#10;            onRetryClick = {},&#10;            onCloseClick = {}&#10;        )&#10;&#10;        // Loading Overlay for processing state&#10;        if (state.isProcessing) {&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .background(Color.Black.copy(alpha = 0.3f)),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Card(&#10;                    modifier = Modifier.padding(32.dp),&#10;                    colors = CardDefaults.cardColors(&#10;                        containerColor = MaterialTheme.colorScheme.surface&#10;                    )&#10;                ) {&#10;                    Column(&#10;                        modifier = Modifier.padding(24.dp),&#10;                        horizontalAlignment = Alignment.CenterHorizontally,&#10;                        verticalArrangement = Arrangement.spacedBy(16.dp)&#10;                    ) {&#10;                        CircularProgressIndicator()&#10;                        Text(&#10;                            text = state.instructionText,&#10;                            style = MaterialTheme.typography.bodyMedium,&#10;                            textAlign = TextAlign.Center&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.infinite_track.presentation.screen.attendance.face&#10;&#10;import android.graphics.Bitmap&#10;import androidx.camera.core.CameraSelector&#10;import androidx.camera.core.ImageProxy&#10;import androidx.camera.lifecycle.ProcessCameraProvider&#10;import androidx.camera.view.PreviewView&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Close&#10;import androidx.compose.material.icons.filled.SentimentSatisfied&#10;import androidx.compose.material.icons.filled.Visibility&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.CircularProgressIndicator&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.LinearProgressIndicator&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.OutlinedButton&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.DisposableEffect&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.onSizeChanged&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.viewinterop.AndroidView&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import androidx.navigation.NavController&#10;import com.example.infinite_track.presentation.components.button.ButtonStateType&#10;import com.example.infinite_track.presentation.components.button.ButtonStyle&#10;import com.example.infinite_track.presentation.components.button.StatefulButton&#10;import com.example.infinite_track.presentation.components.cameras.FaceBoundingBox&#10;import com.example.infinite_track.presentation.components.loading.LoadingAnimation&#10;import com.example.infinite_track.presentation.theme.Blue_500&#10;import com.google.accompanist.permissions.ExperimentalPermissionsApi&#10;import com.google.accompanist.permissions.isGranted&#10;import com.google.accompanist.permissions.rememberPermissionState&#10;import com.google.accompanist.permissions.shouldShowRationale&#10;import java.util.concurrent.ExecutorService&#10;import java.util.concurrent.Executors&#10;import androidx.camera.core.Preview as CameraPreview&#10;&#10;@OptIn(ExperimentalMaterial3Api::class, ExperimentalPermissionsApi::class)&#10;@Composable&#10;fun FaceScannerScreen(&#10;    action: String,&#10;    navController: NavController,&#10;    modifier: Modifier = Modifier,&#10;    viewModel: FaceScannerViewModel = hiltViewModel()&#10;) {&#10;    val uiState by viewModel.uiState.collectAsStateWithLifecycle()&#10;&#10;    // Camera permission state&#10;    val cameraPermissionState = rememberPermissionState(&#10;        android.Manifest.permission.CAMERA&#10;    )&#10;&#10;    // Camera executor&#10;    val cameraExecutor = remember { Executors.newSingleThreadExecutor() }&#10;&#10;    // KUNCI PERBAIKAN: Reset scanner setiap kali screen muncul&#10;    // Ini akan memastikan ViewModel selalu dalam state fresh&#10;    LaunchedEffect(Unit) {&#10;        // Reset scanner terlebih dahulu untuk memastikan state bersih&#10;        viewModel.initializeScanner()&#10;&#10;        // Then request camera permission if not granted&#10;        if (!cameraPermissionState.status.isGranted) {&#10;            cameraPermissionState.launchPermissionRequest()&#10;        }&#10;    }&#10;&#10;    // Handle navigation based on verification result&#10;    LaunchedEffect(uiState.livenessState) {&#10;        when (uiState.livenessState) {&#10;            LivenessState.SUCCESS -&gt; {&#10;                // Send success result and navigate back to proceed with attendance&#10;                navController.previousBackStackEntry?.savedStateHandle?.set(&#10;                    &quot;face_verification_result&quot;,&#10;                    true&#10;                )&#10;                navController.popBackStack()&#10;            }&#10;&#10;            LivenessState.TIMEOUT -&gt; {&#10;                // TIMEOUT means user ran out of time - send failure and go back&#10;                navController.previousBackStackEntry?.savedStateHandle?.set(&#10;                    &quot;face_verification_result&quot;,&#10;                    false&#10;                )&#10;                navController.popBackStack()&#10;            }&#10;&#10;            // FAILURE stays on screen to allow retry - no automatic navigation&#10;            LivenessState.FAILURE -&gt; {&#10;                // Stay on screen, show retry button - user can try again&#10;            }&#10;&#10;            else -&gt; {&#10;                // Continue with current state - don't navigate anywhere&#10;            }&#10;        }&#10;    }&#10;&#10;    // Cleanup camera executor when composable is disposed&#10;    DisposableEffect(Unit) {&#10;        onDispose {&#10;            cameraExecutor.shutdown()&#10;        }&#10;    }&#10;&#10;    Box(modifier = modifier.fillMaxSize()) {&#10;        when {&#10;            cameraPermissionState.status.isGranted -&gt; {&#10;                // Camera permission granted - show camera interface&#10;                CameraContent(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    action = action,&#10;                    uiState = uiState,&#10;                    cameraExecutor = cameraExecutor,&#10;                    onImageAnalysis = { imageProxy, bitmap -&gt;&#10;                        viewModel.processImageProxy(imageProxy, bitmap)&#10;                    },&#10;                    onRetryClick = {&#10;                        viewModel.resetScanner()&#10;                    },&#10;                    onCloseClick = {&#10;                        navController.popBackStack()&#10;                    }&#10;                )&#10;            }&#10;&#10;            cameraPermissionState.status.shouldShowRationale -&gt; {&#10;                // Show rationale for camera permission&#10;                CameraPermissionRationale(&#10;                    onRequestPermission = {&#10;                        cameraPermissionState.launchPermissionRequest()&#10;                    },&#10;                    onCloseClick = {&#10;                        navController.popBackStack()&#10;                    }&#10;                )&#10;            }&#10;&#10;            else -&gt; {&#10;                // Permission denied - show permission request UI&#10;                CameraPermissionDenied(&#10;                    onRequestPermission = {&#10;                        cameraPermissionState.launchPermissionRequest()&#10;                    },&#10;                    onCloseClick = {&#10;                        navController.popBackStack()&#10;                    }&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun CameraContent(&#10;    modifier: Modifier = Modifier,&#10;    action: String,&#10;    uiState: FaceScannerState,&#10;    cameraExecutor: ExecutorService,&#10;    onImageAnalysis: (ImageProxy, Bitmap) -&gt; Unit,&#10;    onRetryClick: () -&gt; Unit,&#10;    onCloseClick: () -&gt; Unit&#10;) {&#10;    val density = LocalDensity.current&#10;    var previewSize by remember { mutableStateOf&lt;androidx.compose.ui.geometry.Size?&gt;(null) }&#10;&#10;    // Get screen dimensions for proper scaling&#10;    val configuration = androidx.compose.ui.platform.LocalConfiguration.current&#10;    val screenWidth = configuration.screenWidthDp.dp&#10;    val screenHeight = configuration.screenHeightDp.dp&#10;&#10;    Box(&#10;        modifier = modifier&#10;            .fillMaxSize()&#10;            .onSizeChanged { size -&gt;&#10;                // Capture actual preview size for coordinate scaling&#10;                previewSize = androidx.compose.ui.geometry.Size(&#10;                    width = size.width.toFloat(),&#10;                    height = size.height.toFloat()&#10;                )&#10;            }&#10;    ) {&#10;        // Layer 1: Camera Preview with proper CameraX integration&#10;        CameraPreview(&#10;            modifier = Modifier.fillMaxSize(),&#10;            cameraExecutor = cameraExecutor,&#10;            onImageAnalysis = { imageProxy, bitmap -&gt;&#10;                onImageAnalysis(imageProxy, bitmap)&#10;            }&#10;        )&#10;&#10;        // Layer 2: Face Bounding Box Overlay with proper coordinate scaling&#10;        FaceBoundingBox(&#10;            modifier = Modifier.fillMaxSize(),&#10;            boundingBox = uiState.boundingBox,&#10;            livenessState = uiState.livenessState,&#10;            previewSize = previewSize, // Pass actual preview size&#10;            imageSize = uiState.imageSize // Pass image size from ViewModel&#10;        )&#10;&#10;        // Layer 3: Top Info Section - More compact&#10;        TopInfoSection(&#10;            modifier = Modifier&#10;                .align(Alignment.TopCenter)&#10;                .padding(top = 16.dp, start = 16.dp, end = 16.dp),&#10;            action = action&#10;        )&#10;&#10;        // Layer 4: Instruction Section with dynamic content&#10;        InstructionSection(&#10;            modifier = Modifier&#10;                .align(Alignment.BottomCenter)&#10;                .padding(bottom = 16.dp, start = 16.dp, end = 16.dp),&#10;            uiState = uiState,&#10;            onRetryClick = onRetryClick,&#10;            onCloseClick = onCloseClick&#10;        )&#10;&#10;        // Layer 5: Loading Overlay for processing state&#10;        if (uiState.isProcessing) {&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .background(Color.Black.copy(alpha = 0.3f)),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Card(&#10;                    modifier = Modifier.padding(32.dp),&#10;                    colors = CardDefaults.cardColors(&#10;                        containerColor = MaterialTheme.colorScheme.surface&#10;                    )&#10;                ) {&#10;                    Column(&#10;                        modifier = Modifier.padding(24.dp),&#10;                        horizontalAlignment = Alignment.CenterHorizontally,&#10;                        verticalArrangement = Arrangement.spacedBy(16.dp)&#10;                    ) {&#10;                        LoadingAnimation()&#10;                        Text(&#10;                            text = uiState.instructionText,&#10;                            style = MaterialTheme.typography.bodyMedium,&#10;                            textAlign = TextAlign.Center&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun CameraPreview(&#10;    modifier: Modifier = Modifier,&#10;    cameraExecutor: ExecutorService,&#10;    onImageAnalysis: (ImageProxy, Bitmap) -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val lifecycleOwner = androidx.lifecycle.compose.LocalLifecycleOwner.current&#10;    val previewView = remember {&#10;        PreviewView(context).apply {&#10;            scaleType = PreviewView.ScaleType.FILL_CENTER&#10;        }&#10;    }&#10;&#10;    // Camera binding setup&#10;    LaunchedEffect(Unit) {&#10;        val cameraProviderFuture = ProcessCameraProvider.getInstance(context)&#10;&#10;        try {&#10;            val cameraProvider = cameraProviderFuture.get()&#10;&#10;            // Unbind all use cases before rebinding&#10;            cameraProvider.unbindAll()&#10;&#10;            // Preview use case&#10;            val preview = CameraPreview.Builder()&#10;                .build()&#10;                .also {&#10;                    it.surfaceProvider = previewView.surfaceProvider&#10;                }&#10;&#10;            // Image analysis use case&#10;            val imageAnalysis = androidx.camera.core.ImageAnalysis.Builder()&#10;                .setBackpressureStrategy(androidx.camera.core.ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST)&#10;                .build()&#10;                .also { analysis -&gt;&#10;                    analysis.setAnalyzer(cameraExecutor) { imageProxy -&gt;&#10;                        try {&#10;                            val bitmap = imageProxyToBitmap(imageProxy)&#10;                            if (bitmap != null) {&#10;                                onImageAnalysis(imageProxy, bitmap)&#10;                            } else {&#10;                                imageProxy.close()&#10;                            }&#10;                        } catch (e: Exception) {&#10;                            imageProxy.close()&#10;                        }&#10;                    }&#10;                }&#10;&#10;            // Select front camera&#10;            val cameraSelector = CameraSelector.DEFAULT_FRONT_CAMERA&#10;&#10;            // Bind use cases to camera&#10;            cameraProvider.bindToLifecycle(&#10;                lifecycleOwner,&#10;                cameraSelector,&#10;                preview,&#10;                imageAnalysis&#10;            )&#10;&#10;        } catch (exc: Exception) {&#10;            exc.printStackTrace()&#10;        }&#10;    }&#10;&#10;    DisposableEffect(Unit) {&#10;        onDispose {&#10;            // Camera cleanup handled by lifecycle&#10;        }&#10;    }&#10;&#10;    // Simple AndroidView without update block&#10;    AndroidView(&#10;        factory = { previewView },&#10;        modifier = modifier&#10;    )&#10;}&#10;&#10;@Composable&#10;private fun TopInfoSection(&#10;    modifier: Modifier = Modifier,&#10;    action: String&#10;) {&#10;    Column(&#10;        modifier = modifier.fillMaxWidth(),&#10;        horizontalAlignment = Alignment.CenterHorizontally,&#10;        verticalArrangement = Arrangement.Center&#10;    ) {&#10;        Text(&#10;            text = &quot;Verifikasi Wajah&quot;,&#10;            style = MaterialTheme.typography.titleMedium,&#10;            color = Color.White,&#10;            fontWeight = FontWeight.Bold,&#10;            textAlign = TextAlign.Center,&#10;            modifier = Modifier.fillMaxWidth()&#10;        )&#10;        Spacer(modifier = Modifier.height(2.dp))&#10;        Text(&#10;            text = if (action == &quot;checkin&quot;) &quot;Check In&quot; else &quot;Check Out&quot;,&#10;            style = MaterialTheme.typography.bodyMedium,&#10;            color = Color.White.copy(alpha = 0.9f),&#10;            fontWeight = FontWeight.Medium,&#10;            textAlign = TextAlign.Center,&#10;            modifier = Modifier.fillMaxWidth()&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun InstructionSection(&#10;    modifier: Modifier = Modifier,&#10;    uiState: FaceScannerState,&#10;    onRetryClick: () -&gt; Unit,&#10;    onCloseClick: () -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = modifier.fillMaxWidth(),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.surface.copy(alpha = 0.50f)&#10;        ),&#10;        shape = RoundedCornerShape(16.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(12.dp),&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.spacedBy(8.dp)&#10;        ) {&#10;            // Status Icon&#10;            val icon = when (uiState.livenessState) {&#10;                LivenessState.WAITING_FOR_LIVENESS -&gt; {&#10;                    if (uiState.currentChallenge == LivenessChallenge.BLINK) {&#10;                        Icons.Default.Visibility&#10;                    } else {&#10;                        Icons.Default.SentimentSatisfied&#10;                    }&#10;                }&#10;&#10;                LivenessState.SUCCESS -&gt; Icons.Default.SentimentSatisfied&#10;                else -&gt; Icons.Default.Visibility&#10;            }&#10;&#10;            val iconColor = when (uiState.livenessState) {&#10;                LivenessState.SUCCESS -&gt; Color(0xFF00FFC2)&#10;                LivenessState.FAILURE, LivenessState.TIMEOUT -&gt; Color(0xFFFF3B30)&#10;                LivenessState.WAITING_FOR_LIVENESS -&gt; Color(0xFFFFD60A)&#10;                else -&gt; Color(0xFF00A3FF)&#10;            }&#10;&#10;            Icon(&#10;                imageVector = icon,&#10;                contentDescription = null,&#10;                modifier = Modifier.size(36.dp),&#10;                tint = iconColor&#10;            )&#10;&#10;            // Instruction Text&#10;            Text(&#10;                text = uiState.instructionText,&#10;                style = MaterialTheme.typography.bodyMedium,&#10;                textAlign = TextAlign.Center,&#10;                fontWeight = FontWeight.Medium&#10;            )&#10;&#10;            // Progress Indicator (for countdown)&#10;            if (uiState.showCountdown &amp;&amp; uiState.livenessState != LivenessState.SUCCESS) {&#10;                Row(&#10;                    verticalAlignment = Alignment.CenterVertically,&#10;                    horizontalArrangement = Arrangement.spacedBy(6.dp)&#10;                ) {&#10;                    LinearProgressIndicator(&#10;                        progress = uiState.progress,&#10;                        color = Blue_500,&#10;                        modifier = Modifier&#10;                            .weight(1f)&#10;                            .height(3.dp)&#10;                            .clip(RoundedCornerShape(2.dp))&#10;                    )&#10;                    Text(&#10;                        text = &quot;${uiState.timeRemaining}s&quot;,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f)&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Error Message&#10;            uiState.errorMessage?.let { errorMessage -&gt;&#10;                Text(&#10;                    text = errorMessage,&#10;                    style = MaterialTheme.typography.bodySmall,&#10;                    color = Color(0xFFFF3B30),&#10;                    textAlign = TextAlign.Center&#10;                )&#10;            }&#10;&#10;            // Action Buttons&#10;            Row(&#10;                horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;            ) {&#10;                // Close Button menggunakan StatefulButton dengan state Error&#10;                StatefulButton(&#10;                    text = &quot;Tutup&quot;,&#10;                    onClick = onCloseClick,&#10;                    modifier = Modifier.weight(1f),&#10;                    style = ButtonStyle.Outlined,&#10;                    stateType = ButtonStateType.Error,&#10;                    enabled = true&#10;                )&#10;&#10;                // Retry Button (show when failed or timeout) menggunakan StatefulButton&#10;                if (uiState.livenessState == LivenessState.FAILURE ||&#10;                    uiState.livenessState == LivenessState.TIMEOUT&#10;                ) {&#10;                    StatefulButton(&#10;                        text = &quot;Coba Lagi&quot;,&#10;                        onClick = onRetryClick,&#10;                        modifier = Modifier.weight(1f),&#10;                        style = ButtonStyle.Elevated,&#10;                        stateType = ButtonStateType.Info,&#10;                        enabled = true&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;// Helper function to convert ImageProxy to Bitmap&#10;private fun imageProxyToBitmap(imageProxy: ImageProxy): Bitmap? {&#10;    return try {&#10;        // Get the YUV_420_888 image from camera&#10;        val image = imageProxy.image&#10;        if (image != null) {&#10;            val planes = image.planes&#10;            val yBuffer = planes[0].buffer&#10;            val uBuffer = planes[1].buffer&#10;            val vBuffer = planes[2].buffer&#10;&#10;            val ySize = yBuffer.remaining()&#10;            val uSize = uBuffer.remaining()&#10;            val vSize = vBuffer.remaining()&#10;&#10;            val nv21 = ByteArray(ySize + uSize + vSize)&#10;&#10;            // U and V are swapped&#10;            yBuffer.get(nv21, 0, ySize)&#10;            vBuffer.get(nv21, ySize, vSize)&#10;            uBuffer.get(nv21, ySize + vSize, uSize)&#10;&#10;            val yuvImage = android.graphics.YuvImage(&#10;                nv21,&#10;                android.graphics.ImageFormat.NV21,&#10;                image.width,&#10;                image.height,&#10;                null&#10;            )&#10;&#10;            val out = java.io.ByteArrayOutputStream()&#10;            yuvImage.compressToJpeg(&#10;                android.graphics.Rect(0, 0, image.width, image.height),&#10;                75,&#10;                out&#10;            )&#10;&#10;            val imageBytes = out.toByteArray()&#10;            val bitmap =&#10;                android.graphics.BitmapFactory.decodeByteArray(imageBytes, 0, imageBytes.size)&#10;&#10;            // Close the output stream&#10;            out.close()&#10;            bitmap&#10;        } else {&#10;            null&#10;        }&#10;    } catch (e: Exception) {&#10;        null&#10;    }&#10;}&#10;&#10;// Permission UI Components&#10;@Composable&#10;private fun CameraPermissionRationale(&#10;    onRequestPermission: () -&gt; Unit,&#10;    onCloseClick: () -&gt; Unit&#10;) {&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(MaterialTheme.colorScheme.background),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(32.dp),&#10;            colors = CardDefaults.cardColors(&#10;                containerColor = MaterialTheme.colorScheme.surface&#10;            ),&#10;            shape = RoundedCornerShape(16.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(24.dp),&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#10;                verticalArrangement = Arrangement.spacedBy(16.dp)&#10;            ) {&#10;                Icon(&#10;                    imageVector = Icons.Default.Visibility,&#10;                    contentDescription = null,&#10;                    modifier = Modifier.size(64.dp),&#10;                    tint = MaterialTheme.colorScheme.primary&#10;                )&#10;&#10;                Text(&#10;                    text = &quot;Izin Kamera Diperlukan&quot;,&#10;                    style = MaterialTheme.typography.headlineSmall,&#10;                    fontWeight = FontWeight.Bold,&#10;                    textAlign = TextAlign.Center&#10;                )&#10;&#10;                Text(&#10;                    text = &quot;Aplikasi memerlukan akses kamera untuk melakukan verifikasi wajah. Fitur ini membantu memastikan keamanan absensi Anda.&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    textAlign = TextAlign.Center,&#10;                    color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.8f)&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                Row(&#10;                    horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;                    modifier = Modifier.fillMaxWidth()&#10;                ) {&#10;                    OutlinedButton(&#10;                        onClick = onCloseClick,&#10;                        modifier = Modifier.weight(1f)&#10;                    ) {&#10;                        Text(&quot;Batal&quot;)&#10;                    }&#10;&#10;                    Button(&#10;                        onClick = onRequestPermission,&#10;                        modifier = Modifier.weight(1f)&#10;                    ) {&#10;                        Text(&quot;Berikan Izin&quot;)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun CameraPermissionDenied(&#10;    onRequestPermission: () -&gt; Unit,&#10;    onCloseClick: () -&gt; Unit&#10;) {&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(MaterialTheme.colorScheme.background),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(32.dp),&#10;            colors = CardDefaults.cardColors(&#10;                containerColor = MaterialTheme.colorScheme.surface&#10;            ),&#10;            shape = RoundedCornerShape(16.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(24.dp),&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#10;                verticalArrangement = Arrangement.spacedBy(16.dp)&#10;            ) {&#10;                Icon(&#10;                    imageVector = Icons.Default.Close,&#10;                    contentDescription = null,&#10;                    modifier = Modifier.size(64.dp),&#10;                    tint = Color(0xFFFF3B30)&#10;                )&#10;&#10;                Text(&#10;                    text = &quot;Akses Kamera Dibutuhkan&quot;,&#10;                    style = MaterialTheme.typography.headlineSmall,&#10;                    fontWeight = FontWeight.Bold,&#10;                    textAlign = TextAlign.Center&#10;                )&#10;&#10;                Text(&#10;                    text = &quot;Tanpa akses kamera, fitur verifikasi wajah tidak dapat berfungsi. Silakan berikan izin kamera untuk melanjutkan proses absensi.&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    textAlign = TextAlign.Center,&#10;                    color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.8f)&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                Row(&#10;                    horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;                    modifier = Modifier.fillMaxWidth()&#10;                ) {&#10;                    OutlinedButton(&#10;                        onClick = onCloseClick,&#10;                        modifier = Modifier.weight(1f)&#10;                    ) {&#10;                        Text(&quot;Tutup&quot;)&#10;                    }&#10;&#10;                    Button(&#10;                        onClick = onRequestPermission,&#10;                        modifier = Modifier.weight(1f)&#10;                    ) {&#10;                        Text(&quot;Coba Lagi&quot;)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;// Preview Composables for different states&#10;@Preview(showBackground = true, name = &quot;Check In - Initial State&quot;)&#10;@Composable&#10;fun PreviewFaceScannerCheckIn() {&#10;    MaterialTheme {&#10;        FaceScannerScreenPreview(&#10;            action = &quot;checkin&quot;,&#10;            state = FaceScannerState(&#10;                livenessState = LivenessState.IDLE,&#10;                instructionText = &quot;Posisikan wajah Anda dalam frame&quot;,&#10;                isProcessing = false,&#10;                showCountdown = false&#10;            )&#10;        )&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true, name = &quot;Check Out - Waiting for Liveness&quot;)&#10;@Composable&#10;fun PreviewFaceScannerCheckOutWaiting() {&#10;    MaterialTheme {&#10;        FaceScannerScreenPreview(&#10;            action = &quot;checkout&quot;,&#10;            state = FaceScannerState(&#10;                livenessState = LivenessState.WAITING_FOR_LIVENESS,&#10;                currentChallenge = LivenessChallenge.BLINK,&#10;                instructionText = &quot;Silakan berkedip untuk verifikasi&quot;,&#10;                isProcessing = false,&#10;                showCountdown = true,&#10;                progress = 0.6f,&#10;                timeRemaining = 4&#10;            )&#10;        )&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true, name = &quot;Processing State&quot;)&#10;@Composable&#10;fun PreviewFaceScannerProcessing() {&#10;    MaterialTheme {&#10;        FaceScannerScreenPreview(&#10;            action = &quot;checkin&quot;,&#10;            state = FaceScannerState(&#10;                livenessState = LivenessState.VERIFYING_FACE,&#10;                instructionText = &quot;Memproses verifikasi wajah...&quot;,&#10;                isProcessing = true,&#10;                showCountdown = false&#10;            )&#10;        )&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true, name = &quot;Success State&quot;)&#10;@Composable&#10;fun PreviewFaceScannerSuccess() {&#10;    MaterialTheme {&#10;        FaceScannerScreenPreview(&#10;            action = &quot;checkin&quot;,&#10;            state = FaceScannerState(&#10;                livenessState = LivenessState.SUCCESS,&#10;                instructionText = &quot;Verifikasi berhasil!&quot;,&#10;                isProcessing = false,&#10;                showCountdown = false&#10;            )&#10;        )&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true, name = &quot;Failure State&quot;)&#10;@Composable&#10;fun PreviewFaceScannerFailure() {&#10;    MaterialTheme {&#10;        FaceScannerScreenPreview(&#10;            action = &quot;checkout&quot;,&#10;            state = FaceScannerState(&#10;                livenessState = LivenessState.FAILURE,&#10;                instructionText = &quot;Verifikasi gagal&quot;,&#10;                errorMessage = &quot;Wajah tidak terdeteksi dengan jelas. Silakan coba lagi.&quot;,&#10;                isProcessing = false,&#10;                showCountdown = false&#10;            )&#10;        )&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true, name = &quot;Timeout State&quot;)&#10;@Composable&#10;fun PreviewFaceScannerTimeout() {&#10;    MaterialTheme {&#10;        FaceScannerScreenPreview(&#10;            action = &quot;checkin&quot;,&#10;            state = FaceScannerState(&#10;                livenessState = LivenessState.TIMEOUT,&#10;                instructionText = &quot;Waktu habis&quot;,&#10;                errorMessage = &quot;Waktu verifikasi telah habis. Silakan coba lagi.&quot;,&#10;                isProcessing = false,&#10;                showCountdown = false&#10;            )&#10;        )&#10;    }&#10;}&#10;&#10;// Simplified preview composable without camera and ViewModel dependencies&#10;@Composable&#10;private fun FaceScannerScreenPreview(&#10;    action: String,&#10;    state: FaceScannerState&#10;) {&#10;    Box(modifier = Modifier.fillMaxSize()) {&#10;        // Mock camera background&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .background(Color.Black)&#10;        )&#10;&#10;        // Top Info Section&#10;        TopInfoSection(&#10;            modifier = Modifier&#10;                .align(Alignment.TopCenter)&#10;                .padding(top = 48.dp, start = 24.dp, end = 24.dp),&#10;            action = action&#10;        )&#10;&#10;        // Instruction Section&#10;        InstructionSection(&#10;            modifier = Modifier&#10;                .align(Alignment.BottomCenter)&#10;                .padding(bottom = 48.dp, start = 24.dp, end = 24.dp),&#10;            uiState = state,&#10;            onRetryClick = {},&#10;            onCloseClick = {}&#10;        )&#10;&#10;        // Loading Overlay for processing state&#10;        if (state.isProcessing) {&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .background(Color.Black.copy(alpha = 0.3f)),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Card(&#10;                    modifier = Modifier.padding(32.dp),&#10;                    colors = CardDefaults.cardColors(&#10;                        containerColor = MaterialTheme.colorScheme.surface&#10;                    )&#10;                ) {&#10;                    Column(&#10;                        modifier = Modifier.padding(24.dp),&#10;                        horizontalAlignment = Alignment.CenterHorizontally,&#10;                        verticalArrangement = Arrangement.spacedBy(16.dp)&#10;                    ) {&#10;                        CircularProgressIndicator()&#10;                        Text(&#10;                            text = state.instructionText,&#10;                            style = MaterialTheme.typography.bodyMedium,&#10;                            textAlign = TextAlign.Center&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/presentation/screen/attendance/face/FaceScannerViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/presentation/screen/attendance/face/FaceScannerViewModel.kt" />
              <option name="originalContent" value="package com.example.infinite_track.presentation.screen.attendance.face&#10;&#10;import android.graphics.Bitmap&#10;import androidx.camera.core.ImageProxy&#10;import androidx.compose.ui.geometry.Rect&#10;import androidx.compose.ui.geometry.Size&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.infinite_track.data.face.FaceDetectorHelper&#10;import com.example.infinite_track.data.face.LivenessResult&#10;import com.example.infinite_track.domain.use_case.auth.VerifyFaceUseCase&#10;import com.google.mlkit.vision.face.Face&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;&#10;/**&#10; * Enum untuk tantangan liveness detection&#10; */&#10;enum class LivenessChallenge {&#10;    BLINK, SMILE&#10;}&#10;&#10;/**&#10; * Enum untuk status proses liveness detection&#10; */&#10;enum class LivenessState {&#10;    IDLE,&#10;    DETECTING_FACE,&#10;    WAITING_FOR_LIVENESS,&#10;    LIVENESS_DETECTED,&#10;    VERIFYING_FACE,&#10;    SUCCESS,&#10;    FAILURE,&#10;    TIMEOUT&#10;}&#10;&#10;/**&#10; * Data class untuk state lengkap face scanner&#10; */&#10;data class FaceScannerState(&#10;    val livenessState: LivenessState = LivenessState.IDLE,&#10;    val currentChallenge: LivenessChallenge = LivenessChallenge.BLINK,&#10;    val instructionText: String = &quot;&quot;,&#10;    val boundingBox: Rect? = null, // Changed to androidx.compose.ui.geometry.Rect&#10;    val progress: Float = 0f,&#10;    val errorMessage: String? = null,&#10;    val isProcessing: Boolean = false,&#10;    val timeRemaining: Int = 20, // 20 detik sesuai kebutuhan&#10;    val showCountdown: Boolean = false,&#10;    val imageSize: Size? = null // Add image size for coordinate scaling&#10;)&#10;&#10;/**&#10; * ViewModel untuk mengatur logika face scanning dengan liveness detection&#10; */&#10;@HiltViewModel&#10;class FaceScannerViewModel @Inject constructor(&#10;    private val faceDetectorHelper: FaceDetectorHelper,&#10;    private val verifyFaceUseCase: VerifyFaceUseCase&#10;) : ViewModel() {&#10;&#10;    companion object {&#10;        private const val TIMEOUT_SECONDS = 20&#10;        private const val LIVENESS_HOLD_DURATION = 1500L // 1.5 detik hold untuk stabilitas&#10;    }&#10;&#10;    // Change from mutableStateOf to StateFlow for better compatibility&#10;    private val _uiState = MutableStateFlow(FaceScannerState())&#10;    val uiState: StateFlow&lt;FaceScannerState&gt; = _uiState.asStateFlow()&#10;&#10;    private var timeoutJob: Job? = null&#10;    private var livenessJob: Job? = null&#10;    private var currentDetectedFace: Face? = null&#10;    private var currentImageBitmap: Bitmap? = null&#10;&#10;    init {&#10;        // Tidak langsung initialize di sini - biarkan UI yang mengontrol&#10;        // initializeScanner() akan dipanggil dari UI&#10;    }&#10;&#10;    /**&#10;     * Inisialisasi scanner dengan random challenge&#10;     * DIPUBLIKKAN agar bisa dipanggil dari UI untuk reset&#10;     * PERBAIKAN: Memastikan reset state yang benar-benar bersih + reinitialize detector&#10;     */&#10;    fun initializeScanner() {&#10;        println(&quot;=== INITIALIZING SCANNER - START ===&quot;)&#10;&#10;        // STEP 1: Cancel any ongoing jobs first&#10;        timeoutJob?.cancel()&#10;        livenessJob?.cancel()&#10;&#10;        // STEP 2: Clear all cached data&#10;        currentDetectedFace = null&#10;        currentImageBitmap = null&#10;&#10;        // STEP 3: KUNCI PERBAIKAN - Reinitialize FaceDetector&#10;        faceDetectorHelper.reinitialize()&#10;&#10;        println(&quot;Previous jobs cancelled, cached data cleared, and detector reinitialized&quot;)&#10;&#10;        // STEP 4: Pilih challenge secara acak&#10;        val randomChallenge = if ((0..1).random() == 0) {&#10;            LivenessChallenge.BLINK&#10;        } else {&#10;            LivenessChallenge.SMILE&#10;        }&#10;&#10;        val instructionText = when (randomChallenge) {&#10;            LivenessChallenge.BLINK -&gt; &quot;Posisikan wajah Anda di dalam frame, lalu kedipkan mata&quot;&#10;            LivenessChallenge.SMILE -&gt; &quot;Posisikan wajah Anda di dalam frame, lalu tersenyum&quot;&#10;        }&#10;&#10;        // STEP 5: PERBAIKAN - Reset state ke kondisi benar-benar fresh&#10;        _uiState.value = FaceScannerState(&#10;            currentChallenge = randomChallenge,&#10;            instructionText = instructionText,&#10;            livenessState = LivenessState.DETECTING_FACE, // Pastikan state fresh&#10;            timeRemaining = TIMEOUT_SECONDS,&#10;            showCountdown = true,&#10;            isProcessing = false,&#10;            errorMessage = null,&#10;            boundingBox = null,&#10;            progress = 0f,&#10;            imageSize = null // Reset image size juga&#10;        )&#10;&#10;        // STEP 6: Start fresh timeout&#10;        startTimeout()&#10;&#10;        println(&quot;=== SCANNER INITIALIZED SUCCESSFULLY ===&quot;)&#10;        println(&quot;Challenge: $randomChallenge&quot;)&#10;        println(&quot;State: ${_uiState.value.livenessState}&quot;)&#10;        println(&quot;Processing: ${_uiState.value.isProcessing}&quot;)&#10;        println(&quot;Detector reinitialized: YES&quot;)&#10;    }&#10;&#10;    /**&#10;     * Reset scanner untuk mencoba lagi - dengan logging yang lebih detail&#10;     */&#10;    fun resetScanner() {&#10;        println(&quot;=== RESET SCANNER REQUESTED ===&quot;)&#10;        println(&quot;Current state before reset: ${_uiState.value.livenessState}&quot;)&#10;        initializeScanner()&#10;        println(&quot;=== RESET SCANNER COMPLETED ===&quot;)&#10;    }&#10;&#10;    /**&#10;     * Proses frame dari kamera untuk deteksi wajah dan verifikasi liveness&#10;     * PERBAIKAN: Guard clause yang lebih smart untuk memungkinkan reset&#10;     */&#10;    fun processImageProxy(imageProxy: ImageProxy, imageBitmap: Bitmap) {&#10;        val currentState = _uiState.value.livenessState&#10;        val isProcessing = _uiState.value.isProcessing&#10;&#10;        // PERBAIKAN: Hanya blokir jika benar-benar sedang processing atau sudah final success&#10;        // FAILURE dan TIMEOUT harus bisa diproses lagi setelah reset&#10;        if (isProcessing || currentState == LivenessState.SUCCESS) {&#10;            println(&quot;BLOCKED: Processing=$isProcessing, State=$currentState&quot;)&#10;            imageProxy.close()&#10;            return&#10;        }&#10;&#10;        // PERBAIKAN: Log setiap frame yang diproses untuk debugging&#10;        println(&quot;PROCESSING FRAME: State=$currentState, Processing=$isProcessing&quot;)&#10;&#10;        currentImageBitmap = imageBitmap&#10;&#10;        // Panggil FaceDetectorHelper untuk mendeteksi wajah&#10;        faceDetectorHelper.detect(imageProxy) { result -&gt;&#10;            result.onSuccess { face -&gt;&#10;                println(&quot;FACE DETECTED: Processing face detection result&quot;)&#10;                handleFaceDetected(face, imageBitmap.width, imageBitmap.height)&#10;            }.onFailure { exception -&gt;&#10;                println(&quot;FACE DETECTION FAILED: ${exception.message}&quot;)&#10;                handleFaceDetectionError(exception.message ?: &quot;Error mendeteksi wajah&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Handle ketika wajah berhasil terdeteksi&#10;     */&#10;    private fun handleFaceDetected(face: Face, imageWidth: Int, imageHeight: Int) {&#10;        currentDetectedFace = face&#10;&#10;        // Convert android.graphics.Rect to androidx.compose.ui.geometry.Rect&#10;        val androidRect = face.boundingBox&#10;        val composeRect = Rect(&#10;            left = androidRect.left.toFloat(),&#10;            top = androidRect.top.toFloat(),&#10;            right = androidRect.right.toFloat(),&#10;            bottom = androidRect.bottom.toFloat()&#10;        )&#10;&#10;        // Update bounding box dan image size untuk UI dengan coordinate scaling yang proper&#10;        _uiState.value = _uiState.value.copy(&#10;            boundingBox = composeRect,&#10;            imageSize = Size(&#10;                width = imageWidth.toFloat(),&#10;                height = imageHeight.toFloat()&#10;            )&#10;        )&#10;&#10;        // Debug log untuk melihat koordinat&#10;        println(&quot;Face detected - Android Rect: $androidRect&quot;)&#10;        println(&quot;Face detected - Compose Rect: $composeRect&quot;)&#10;        println(&quot;Image size: ${imageWidth}x${imageHeight}&quot;)&#10;&#10;        // Cek apakah wajah berada di posisi yang baik&#10;        if (!faceDetectorHelper.isFaceWellPositioned(face, imageWidth, imageHeight)) {&#10;            _uiState.value = _uiState.value.copy(&#10;                livenessState = LivenessState.DETECTING_FACE,&#10;                instructionText = &quot;Posisikan wajah Anda lebih dekat dan di tengah frame&quot;&#10;            )&#10;            return&#10;        }&#10;&#10;        // Wajah sudah di posisi yang baik, lanjut ke pengecekan liveness&#10;        when (_uiState.value.livenessState) {&#10;            LivenessState.DETECTING_FACE -&gt; {&#10;                // Transisi ke waiting for liveness&#10;                _uiState.value = _uiState.value.copy(&#10;                    livenessState = LivenessState.WAITING_FOR_LIVENESS,&#10;                    instructionText = when (_uiState.value.currentChallenge) {&#10;                        LivenessChallenge.BLINK -&gt; &quot;Wajah terdeteksi! Sekarang kedipkan mata Anda&quot;&#10;                        LivenessChallenge.SMILE -&gt; &quot;Wajah terdeteksi! Sekarang tersenyum&quot;&#10;                    }&#10;                )&#10;            }&#10;&#10;            LivenessState.WAITING_FOR_LIVENESS -&gt; {&#10;                // Cek apakah challenge liveness terpenuhi&#10;                checkLivenessChallenge(face)&#10;            }&#10;&#10;            else -&gt; {&#10;                // State lain tidak perlu di-handle di sini&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Cek apakah challenge liveness saat ini terpenuhi dengan progressive feedback&#10;     */&#10;    private fun checkLivenessChallenge(face: Face) {&#10;        val livenessResult = when (_uiState.value.currentChallenge) {&#10;            LivenessChallenge.BLINK -&gt; faceDetectorHelper.verifyBlink(face)&#10;            LivenessChallenge.SMILE -&gt; faceDetectorHelper.verifySmile(face)&#10;        }&#10;&#10;        when (livenessResult) {&#10;            LivenessResult.SUCCESS -&gt; {&#10;                // Liveness berhasil terdeteksi - lanjut ke verifikasi&#10;                _uiState.value = _uiState.value.copy(&#10;                    livenessState = LivenessState.LIVENESS_DETECTED,&#10;                    instructionText = &quot;Liveness terdeteksi! Tetap di posisi...&quot;&#10;                )&#10;&#10;                // Tahan deteksi sebentar untuk stabilitas, lalu lanjut verifikasi&#10;                livenessJob?.cancel()&#10;                livenessJob = viewModelScope.launch {&#10;                    delay(LIVENESS_HOLD_DURATION)&#10;                    proceedWithFaceVerification()&#10;                }&#10;            }&#10;&#10;            LivenessResult.IN_PROGRESS -&gt; {&#10;                // User hampir berhasil - berikan umpan balik yang memandu&#10;                val progressText = when (_uiState.value.currentChallenge) {&#10;                    LivenessChallenge.BLINK -&gt; &quot;Hampir berhasil! Coba kedipkan kedua mata bersamaan&quot;&#10;                    LivenessChallenge.SMILE -&gt; &quot;Bagus! Tersenyum sedikit lebih lebar lagi&quot;&#10;                }&#10;&#10;                _uiState.value = _uiState.value.copy(&#10;                    livenessState = LivenessState.WAITING_FOR_LIVENESS,&#10;                    instructionText = progressText&#10;                )&#10;            }&#10;&#10;            LivenessResult.FAILURE -&gt; {&#10;                // Belum berhasil - berikan instruksi yang jelas&#10;                val failureText = when (_uiState.value.currentChallenge) {&#10;                    LivenessChallenge.BLINK -&gt; &quot;Silakan kedipkan mata Anda dengan jelas&quot;&#10;                    LivenessChallenge.SMILE -&gt; &quot;Silakan tersenyum dengan lebih jelas&quot;&#10;                }&#10;&#10;                _uiState.value = _uiState.value.copy(&#10;                    livenessState = LivenessState.WAITING_FOR_LIVENESS,&#10;                    instructionText = failureText&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Lanjutkan dengan verifikasi wajah setelah liveness terkonfirmasi&#10;     */&#10;    private fun proceedWithFaceVerification() {&#10;        val face = currentDetectedFace&#10;        val bitmap = currentImageBitmap&#10;&#10;        if (face == null || bitmap == null) {&#10;            handleVerificationError(&quot;Gagal mengambil data wajah&quot;)&#10;            return&#10;        }&#10;&#10;        _uiState.value = _uiState.value.copy(&#10;            livenessState = LivenessState.VERIFYING_FACE,&#10;            isProcessing = true,&#10;            instructionText = &quot;Memverifikasi identitas Anda...&quot;,&#10;            showCountdown = false&#10;        )&#10;&#10;        viewModelScope.launch {&#10;            try {&#10;                // DEBUG: Log bitmap info sebelum ekstraksi&#10;                println(&quot;DEBUG: Original bitmap size: ${bitmap.width}x${bitmap.height}&quot;)&#10;                println(&quot;DEBUG: Face bounding box: ${face.boundingBox}&quot;)&#10;&#10;                // Ekstrak bitmap wajah dari gambar penuh&#10;                val faceBitmap = faceDetectorHelper.extractFaceBitmap(face, bitmap)&#10;&#10;                if (faceBitmap == null) {&#10;                    handleVerificationError(&quot;Gagal mengekstrak wajah dari gambar&quot;)&#10;                    return@launch&#10;                }&#10;&#10;                // DEBUG: Log face bitmap info setelah ekstraksi&#10;                println(&quot;DEBUG: Extracted face bitmap size: ${faceBitmap.width}x${faceBitmap.height}&quot;)&#10;&#10;                // Verifikasi wajah menggunakan VerifyFaceUseCase&#10;                println(&quot;DEBUG: Starting face verification...&quot;)&#10;                verifyFaceUseCase(faceBitmap)&#10;                    .onSuccess { isMatch -&gt;&#10;                        println(&quot;DEBUG: Face verification completed. Match: $isMatch&quot;)&#10;                        if (isMatch) {&#10;                            handleVerificationSuccess()&#10;                        } else {&#10;                            handleVerificationError(&quot;Wajah tidak cocok dengan data yang tersimpan. Silakan coba lagi.&quot;)&#10;                        }&#10;                    }&#10;                    .onFailure { exception -&gt;&#10;                        println(&quot;DEBUG: Face verification failed with exception: ${exception.message}&quot;)&#10;                        handleVerificationError(&#10;                            exception.message ?: &quot;Gagal memverifikasi wajah. Silakan coba lagi.&quot;&#10;                        )&#10;                    }&#10;&#10;            } catch (e: Exception) {&#10;                println(&quot;DEBUG: Exception in proceedWithFaceVerification: ${e.message}&quot;)&#10;                handleVerificationError(&quot;Terjadi kesalahan: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Handle sukses verifikasi wajah&#10;     */&#10;    private fun handleVerificationSuccess() {&#10;        timeoutJob?.cancel()&#10;        livenessJob?.cancel()&#10;&#10;        _uiState.value = _uiState.value.copy(&#10;            livenessState = LivenessState.SUCCESS,&#10;            isProcessing = false,&#10;            instructionText = &quot;Verifikasi berhasil! Identitas terkonfirmasi.&quot;,&#10;            progress = 1f,&#10;            showCountdown = false,&#10;            errorMessage = null&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Handle error deteksi wajah&#10;     */&#10;    private fun handleFaceDetectionError(errorMessage: String) {&#10;        // Hanya update instruction jika masih dalam tahap deteksi&#10;        if (_uiState.value.livenessState == LivenessState.DETECTING_FACE) {&#10;            _uiState.value = _uiState.value.copy(&#10;                instructionText = &quot;Mencari wajah... Pastikan wajah terlihat jelas di dalam frame&quot;,&#10;                boundingBox = null&#10;            )&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Handle error verifikasi wajah&#10;     */&#10;    private fun handleVerificationError(errorMessage: String) {&#10;        timeoutJob?.cancel()&#10;        livenessJob?.cancel()&#10;&#10;        _uiState.value = _uiState.value.copy(&#10;            livenessState = LivenessState.FAILURE,&#10;            isProcessing = false,&#10;            instructionText = &quot;Verifikasi gagal&quot;,&#10;            errorMessage = errorMessage,&#10;            showCountdown = false&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Mulai countdown timer untuk timeout&#10;     */&#10;    private fun startTimeout() {&#10;        timeoutJob?.cancel()&#10;        timeoutJob = viewModelScope.launch {&#10;            repeat(TIMEOUT_SECONDS) { second -&gt;&#10;                val remainingTime = TIMEOUT_SECONDS - second&#10;                _uiState.value = _uiState.value.copy(&#10;                    timeRemaining = remainingTime,&#10;                    progress = second.toFloat() / TIMEOUT_SECONDS&#10;                )&#10;                delay(1000)&#10;&#10;                // Cek apakah proses sudah selesai&#10;                if (_uiState.value.livenessState == LivenessState.SUCCESS ||&#10;                    _uiState.value.livenessState == LivenessState.FAILURE&#10;                ) {&#10;                    return@launch&#10;                }&#10;            }&#10;&#10;            // Timeout tercapai&#10;            handleTimeout()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Handle timeout&#10;     */&#10;    private fun handleTimeout() {&#10;        livenessJob?.cancel()&#10;&#10;        _uiState.value = _uiState.value.copy(&#10;            livenessState = LivenessState.TIMEOUT,&#10;            isProcessing = false,&#10;            instructionText = &quot;Waktu habis&quot;,&#10;            errorMessage = &quot;Tidak dapat mendeteksi wajah dalam waktu $TIMEOUT_SECONDS detik. Silakan coba lagi.&quot;,&#10;            showCountdown = false,&#10;            timeRemaining = 0&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Bersihkan resources ketika ViewModel dihancurkan&#10;     */&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        timeoutJob?.cancel()&#10;        livenessJob?.cancel()&#10;        faceDetectorHelper.release()&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.infinite_track.presentation.screen.attendance.face&#10;&#10;import android.graphics.Bitmap&#10;import androidx.camera.core.ImageProxy&#10;import androidx.compose.ui.geometry.Rect&#10;import androidx.compose.ui.geometry.Size&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.infinite_track.data.face.FaceDetectorHelper&#10;import com.example.infinite_track.data.face.LivenessResult&#10;import com.example.infinite_track.domain.use_case.auth.VerifyFaceUseCase&#10;import com.google.mlkit.vision.face.Face&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;&#10;/**&#10; * Enum untuk tantangan liveness detection&#10; */&#10;enum class LivenessChallenge {&#10;    BLINK, SMILE&#10;}&#10;&#10;/**&#10; * Enum untuk status proses liveness detection&#10; */&#10;enum class LivenessState {&#10;    IDLE,&#10;    DETECTING_FACE,&#10;    WAITING_FOR_LIVENESS,&#10;    LIVENESS_DETECTED,&#10;    VERIFYING_FACE,&#10;    SUCCESS,&#10;    FAILURE,&#10;    TIMEOUT&#10;}&#10;&#10;/**&#10; * Data class untuk state lengkap face scanner&#10; */&#10;data class FaceScannerState(&#10;    val livenessState: LivenessState = LivenessState.IDLE,&#10;    val currentChallenge: LivenessChallenge = LivenessChallenge.BLINK,&#10;    val instructionText: String = &quot;&quot;,&#10;    val boundingBox: Rect? = null, // Changed to androidx.compose.ui.geometry.Rect&#10;    val progress: Float = 0f,&#10;    val errorMessage: String? = null,&#10;    val isProcessing: Boolean = false,&#10;    val timeRemaining: Int = 20, // 20 detik sesuai kebutuhan&#10;    val showCountdown: Boolean = false,&#10;    val imageSize: Size? = null // Add image size for coordinate scaling&#10;)&#10;&#10;/**&#10; * ViewModel untuk mengatur logika face scanning dengan liveness detection&#10; */&#10;@HiltViewModel&#10;class FaceScannerViewModel @Inject constructor(&#10;    private val faceDetectorHelper: FaceDetectorHelper,&#10;    private val verifyFaceUseCase: VerifyFaceUseCase&#10;) : ViewModel() {&#10;&#10;    companion object {&#10;        private const val TIMEOUT_SECONDS = 20&#10;        private const val LIVENESS_HOLD_DURATION = 1500L // 1.5 detik hold untuk stabilitas&#10;    }&#10;&#10;    // Change from mutableStateOf to StateFlow for better compatibility&#10;    private val _uiState = MutableStateFlow(FaceScannerState())&#10;    val uiState: StateFlow&lt;FaceScannerState&gt; = _uiState.asStateFlow()&#10;&#10;    private var timeoutJob: Job? = null&#10;    private var livenessJob: Job? = null&#10;    private var currentDetectedFace: Face? = null&#10;    private var currentImageBitmap: Bitmap? = null&#10;&#10;    init {&#10;        // Tidak langsung initialize di sini - biarkan UI yang mengontrol&#10;        // initializeScanner() akan dipanggil dari UI&#10;    }&#10;&#10;    /**&#10;     * Inisialisasi scanner dengan random challenge&#10;     * DIPUBLIKKAN agar bisa dipanggil dari UI untuk reset&#10;     */&#10;    fun initializeScanner() {&#10;        // STEP 1: Cancel any ongoing jobs first&#10;        timeoutJob?.cancel()&#10;        livenessJob?.cancel()&#10;&#10;        // STEP 2: Clear all cached data&#10;        currentDetectedFace = null&#10;        currentImageBitmap = null&#10;&#10;        // STEP 3: Reinitialize FaceDetector&#10;        faceDetectorHelper.reinitialize()&#10;&#10;        // STEP 4: Pilih challenge secara acak&#10;        val randomChallenge = if ((0..1).random() == 0) {&#10;            LivenessChallenge.BLINK&#10;        } else {&#10;            LivenessChallenge.SMILE&#10;        }&#10;&#10;        val instructionText = when (randomChallenge) {&#10;            LivenessChallenge.BLINK -&gt; &quot;Posisikan wajah Anda di dalam frame, lalu kedipkan mata&quot;&#10;            LivenessChallenge.SMILE -&gt; &quot;Posisikan wajah Anda di dalam frame, lalu tersenyum&quot;&#10;        }&#10;&#10;        // STEP 5: Reset state ke kondisi benar-benar fresh&#10;        _uiState.value = FaceScannerState(&#10;            currentChallenge = randomChallenge,&#10;            instructionText = instructionText,&#10;            livenessState = LivenessState.DETECTING_FACE,&#10;            timeRemaining = TIMEOUT_SECONDS,&#10;            showCountdown = true,&#10;            isProcessing = false,&#10;            errorMessage = null,&#10;            boundingBox = null,&#10;            progress = 0f,&#10;            imageSize = null&#10;        )&#10;&#10;        // STEP 6: Start fresh timeout&#10;        startTimeout()&#10;    }&#10;&#10;    /**&#10;     * Reset scanner untuk mencoba lagi&#10;     */&#10;    fun resetScanner() {&#10;        initializeScanner()&#10;    }&#10;&#10;    /**&#10;     * Proses frame dari kamera untuk deteksi wajah dan verifikasi liveness&#10;     */&#10;    fun processImageProxy(imageProxy: ImageProxy, imageBitmap: Bitmap) {&#10;        val currentState = _uiState.value.livenessState&#10;        val isProcessing = _uiState.value.isProcessing&#10;&#10;        // Hanya blokir jika benar-benar sedang processing atau sudah final success&#10;        if (isProcessing || currentState == LivenessState.SUCCESS) {&#10;            imageProxy.close()&#10;            return&#10;        }&#10;&#10;        currentImageBitmap = imageBitmap&#10;&#10;        // Panggil FaceDetectorHelper untuk mendeteksi wajah&#10;        faceDetectorHelper.detect(imageProxy) { result -&gt;&#10;            result.onSuccess { face -&gt;&#10;                handleFaceDetected(face, imageBitmap.width, imageBitmap.height)&#10;            }.onFailure { exception -&gt;&#10;                handleFaceDetectionError(exception.message ?: &quot;Error mendeteksi wajah&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Handle ketika wajah berhasil terdeteksi&#10;     */&#10;    private fun handleFaceDetected(face: Face, imageWidth: Int, imageHeight: Int) {&#10;        currentDetectedFace = face&#10;&#10;        // Convert android.graphics.Rect to androidx.compose.ui.geometry.Rect&#10;        val androidRect = face.boundingBox&#10;        val composeRect = Rect(&#10;            left = androidRect.left.toFloat(),&#10;            top = androidRect.top.toFloat(),&#10;            right = androidRect.right.toFloat(),&#10;            bottom = androidRect.bottom.toFloat()&#10;        )&#10;&#10;        // Update bounding box dan image size untuk UI dengan coordinate scaling yang proper&#10;        _uiState.value = _uiState.value.copy(&#10;            boundingBox = composeRect,&#10;            imageSize = Size(&#10;                width = imageWidth.toFloat(),&#10;                height = imageHeight.toFloat()&#10;            )&#10;        )&#10;&#10;        // Cek apakah wajah berada di posisi yang baik&#10;        if (!faceDetectorHelper.isFaceWellPositioned(face, imageWidth, imageHeight)) {&#10;            _uiState.value = _uiState.value.copy(&#10;                livenessState = LivenessState.DETECTING_FACE,&#10;                instructionText = &quot;Posisikan wajah Anda lebih dekat dan di tengah frame&quot;&#10;            )&#10;            return&#10;        }&#10;&#10;        // Wajah sudah di posisi yang baik, lanjut ke pengecekan liveness&#10;        when (_uiState.value.livenessState) {&#10;            LivenessState.DETECTING_FACE -&gt; {&#10;                // Transisi ke waiting for liveness&#10;                _uiState.value = _uiState.value.copy(&#10;                    livenessState = LivenessState.WAITING_FOR_LIVENESS,&#10;                    instructionText = when (_uiState.value.currentChallenge) {&#10;                        LivenessChallenge.BLINK -&gt; &quot;Wajah terdeteksi! Sekarang kedipkan mata Anda&quot;&#10;                        LivenessChallenge.SMILE -&gt; &quot;Wajah terdeteksi! Sekarang tersenyum&quot;&#10;                    }&#10;                )&#10;            }&#10;&#10;            LivenessState.WAITING_FOR_LIVENESS -&gt; {&#10;                // Cek apakah challenge liveness terpenuhi&#10;                checkLivenessChallenge(face)&#10;            }&#10;&#10;            else -&gt; {&#10;                // State lain tidak perlu di-handle di sini&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Cek apakah challenge liveness saat ini terpenuhi dengan progressive feedback&#10;     */&#10;    private fun checkLivenessChallenge(face: Face) {&#10;        val livenessResult = when (_uiState.value.currentChallenge) {&#10;            LivenessChallenge.BLINK -&gt; faceDetectorHelper.verifyBlink(face)&#10;            LivenessChallenge.SMILE -&gt; faceDetectorHelper.verifySmile(face)&#10;        }&#10;&#10;        when (livenessResult) {&#10;            LivenessResult.SUCCESS -&gt; {&#10;                // Liveness berhasil terdeteksi - lanjut ke verifikasi&#10;                _uiState.value = _uiState.value.copy(&#10;                    livenessState = LivenessState.LIVENESS_DETECTED,&#10;                    instructionText = &quot;Liveness terdeteksi! Tetap di posisi...&quot;&#10;                )&#10;&#10;                // Tahan deteksi sebentar untuk stabilitas, lalu lanjut verifikasi&#10;                livenessJob?.cancel()&#10;                livenessJob = viewModelScope.launch {&#10;                    delay(LIVENESS_HOLD_DURATION)&#10;                    proceedWithFaceVerification()&#10;                }&#10;            }&#10;&#10;            LivenessResult.IN_PROGRESS -&gt; {&#10;                // User hampir berhasil - berikan umpan balik yang memandu&#10;                val progressText = when (_uiState.value.currentChallenge) {&#10;                    LivenessChallenge.BLINK -&gt; &quot;Hampir berhasil! Coba kedipkan kedua mata bersamaan&quot;&#10;                    LivenessChallenge.SMILE -&gt; &quot;Bagus! Tersenyum sedikit lebih lebar lagi&quot;&#10;                }&#10;&#10;                _uiState.value = _uiState.value.copy(&#10;                    livenessState = LivenessState.WAITING_FOR_LIVENESS,&#10;                    instructionText = progressText&#10;                )&#10;            }&#10;&#10;            LivenessResult.FAILURE -&gt; {&#10;                // Belum berhasil - berikan instruksi yang jelas&#10;                val failureText = when (_uiState.value.currentChallenge) {&#10;                    LivenessChallenge.BLINK -&gt; &quot;Silakan kedipkan mata Anda dengan jelas&quot;&#10;                    LivenessChallenge.SMILE -&gt; &quot;Silakan tersenyum dengan lebih jelas&quot;&#10;                }&#10;&#10;                _uiState.value = _uiState.value.copy(&#10;                    livenessState = LivenessState.WAITING_FOR_LIVENESS,&#10;                    instructionText = failureText&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Lanjutkan dengan verifikasi wajah setelah liveness terkonfirmasi&#10;     */&#10;    private fun proceedWithFaceVerification() {&#10;        val face = currentDetectedFace&#10;        val bitmap = currentImageBitmap&#10;&#10;        if (face == null || bitmap == null) {&#10;            handleVerificationError(&quot;Gagal mengambil data wajah&quot;)&#10;            return&#10;        }&#10;&#10;        _uiState.value = _uiState.value.copy(&#10;            livenessState = LivenessState.VERIFYING_FACE,&#10;            isProcessing = true,&#10;            instructionText = &quot;Memverifikasi identitas Anda...&quot;,&#10;            showCountdown = false&#10;        )&#10;&#10;        viewModelScope.launch {&#10;            try {&#10;                // Ekstrak bitmap wajah dari gambar penuh&#10;                val faceBitmap = faceDetectorHelper.extractFaceBitmap(face, bitmap)&#10;&#10;                if (faceBitmap == null) {&#10;                    handleVerificationError(&quot;Gagal mengekstrak wajah dari gambar&quot;)&#10;                    return@launch&#10;                }&#10;&#10;                // Verifikasi wajah menggunakan VerifyFaceUseCase&#10;                verifyFaceUseCase(faceBitmap)&#10;                    .onSuccess { isMatch -&gt;&#10;                        if (isMatch) {&#10;                            handleVerificationSuccess()&#10;                        } else {&#10;                            handleVerificationError(&quot;Wajah tidak cocok dengan data yang tersimpan. Silakan coba lagi.&quot;)&#10;                        }&#10;                    }&#10;                    .onFailure { exception -&gt;&#10;                        handleVerificationError(&#10;                            exception.message ?: &quot;Gagal memverifikasi wajah. Silakan coba lagi.&quot;&#10;                        )&#10;                    }&#10;&#10;            } catch (e: Exception) {&#10;                handleVerificationError(&quot;Terjadi kesalahan: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Handle sukses verifikasi wajah&#10;     */&#10;    private fun handleVerificationSuccess() {&#10;        timeoutJob?.cancel()&#10;        livenessJob?.cancel()&#10;&#10;        _uiState.value = _uiState.value.copy(&#10;            livenessState = LivenessState.SUCCESS,&#10;            isProcessing = false,&#10;            instructionText = &quot;Verifikasi berhasil! Identitas terkonfirmasi.&quot;,&#10;            progress = 1f,&#10;            showCountdown = false,&#10;            errorMessage = null&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Handle error deteksi wajah&#10;     */&#10;    private fun handleFaceDetectionError(errorMessage: String) {&#10;        // Hanya update instruction jika masih dalam tahap deteksi&#10;        if (_uiState.value.livenessState == LivenessState.DETECTING_FACE) {&#10;            _uiState.value = _uiState.value.copy(&#10;                instructionText = &quot;Mencari wajah... Pastikan wajah terlihat jelas di dalam frame&quot;,&#10;                boundingBox = null&#10;            )&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Handle error verifikasi wajah&#10;     */&#10;    private fun handleVerificationError(errorMessage: String) {&#10;        timeoutJob?.cancel()&#10;        livenessJob?.cancel()&#10;&#10;        _uiState.value = _uiState.value.copy(&#10;            livenessState = LivenessState.FAILURE,&#10;            isProcessing = false,&#10;            instructionText = &quot;Verifikasi gagal&quot;,&#10;            errorMessage = errorMessage,&#10;            showCountdown = false&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Mulai countdown timer untuk timeout&#10;     */&#10;    private fun startTimeout() {&#10;        timeoutJob?.cancel()&#10;        timeoutJob = viewModelScope.launch {&#10;            repeat(TIMEOUT_SECONDS) { second -&gt;&#10;                val remainingTime = TIMEOUT_SECONDS - second&#10;                _uiState.value = _uiState.value.copy(&#10;                    timeRemaining = remainingTime,&#10;                    progress = second.toFloat() / TIMEOUT_SECONDS&#10;                )&#10;                delay(1000)&#10;&#10;                // Cek apakah proses sudah selesai&#10;                if (_uiState.value.livenessState == LivenessState.SUCCESS ||&#10;                    _uiState.value.livenessState == LivenessState.FAILURE&#10;                ) {&#10;                    return@launch&#10;                }&#10;            }&#10;&#10;            // Timeout tercapai&#10;            handleTimeout()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Handle timeout&#10;     */&#10;    private fun handleTimeout() {&#10;        livenessJob?.cancel()&#10;&#10;        _uiState.value = _uiState.value.copy(&#10;            livenessState = LivenessState.TIMEOUT,&#10;            isProcessing = false,&#10;            instructionText = &quot;Waktu habis&quot;,&#10;            errorMessage = &quot;Tidak dapat mendeteksi wajah dalam waktu $TIMEOUT_SECONDS detik. Silakan coba lagi.&quot;,&#10;            showCountdown = false,&#10;            timeRemaining = 0&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Bersihkan resources ketika ViewModel dihancurkan&#10;     */&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        timeoutJob?.cancel()&#10;        livenessJob?.cancel()&#10;        faceDetectorHelper.release()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>